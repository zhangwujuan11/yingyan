import Player from 'xgplayer'
import { EVENTS, common, Context } from 'xgplayer-helper-utils'
import HlsVodController from './hls-vod';

const { debounce } = common;
const HlsAllowedEvents = EVENTS.HlsAllowedEvents;
const REMUX_EVENTS = EVENTS.REMUX_EVENTS;
const HLS_EVENTS = EVENTS.HLS_EVENTS;
const MSE_EVENTS = EVENTS.MSE_EVENTS;

class HlsVodPlayer extends Player {
  constructor (options) {
    super(options)
    this.hlsOps = {};
    this.util = Player.util;
    this.util.deepCopy(this.hlsOps, options);
    this._handleSetCurrentTime = debounce(this._handleSetCurrentTime.bind(this), 200)
    this.onWaiting = this.onWaiting.bind(this)
    // this.started = false;
  }

  get currentTime () {
    return super.currentTime;
  }

  set currentTime (time) {
    this._handleSetCurrentTime(time);
  }

  get src () {
    return this.currentSrc;
  }

  set src (url) {
    this.onWaiting = this.onWaiting.bind(this)
    this.__core__.mse.destroy().then(() => {
      this._context.destroy();
      this._context = null;
      this.video.src = '';
      this.video.load();
      this.started = false;
      this.video.currentTime = 0;

      if (!this.paused) {
        this.pause()
        this.once('canplay', () => {
          this.play()
        })
      } else {
        this.play()
      }

      this.start(url)
    })
  }

  _handleSetCurrentTime (time) {
    time = parseFloat(time);
    if (time === this.currentTime) return;
    super.currentTime = time;
    if (this._context) {
      this.__core__.seek(time);
    }
  }
  play () {
    return this.video.play().catch((e) => {
      if (e && e.code === 20) { // fix: chrome The play() request was interrupted by a new load request.
        this.once('canplay', () => {
          this.video.play()
        })
      }
    })
  }
  replay () {
    this.__core__.mse.cleanBuffers().then(() => {
      this.__core__.replay();
      super.replay();
    })
  }

  _initEvents () {
    this.__core__.once(REMUX_EVENTS.INIT_SEGMENT, () => {
      const mse = this.__core__.mse;
      super.start(mse.url);
    });

    this.__core__.once(HLS_EVENTS.RETRY_TIME_EXCEEDED, () => {
      this.emit('error', new Player.Errors('network', this.config.url))
    })

    this.__core__.on(MSE_EVENTS.SOURCE_UPDATE_END, () => {
      this._onSourceUpdateEnd();
    })

    this.once('canplay', () => {
      if (this.config.autoplay) {
        this.play()
      }
    });
  }

  initHlsBackupEvents (hls, ctx) {
    hls.once(REMUX_EVENTS.INIT_SEGMENT, () => {
      if (!this.video.src) {
        console.log('挂载 src blob');
        const mse = hls.mse;
        super.start(mse.url);
      }
    });
    hls.once(EVENTS.REMUX_EVENTS.MEDIA_SEGMENT, () => {
      this.__core__ = hls;
      this.__core__.mse.cleanBuffers().then(() => {
        this.__core__.mse.resetContext(ctx);
        this.__core__.mse.doAppend()
        this._context = ctx;
      })
    })

    hls.once(EVENTS.LOADER_EVENTS.LOADER_ERROR, () => {
      ctx.destroy()
    })
  }

  _onSourceUpdateEnd () {
    if (this.video.readyState === 1 || this.video.readyState === 2) {
      const { gap, start, method } = this.detectBufferGap()
      if (gap) {
        if (method === 'ceil' && this.currentTime < Math[method](start)) {
          this.currentTime = Math[method](start);
        } else if (method === 'floor' && this.currentTime > Math[method](start)) {
          this.currentTime = Math[method](start);
        }
      }
    }
  }

  start (url = this.config.url) {
    if (!url || this.started) {
      return;
    }
    if (!this._context) {
      this._context = new Context(this, this.hlsOps, HlsAllowedEvents);
    }

    this.__core__ = this._context.registry('HLS_VOD_CONTROLLER', HlsVodController)({player: this, container: this.video, preloadTime: this.config.preloadTime});
    this._context.init();
    this.__core__.load(url);
    this._initEvents();

    this.started = true;
  }

  switchURL (url) {
    this.config.url = url;
    const context = new Context(this, this.hlsOps, HlsAllowedEvents);
    const hls = context.registry('HLS_VOD_CONTROLLER', HlsVodController)({
      player: this,
      container: this.video,
      mse: this.__core__.mse,
      preloadTime: this.config.preloadTime
    })
    this.newContext = context;
    this.newHls = hls;
    context.init()
    this._context.destroy();
    this.initHlsBackupEvents(hls, context)
    this.__core__.mse.cleanBuffers().then(() => {
      hls.load(url);
    })
  }

  destroy () {
    return new Promise((resolve) => {
      if (this.__core__ && this.__core__.mse) {
        this.__core__.mse.destroy().then(() => {
          if (this._context) {
            this._context.destroy();
          }
          super.destroy();
          resolve();
        })
        setTimeout(() => {
          resolve()
        }, 100)
      } else {
        super.destroy();
        setTimeout(() => {
          resolve()
        }, 50)
      }
    })
  }

  detectBufferGap () {
    const { video } = this;
    let result = {
      gap: false,
      start: -1
    }
    const isStartPlay = this.currentTime === 0
    for (let i = 0; i < video.buffered.length; i++) {
      const bufferStart = video.buffered.start(i)
      const bufferEnd = video.buffered.end(i)
      if ((!video.played.length || (bufferStart <= this.currentTime && bufferEnd - this.currentTime >= 0.5)) && !isStartPlay) {
        break;
      }
      const startGap = bufferStart - this.currentTime;
      const endGap = this.currentTime - bufferEnd;
      if (startGap > 0.01 && (startGap <= 2 || isStartPlay)) {
        result = {
          gap: true,
          start: bufferStart,
          method: 'ceil'
        };
        break;
      } else if (endGap > 0.1 && (endGap <= 2 || isStartPlay)) {
        result = {
          gap: true,
          start: bufferEnd,
          method: 'floor'
        };
      } else {
        result = {
          gap: false,
          start: -1
        }
      }
    }

    return result;
  }

  get context () {
    return this._context;
  }

  static isSupported () {
    return window.MediaSource &&
      window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  }

  static install (name, plugin) {
    return Player.install(name, plugin)
  }
}

export default HlsVodPlayer;
