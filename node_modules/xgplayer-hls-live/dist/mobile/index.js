(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('xgplayer')) :
  typeof define === 'function' && define.amd ? define(['xgplayer'], factory) :
  (global = global || self, global.HlsLiveMobilePlayer = factory(global.Player));
}(this, (function (Player) { 'use strict';

  Player = Player && Object.prototype.hasOwnProperty.call(Player, 'default') ? Player['default'] : Player;

  var BROWSER_EVENTS = {
    VISIBILITY_CHANGE: 'VISIBILITY_CHANGE'
  };
  var PLAYER_EVENTS = {
    SEEK: 'SEEK'
  };

  var LOADER_EVENTS = {
    LADER_START: 'LOADER_START',
    LOADER_DATALOADED: 'LOADER_DATALOADED',
    LOADER_COMPLETE: 'LOADER_COMPLETE',
    LOADER_RESPONSE_HEADERS: 'LOADER_RESPONSE_HEADERS',
    LOADER_ERROR: 'LOADER_ERROR',
    LOADER_RETRY: 'LOADER_RETRY',
    LOADER_TTFB: 'LOADER_TTFB'
  };

  var DEMUX_EVENTS = {
    DEMUX_START: 'DEMUX_START',
    DEMUX_COMPLETE: 'DEMUX_COMPLETE',
    DEMUX_ERROR: 'DEMUX_ERROR',
    METADATA_PARSED: 'METADATA_PARSED',
    SEI_PARSED: 'SEI_PARSED',
    VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',
    AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',
    MEDIA_INFO: 'MEDIA_INFO',
    ISKEYFRAME: 'ISKEYFRAME'
  };

  var REMUX_EVENTS = {
    REMUX_METADATA: 'REMUX_METADATA',
    REMUX_MEDIA: 'REMUX_MEDIA',
    MEDIA_SEGMENT: 'MEDIA_SEGMENT',
    REMUX_ERROR: 'REMUX_ERROR',
    INIT_SEGMENT: 'INIT_SEGMENT',
    DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM',
    DETECT_CHANGE_STREAM_DISCONTINUE: 'DETECT_CHANGE_STREAM_DISCONTINUE',
    DETECT_AUDIO_GAP: 'DETECT_AUDIO_GAP',
    DETECT_LARGE_GAP: 'DETECT_LARGE_GAP',
    DETECT_AUDIO_OVERLAP: 'DETECT_AUDIO_OVERLAP',
    RANDOM_ACCESS_POINT: 'RANDOM_ACCESS_POINT',
    DETECT_FRAG_ID_DISCONTINUE: 'DETECT_FRAG_ID_DISCONTINUE'
  };

  var MSE_EVENTS = {
    SOURCE_UPDATE_END: 'SOURCE_UPDATE_END',
    MSE_ERROR: 'MSE_ERROR',
    MSE_WRONG_TRACK_ADD: 'MSE_WRONG_TRACK_ADD'

    // hls专有events
  };var HLS_EVENTS = {
    RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'
  };

  var CRYPTO_EVENTS = {
    START_DECRYPTOO: 'START_DECRYPTO',
    DECRYPTED: 'DECRYPTED'
  };
  var ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS, PLAYER_EVENTS, BROWSER_EVENTS);

  var FlvAllowedEvents = [];
  var HlsAllowedEvents = [];

  for (var key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(key)) {
      FlvAllowedEvents.push(ALLEVENTS[key]);
    }
  }

  for (var _key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(_key)) {
      HlsAllowedEvents.push(ALLEVENTS[_key]);
    }
  }

  var EVENTS = {
    ALLEVENTS: ALLEVENTS,
    HLS_EVENTS: HLS_EVENTS,
    REMUX_EVENTS: REMUX_EVENTS,
    DEMUX_EVENTS: DEMUX_EVENTS,
    MSE_EVENTS: MSE_EVENTS,
    LOADER_EVENTS: LOADER_EVENTS,
    FlvAllowedEvents: FlvAllowedEvents,
    HlsAllowedEvents: HlsAllowedEvents,
    CRYPTO_EVENTS: CRYPTO_EVENTS,
    PLAYER_EVENTS: PLAYER_EVENTS,
    BROWSER_EVENTS: BROWSER_EVENTS
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * @typedef {Object} TSFrag
   * @property {number} duration
   * @property {boolean} downloaded
   * @property {boolean} downloading
   * @property {number=} start
   * @property {number} cc
   * @property {boolean} discontinue
   */

  var Playlist = function () {
    function Playlist(configs) {
      _classCallCheck(this, Playlist);

      /** @type {string} */
      this._baseURL = '';
      /** @type {Object.<number, string>} */
      this._list = {};
      /** @type {Object.<string, TSFrag>} */
      this._ts = {};
      /** @type {number} */
      this.version = 0;
      /** @type {number} */
      this.sequence = -1;
      /** @type {number} */
      this.targetduration = 0;
      /** @type {number} */
      this.duration = 0;
      /** @type {number} */
      this.fragLength = 0;
      /** @type {TSFrag | undefined} */
      this._lastget = undefined;
      /** @type {boolean} */
      this.end = false; // 判断live | vod , 对点播或直播结束时存在 EXT-X-ENDLIST
      /** @type {boolean} */
      this.autoclear = configs.autoclear || false;
      /** @type {*} */
      this.logger = configs.logger;
      /** @type {string[]} */
      this.downloadedUrls = [];
      this._avgSegmentDuration = 4;
    }

    /**
     * @return {Object<number, string>}
     */

    _createClass(Playlist, [{
      key: 'push',

      /**
       * add a ts frag to play list
       * @param {string} tsURL ts frag url
       * @param {number} duration ts frag duration
       * @param {boolean} discontinue has #EXT-X-DISCONTINUITY tag before this frag
       * @param {number} id
       * @param {number} cc
       */
      value: function push(tsURL, duration, discontinue, id, cc, isLast) {
        if (!this._ts[tsURL]) {
          this._ts[tsURL] = {
            duration: duration,
            downloaded: false,
            downloading: false,
            start: this.duration,
            discontinue: !!discontinue,
            id: id,
            cc: cc,
            isLast: isLast || false
          };
          this._list[this.duration] = tsURL;
          this.duration += duration;
          this.fragLength += 1;
        }
      }

      /**
       * delete a fragment from playlist
       * @param {string} url
       */

    }, {
      key: 'deleteFrag',
      value: function deleteFrag(url) {
        if (this._ts[url]) {
          if (this._ts[url].start > this._lastget.time) {
            this._lastget = {
              duration: this._ts[url].duration,
              time: this._ts[url].start,
              downloaded: false,
              downloading: false,
              url: url,
              id: this._ts[url].id
            };
          }
          delete this._list[this._ts[url].start];
          delete this._ts[url];
          this.fragLength -= 1;
        }
      }
    }, {
      key: '_calcAvgFrgmentDuration',
      value: function _calcAvgFrgmentDuration(data) {
        if (!data.frags) return data.targetduration;
        var fragLen = data.frags.length;
        return Math.floor(data.duration / fragLen / 1000);
      }

      /**
       * add m3u8 to current play list
       * @param {*} data
       * @param {boolean} deletepre
       */

    }, {
      key: 'pushM3U8',
      value: function pushM3U8(data, deletepre) {
        // 常规信息替换
        if (!data) {
          throw new Error('No m3u8 data received.');
        }
        this.version = data.version;

        this.targetduration = data.targetduration;

        this._avgSegmentDuration = Math.min(this.targetduration, this._calcAvgFrgmentDuration(data));

        if (data.encrypt && !this.encrypt) {
          this.encrypt = data.encrypt;
        }

        this.end = data.end || false;

        if (!data.sequence) {
          data.sequence = 0;
        }

        // 新分片信息
        if (data.sequence > this.sequence) {
          var len = data.frags.length;
          if (this.logger) {
            this.logger.log('PLAYLIST', 'new playlist [' + data.sequence + ', ' + (data.sequence + len - 1) + ']');
          }
          this.sequence = data.sequence;
          var newfraglist = [];
          for (var i = 0; i < len; i++) {
            var frag = data.frags[i];
            if (!this._ts[frag.url] && this.downloadedUrls.indexOf(frag.url) < 0) {
              newfraglist.push(frag.url);
              this.push(frag.url, frag.duration, frag.discontinue, frag.id, frag.cc, frag.isLast);
            }
          }

          if (newfraglist.length < 1) {
            throw new Error('Can not read ts file list.');
          }

          if (deletepre) {
            var tslist = this.getTsList();
            for (var _i = 0; _i < tslist.length; _i++) {
              if (newfraglist.indexOf(tslist[_i]) < 0) {
                this.deleteFrag(tslist[_i]);
              }
            }
          }
        } else {
          throw new Error('Old m3u8 file received, ' + data.sequence);
        }
      }

      /**
       * return ts url list
       * @return {string[]}
       */

    }, {
      key: 'getTsList',
      value: function getTsList() {
        return Object.keys(this._ts);
      }

      /**
       * mark a ts frag as downloaded / not downloaded
       * @param {string} tsname
       * @param {boolean} isloaded
       */

    }, {
      key: 'downloaded',
      value: function downloaded(tsname, isloaded) {
        var ts = this._ts[tsname];
        if (ts) {
          ts.downloaded = isloaded;
        }
      }

      /**
       * mark a ts frag as loading / not loading
       * @param {string} tsname
       * @param {boolean} loading
       */

    }, {
      key: 'downloading',
      value: function downloading(tsname, loading) {
        var ts = this._ts[tsname];
        if (ts) {
          ts.downloading = loading;
        }
      }

      /**
       * get a frag by ts name
       * @param name
       * @return {TSFrag}
       */

    }, {
      key: 'getTsByName',
      value: function getTsByName(name) {
        return this._ts[name];
      }

      /**
       * get ts frag by timestamp
       * @param {number} time
       * @return {undefined|TSFrag}
       */

    }, {
      key: 'getTs',
      value: function getTs(time) {
        var timelist = Object.keys(this._list);
        var ts = void 0;

        if (time === undefined) {
          if (this._lastget) {
            time = this._lastget.time + this._lastget.duration;
          } else {
            time = 0;
          }
        }

        if (timelist.length < 1 || time >= this.duration) {
          return undefined;
        }
        timelist = timelist.sort(function (a, b) {
          return parseFloat(a) - parseFloat(b);
        });
        for (var i = 0; i < timelist.length; i++) {
          if (time >= parseInt(timelist[i])) {
            var url = this._list[timelist[i]];
            var downloaded = this._ts[url].downloaded;
            var downloading = this._ts[url].downloading;
            ts = {
              url: url,
              downloaded: downloaded,
              downloading: downloading,
              time: parseInt(timelist[i]),
              duration: parseInt(this._ts[url].duration),
              id: this._ts[url].id,
              cc: this._ts[url].cc,
              isLast: this._ts[url].isLast
            };
            if (this.autoclear && this._lastget) {
              delete this._ts[this._lastget.url];
              delete this._list[this._lastget.time];
            }
            this._lastget = ts;
          } else {
            break;
          }
        }
        if (ts) {
          this.downloadedUrls.push(ts.url);
        }
        return ts;
      }

      /**
       * get last downloaded ts frag
       * @return {TSFrag|undefined}
       */

    }, {
      key: 'getLastDownloadedTs',
      value: function getLastDownloadedTs() {
        var timelist = Object.keys(this._list).sort(function (a, b) {
          var result = Number(a) - Number(b);
          return result;
        });
        var found = void 0;
        for (var i = 0; i < timelist.length; i++) {
          var url = this._list[timelist[i]];
          var downloaded = this._ts[url].downloaded;
          var downloading = this._ts[url].downloading;
          if (downloaded) {
            found = { url: url, downloaded: downloaded, downloading: downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };
          } else {
            break;
          }
        }

        return found;
      }
    }, {
      key: 'clear',
      value: function clear() {
        this._baseURL = '';
        this._list = {};
        this._ts = {};
        this.version = 0;
        this.sequence = -1;
        this.targetduration = 0;
        this.duration = 0;
      }
    }, {
      key: 'clearDownloaded',
      value: function clearDownloaded() {
        var list = Object.keys(this._ts);
        for (var i = 0, l = list.length; i < l; i++) {
          var ts = this._ts[list[i]];
          ts.downloaded = false;
          ts.downloading = false;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._baseURL = '';
        this._list = {};
        this._ts = {};
        this.version = 0;
        this.sequence = -1;
        this.targetduration = 0;
        this.duration = 0;
        this.fragLength = 0;
        this._lastget = undefined;
        this.autoclear = false;
      }
    }, {
      key: 'resetSequence',
      value: function resetSequence() {
        this.sequence = -1;
      }
    }, {
      key: 'list',
      get: function get() {
        return this._list;
      }

      /**
       * @param {string} baseURL
       */

    }, {
      key: 'baseURL',
      set: function set(baseURL) {
        if (this.baseURL !== baseURL) {
          this.clear();
          this._baseURL = baseURL;
        }
      }

      /**
       * base cdn url for ts fragments
       * @return {string}
       */

      , get: function get() {
        return this._baseURL;
      }
    }, {
      key: 'avgSegmentDuration',
      get: function get() {
        return this._avgSegmentDuration;
      }
    }]);

    return Playlist;
  }();

  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var XGDataView = function () {
    function XGDataView(buffer) {
      _classCallCheck$1(this, XGDataView);

      if (buffer instanceof ArrayBuffer) {
        /** @type {ArrayBuffer} */
        this.buffer = buffer;
        /** @type {DataView} */
        this.dataview = new DataView(buffer);
        /** @type {number} */
        this.dataview.position = 0;
      } else {
        throw new Error('data is invalid');
      }
    }

    /**
     * byffer length
     * @return {number}
     */

    _createClass$1(XGDataView, [{
      key: 'back',

      /**
       * move read position backward
       * @param count
       */
      value: function back(count) {
        this.position -= count;
      }
    }, {
      key: 'getUint8',
      value: function getUint8(offset) {
        return this.dataview.getUint8(offset);
      }

      /**
       * move read position forward
       * @param count
       */

    }, {
      key: 'skip',
      value: function skip(count) {
        var loop = Math.floor(count / 4);
        var last = count % 4;
        for (var i = 0; i < loop; i++) {
          XGDataView.readByte(this.dataview, 4);
        }
        if (last > 0) {
          XGDataView.readByte(this.dataview, last);
        }
      }

      /**
       * [readByte 从DataView中读取数据]
       * @param  {DataView} buffer [DataView实例]
       * @param  {Number} size   [读取字节数]
       * @return {Number}        [整数]
       */

    }, {
      key: 'readUint8',

      /**
       * @return {Number}
       */
      value: function readUint8() {
        return XGDataView.readByte(this.dataview, 1);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readUint16',
      value: function readUint16() {
        return XGDataView.readByte(this.dataview, 2);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readUint24',
      value: function readUint24() {
        return XGDataView.readByte(this.dataview, 3);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readUint32',
      value: function readUint32() {
        return XGDataView.readByte(this.dataview, 4);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readUint64',
      value: function readUint64() {
        return XGDataView.readByte(this.dataview, 8);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readInt8',
      value: function readInt8() {
        return XGDataView.readByte(this.dataview, 1, true);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readInt16',
      value: function readInt16() {
        return XGDataView.readByte(this.dataview, 2, true);
      }

      /**
       * @return {Number}
       */

    }, {
      key: 'readInt32',
      value: function readInt32() {
        return XGDataView.readByte(this.dataview, 4, true);
      }

      /**
       * @return {Uint8Array}
       */

    }, {
      key: 'writeUint32',
      value: function writeUint32(value) {
        return new Uint8Array([value >>> 24 & 0xff, value >>> 16 & 0xff, value >>> 8 & 0xff, value & 0xff]);
      }
    }, {
      key: 'length',
      get: function get() {
        return this.buffer.byteLength;
      }

      /**
       * set current read position of data-view
       * @param value
       */

    }, {
      key: 'position',
      set: function set(value) {
        this.dataview.position = value;
      }

      /**
       * set current read position of data-view
       * @param value
       */

      , get: function get() {
        return this.dataview.position;
      }
    }], [{
      key: 'readByte',
      value: function readByte(buffer, size, sign) {
        var res = void 0;
        switch (size) {
          case 1:
            if (sign) {
              res = buffer.getInt8(buffer.position);
            } else {
              res = buffer.getUint8(buffer.position);
            }
            break;
          case 2:
            if (sign) {
              res = buffer.getInt16(buffer.position);
            } else {
              res = buffer.getUint16(buffer.position);
            }
            break;
          case 3:
            if (sign) {
              throw new Error('not supported for readByte 3');
            } else {
              res = buffer.getUint8(buffer.position) << 16;
              res |= buffer.getUint8(buffer.position + 1) << 8;
              res |= buffer.getUint8(buffer.position + 2);
            }
            break;
          case 4:
            if (sign) {
              res = buffer.getInt32(buffer.position);
            } else {
              res = buffer.getUint32(buffer.position);
            }
            break;
          case 8:
            if (sign) {
              throw new Error('not supported for readBody 8');
            } else {
              res = buffer.getUint32(buffer.position) << 32;
              res |= buffer.getUint32(buffer.position + 4);
            }
            break;
          default:
            res = '';
        }
        buffer.position += size;
        return res;
      }
    }]);

    return XGDataView;
  }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$2 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Track = function () {
    function Track() {
      _classCallCheck$2(this, Track);

      /** @type {number} */
      this.id = -1;
      /** @type {number} */
      this.sequenceNumber = 0;
      /** @type {*} */
      this.samples = [];
      /** @type {*} */
      this.droppedSamples = [];
      /** @type {number} */
      this.length = 0;
    }

    _createClass$2(Track, [{
      key: 'reset',
      value: function reset() {
        this.sequenceNumber = 0;
        this.samples = [];
        this.length = 0;
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.reset();
        this.id = -1;
      }
    }]);

    return Track;
  }();

  var AudioTrack = function (_Track) {
    _inherits(AudioTrack, _Track);

    function AudioTrack() {
      _classCallCheck$2(this, AudioTrack);

      /** @type {string} */
      var _this = _possibleConstructorReturn(this, (AudioTrack.__proto__ || Object.getPrototypeOf(AudioTrack)).call(this));

      _this.TAG = 'AudioTrack';
      /** @type {string} */
      _this.type = 'audio';
      return _this;
    }

    return AudioTrack;
  }(Track);

  var VideoTrack = function (_Track2) {
    _inherits(VideoTrack, _Track2);

    function VideoTrack() {
      _classCallCheck$2(this, VideoTrack);

      /** @type {string} */
      var _this2 = _possibleConstructorReturn(this, (VideoTrack.__proto__ || Object.getPrototypeOf(VideoTrack)).call(this));

      _this2.TAG = 'VideoTrack';
      /** @type {string} */
      _this2.type = 'video';
      /** @type {number} */
      _this2.dropped = 0;
      /** @type {number} */
      _this2.sequenceNumber = 0;
      return _this2;
    }

    _createClass$2(VideoTrack, [{
      key: 'reset',
      value: function reset() {
        this.sequenceNumber = 0;
        this.samples = [];
        this.length = 0;
        this.dropped = 0;
      }
    }]);

    return VideoTrack;
  }(Track);

  var Tracks = function () {
    function Tracks() {
      _classCallCheck$2(this, Tracks);

      this.audioTrack = null;
      this.videoTrack = null;
    }

    _createClass$2(Tracks, [{
      key: 'destroy',
      value: function destroy() {
        this.audioTrack = null;
        this.videoTrack = null;
      }
    }]);

    return Tracks;
  }();

  var _createClass$3 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var XgBuffer = function () {
    /**
     * A buffer to store loaded data.
     *
     * @class LoaderBuffer
     * @param {number} length - Optional the buffer size
     */
    function XgBuffer(length) {
      _classCallCheck$3(this, XgBuffer);

      this.length = length || 0;
      this.historyLen = length || 0;
      this.array = [];
      this.offset = 0;
    }

    /**
     * The function to push data.
     *
     * @param {Uint8Array} data - The data to push into the buffer
     */

    _createClass$3(XgBuffer, [{
      key: "push",
      value: function push(data) {
        this.array.push(data);
        this.length += data.byteLength;
        this.historyLen += data.byteLength;
      }

      /**
       * The function to shift data.
       *
       * @param {number} length - The size of shift.
       */

    }, {
      key: "shift",
      value: function shift(length) {
        if (this.array.length < 1) {
          return new Uint8Array(0);
        }

        if (length === undefined) {
          return this._shiftBuffer();
        }
        if (this.offset + length === this.array[0].length) {
          var _ret = this.array[0].slice(this.offset, this.offset + length);
          this.offset = 0;
          this.array.shift();
          this.length -= length;
          return _ret;
        }

        if (this.offset + length < this.array[0].length) {
          var _ret2 = this.array[0].slice(this.offset, this.offset + length);
          this.offset += length;
          this.length -= length;
          return _ret2;
        }

        var ret = new Uint8Array(length);
        var tmpoff = 0;
        while (this.array.length > 0 && length > 0) {
          if (this.offset + length < this.array[0].length) {
            var tmp = this.array[0].slice(this.offset, this.offset + length);
            ret.set(tmp, tmpoff);
            this.offset += length;
            this.length -= length;
            length = 0;
            break;
          } else {
            // console.log('mark1')
            var templength = this.array[0].length - this.offset;
            ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);
            this.array.shift();
            this.offset = 0;
            tmpoff += templength;
            this.length -= templength;
            length -= templength;
          }
        }
        return ret;
      }

      /**
       * Function to clear the buffer.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.array = [];
        this.length = 0;
        this.offset = 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.historyLen = 0;
      }

      /**
       * Function to shift one unit8Array.
       */

    }, {
      key: "_shiftBuffer",
      value: function _shiftBuffer() {
        this.length -= this.array[0].length;
        this.offset = 0;
        return this.array.shift();
      }

      /**
       * Convert uint8 data to number.
       *
       * @param {number} start - the start postion.
       * @param {number} length - the length of data.
       */

    }, {
      key: "toInt",
      value: function toInt(start, length) {
        var retInt = 0;
        var i = this.offset + start;
        while (i < this.offset + length + start) {
          if (i < this.array[0].length) {
            retInt = retInt * 256 + this.array[0][i];
          } else if (this.array[1]) {
            retInt = retInt * 256 + this.array[1][i - this.array[0].length];
          }

          i++;
        }
        return retInt;
      }
    }]);

    return XgBuffer;
  }();

  var _createClass$4 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var AudioTrackMeta = function () {
    function AudioTrackMeta(meta) {
      _classCallCheck$4(this, AudioTrackMeta);

      var _default = {
        sampleRate: 48000,
        channelCount: 2,
        codec: 'mp4a.40.2',
        config: [41, 401, 136, 0],
        duration: 0,
        id: 2,
        refSampleDuration: 21,
        sampleRateIndex: 3,
        timescale: 1000,
        type: 'audio'
      };
      if (meta) {
        return Object.assign({}, _default, meta);
      }
      return _default;
    }

    _createClass$4(AudioTrackMeta, [{
      key: 'destroy',
      value: function destroy() {
        this.init = null;
      }
    }]);

    return AudioTrackMeta;
  }();

  var VideoTrackMeta = function () {
    function VideoTrackMeta(meta) {
      _classCallCheck$4(this, VideoTrackMeta);

      var _default = {
        avcc: null,
        sps: new Uint8Array(0),
        pps: new Uint8Array(0),
        chromaFormat: 420,
        codec: 'avc1.640020',
        codecHeight: 720,
        codecWidth: 1280,
        duration: 0,
        frameRate: {
          fixed: true,
          fps: 25,
          fps_num: 25000,
          fps_den: 1000
        },
        id: 1,
        level: '3.2',
        presentHeight: 720,
        presentWidth: 1280,
        profile: 'High',
        refSampleDuration: 40,
        parRatio: {
          height: 1,
          width: 1
        },
        timescale: 1000,
        type: 'video'
      };

      if (meta) {
        return Object.assign({}, _default, meta);
      }
      return _default;
    }

    _createClass$4(VideoTrackMeta, [{
      key: 'destroy',
      value: function destroy() {
        this.init = null;
        this.sps = null;
        this.pps = null;
      }
    }]);

    return VideoTrackMeta;
  }();

  var _createClass$5 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * @typedef {Object} TAudioSample
   * @property {number} dts
   * @property {number} pts
   * @property {number} originDts
   * @property {Uint8Array} data
   */

  /**
   * @typedef {Object} TVideoSample
   * @property {number} dts
   * @property {number} pts
   * @property {boolean} isKeyframe
   * @property {number} originDts
   * @property {Uint8Array} data
   * @property {Array<any>} nals
   */

  var AudioSample = function () {
    function AudioSample(info) {
      _classCallCheck$5(this, AudioSample);

      var _default = AudioSample.getDefault();
      if (!info) {
        return _default;
      }
      return Object.assign({}, _default, info);
    }

    /**
     * default audio sample
     * @return {TAudioSample}
     */

    _createClass$5(AudioSample, null, [{
      key: "getDefault",
      value: function getDefault() {
        return {
          dts: -1,
          pts: -1,
          originDts: -1,
          data: new Uint8Array()
        };
      }
    }]);

    return AudioSample;
  }();

  var VideoSample = function () {
    /**
     * @constructor
     * @param info
     * @return {TVideoSample}
     */
    function VideoSample(info) {
      _classCallCheck$5(this, VideoSample);

      var _default = VideoSample.getDefault();

      if (!info) {
        return _default;
      }
      var sample = Object.assign({}, _default, info);

      return sample;
    }

    /**
     * default video sample
     * @return {TVideoSample}
     */

    _createClass$5(VideoSample, null, [{
      key: "getDefault",
      value: function getDefault() {
        return {
          dts: -1,
          pts: undefined,
          isKeyframe: false, // is Random access point
          originDts: -1,
          data: new Uint8Array(),
          nals: []
        };
      }
    }]);

    return VideoSample;
  }();

  var _createClass$6 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * @typedef {Object} VideoMediaInfo
   * @property {string|null} codec
   * @property {number|null} width
   * @property {number|null} height
   * @property {string|null} profile
   * @property {{fixed: boolean,fps: number,fps_num: number,fps_den: number}} frameRate
   * @property {string|null} chromaFormat
   * @property {{width:number,height:number}} parRatio
   */

  /**
   * @typedef {Object} AudioMediaInfo
   * @property {string|null} codec
   * @property {number|null} sampleRate
   * @property {number|null} sampleRateIndex
   * @property {number|null} channelCount
   */

  /**
   * @param {Object} obj
   * @return {boolean}
   */
  var isObjectFilled = function isObjectFilled(obj) {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (obj[key] === null) {
          return false;
        }
      }
    }
    return true;
  };

  var MediaInfo = function () {
    function MediaInfo() {
      _classCallCheck$6(this, MediaInfo);

      this.mimeType = null;
      this.duration = null;

      /** @type {boolean} */
      this.hasVideo = false;
      /**
       * video media info
       * @type {VideoMediaInfo}
       */
      this.video = {
        codec: null,
        width: null,
        height: null,
        profile: null,
        level: null,
        frameRate: {
          fixed: true,
          fps: 25,
          fps_num: 25000,
          fps_den: 1000
        },
        chromaFormat: null,
        parRatio: {
          width: 1,
          height: 1
          /** @type {boolean} */
        } };this.hasAudio = false;

      /**
       * video media info
       * @type {AudioMediaInfo}
       */
      this.audio = {
        codec: null,
        sampleRate: null,
        sampleRateIndex: null,
        channelCount: null
      };
    }

    _createClass$6(MediaInfo, [{
      key: "isComplete",
      value: function isComplete() {
        return MediaInfo.isBaseInfoReady(this) && MediaInfo.isVideoReady(this) && MediaInfo.isAudioReady(this);
      }
    }], [{
      key: "isBaseInfoReady",
      value: function isBaseInfoReady(mediaInfo) {
        return isObjectFilled(mediaInfo);
      }
    }, {
      key: "isVideoReady",
      value: function isVideoReady(mediaInfo) {
        if (!mediaInfo.hasVideo) {
          return true;
        }

        return isObjectFilled(mediaInfo.video);
      }
    }, {
      key: "isAudioReady",
      value: function isAudioReady(mediaInfo) {
        if (!mediaInfo.hasAudio) {
          return true;
        }

        return isObjectFilled(mediaInfo.video);
      }
    }]);

    return MediaInfo;
  }();

  var _createClass$7 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * @typedef {Object} TsFragProps
   * @property {number} start
   * @property {number} duration
   * @property {string} url
   * @property {boolean} discontinue
   * @property {number} id
   * @property {number} cc
   */
  var TsFrag = function () {
    _createClass$7(TsFrag, null, [{
      key: 'getDefault',

      /**
       *
       * @return TsFrag
       */
      value: function getDefault() {
        return {
          id: -1,
          url: '',
          start: -1,
          duration: -1,
          discontinue: false,
          cc: -1
        };
      }
      /**
       *
       * @param {TsFragProps} props
       */

    }]);

    function TsFrag(props) {
      _classCallCheck$7(this, TsFrag);

      var merged = Object.assign({}, TsFrag.getDefault(), props);

      this.id = merged.id;

      this.url = merged.url;

      this.start = merged.start;

      this.duration = merged.duration;

      this.discontinue = merged.discontinue;

      this.cc = merged.cc;
    }

    return TsFrag;
  }();

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty,
      prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
        events,
        name;

    if (this._eventsCount === 0) return names;

    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  var _createClass$8 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn$1(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$1(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$1(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DIRECT_EMIT_FLAG = '__TO__';

  var Context = function () {
    /**
     *
     * @param {*} player
     * @param {*} configs
     * @param {string[]}allowedEvents
     */
    function Context(player, configs) {
      var allowedEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      _classCallCheck$8(this, Context);

      this._emitter = new eventemitter3();
      if (!this._emitter.off) {
        this._emitter.off = this._emitter.removeListener;
      }

      this.mediaInfo = new MediaInfo();
      this._instanceMap = {}; // 所有的解码流程实例
      this._clsMap = {}; // 构造函数的map
      this._inited = false;
      this.allowedEvents = allowedEvents;
      this._configs = configs;
      this._player = player;
      this._hooks = {}; // 注册在事件前/后的钩子，例如 before('DEMUX_COMPLETE')
    }

    /**
     * 从上下文中获取解码流程实例，如果没有实例，构造一个
     * @param {string} tag
     * @returns {*}
     */

    _createClass$8(Context, [{
      key: 'getInstance',
      value: function getInstance(tag) {
        var instance = this._instanceMap[tag];
        if (instance) {
          return instance;
        } else {
          // throw new Error(`${tag}实例尚未初始化`)
          return null;
        }
      }

      /**
       * 初始化具体实例
       * @param {string} tag
       * @param {any[]}args
       */

    }, {
      key: 'initInstance',
      value: function initInstance(tag) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var a = args[0],
            b = args[1],
            c = args[2],
            d = args[3];

        if (this._clsMap[tag]) {
          var newInstance = new this._clsMap[tag](a, b, c, d);
          this._instanceMap[tag] = newInstance;
          if (newInstance.init) {
            newInstance.init(); // TODO: lifecircle
          }
          return newInstance;
        } else {
          throw new Error(tag + "\u672A\u5728context\u4E2D\u6CE8\u518C");
        }
      }

      /**
       * 避免大量的initInstance调用，初始化所有的组件
       * @param {*} config
       */

    }, {
      key: 'init',
      value: function init(config) {
        if (this._inited) {
          return;
        }
        for (var tag in this._clsMap) {
          // if not inited, init an instance
          if (this._clsMap.hasOwnProperty(tag) && !this._instanceMap[tag]) {
            this.initInstance(tag, config);
          }
        }
        this._inited = true;
      }

      /**
       * 注册一个上下文流程，提供安全的事件发送机制
       * @param {string} tag
       * @param {*} cls
       */

    }, {
      key: 'registry',
      value: function registry(tag, cls) {
        var _this2 = this;

        var emitter = this._emitter;
        var checkMessageName = this._isMessageNameValid.bind(this);
        var self = this;
        var enhanced = function (_cls) {
          _inherits$1(enhanced, _cls);

          function enhanced(a, b, c) {
            _classCallCheck$8(this, enhanced);

            var _this = _possibleConstructorReturn$1(this, (enhanced.__proto__ || Object.getPrototypeOf(enhanced)).call(this, a, b, c));

            _this.listeners = {};
            _this.onceListeners = {};
            _this.TAG = tag;
            _this._context = self;
            return _this;
          }

          /**
           * @param {string} messageName
           * @param {function} callback
           */

          _createClass$8(enhanced, [{
            key: 'on',
            value: function on(messageName, callback) {
              checkMessageName(messageName);

              if (this.listeners[messageName]) {
                this.listeners[messageName].push(callback);
              } else {
                this.listeners[messageName] = [callback];
              }

              emitter.on('' + messageName + DIRECT_EMIT_FLAG + tag, callback); // 建立定向通信监听
              return emitter.on(messageName, callback);
            }

            /**
             * @param {string} messageName
             * @param {function} callback
             */

          }, {
            key: 'before',
            value: function before(messageName, callback) {
              checkMessageName(messageName);
              if (self._hooks[messageName]) {
                self._hooks[messageName].push(callback);
              } else {
                self._hooks[messageName] = [callback];
              }
            }

            /**
             * @param {string} messageName
             * @param {function} callback
             */

          }, {
            key: 'once',
            value: function once(messageName, callback) {
              checkMessageName(messageName);

              if (this.onceListeners[messageName]) {
                this.onceListeners[messageName].push(callback);
              } else {
                this.onceListeners[messageName] = [callback];
              }

              emitter.once('' + messageName + DIRECT_EMIT_FLAG + tag, callback);
              return emitter.once(messageName, callback);
            }

            /**
             * @param {string} messageName
             * @param {any[]} args
             */

          }, {
            key: 'emit',
            value: function emit(messageName) {
              checkMessageName(messageName);
              // console.log('emit ', messageName);

              var beforeList = self._hooks ? self._hooks[messageName] : null;

              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }

              if (beforeList) {
                for (var i = 0, len = beforeList.length; i < len; i++) {
                  var callback = beforeList[i];
                  // eslint-disable-next-line standard/no-callback-literal
                  callback.apply(undefined, args);
                }
              }
              return emitter.emit.apply(emitter, [messageName].concat(args));
            }

            /**
             * 定向发送给某个组件单例的消息
             * @param {string} messageName
             * @param {any[]} args
             */

          }, {
            key: 'emitTo',
            value: function emitTo(tag, messageName) {
              checkMessageName(messageName);

              for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                args[_key3 - 2] = arguments[_key3];
              }

              return emitter.emit.apply(emitter, ['' + messageName + DIRECT_EMIT_FLAG + tag].concat(args));
            }

            /**
             * 定向发送给某个组件单例的消息
             * @param {string} messageName
             * @param {function} callback
             */

          }, {
            key: 'off',
            value: function off(messageName, callback) {
              checkMessageName(messageName);
              return emitter.off(messageName, callback);
            }
          }, {
            key: 'removeListeners',
            value: function removeListeners() {
              var hasOwn = Object.prototype.hasOwnProperty.bind(this.listeners);

              for (var messageName in this.listeners) {
                if (hasOwn(messageName)) {
                  var callbacks = this.listeners[messageName] || [];
                  for (var i = 0; i < callbacks.length; i++) {
                    var callback = callbacks[i];
                    emitter.off(messageName, callback);
                    emitter.off('' + messageName + DIRECT_EMIT_FLAG + tag, callback);
                  }
                }
              }

              for (var _messageName in this.onceListeners) {
                if (hasOwn(_messageName)) {
                  var _callbacks = this.onceListeners[_messageName] || [];
                  for (var _i = 0; _i < _callbacks.length; _i++) {
                    var _callback = _callbacks[_i];
                    emitter.off(_messageName, _callback);
                    emitter.off('' + _messageName + DIRECT_EMIT_FLAG + tag, _callback);
                  }
                }
              }
            }

            /**
             * 在组件销毁时，默认将它注册的事件全部卸载，确保不会造成内存泄漏
             */

          }, {
            key: 'destroy',
            value: function destroy() {
              // step1 unlisten events
              this.removeListeners();
              this.listeners = {};
              // step2 release from context
              delete self._instanceMap[tag];
              if (_get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this)) {
                return _get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this).call(this);
              }
              this._context = null;
            }
          }, {
            key: '_player',
            get: function get() {
              if (!this._context) {
                return null;
              }
              return this._context._player;
            },
            set: function set(v) {
              if (this._context) {
                this._context._player = v;
              }
            }
          }, {
            key: '_pluginConfig',
            get: function get() {
              if (!this._context) {
                return null;
              }
              return this._context._configs;
            }
          }]);

          return enhanced;
        }(cls);
        this._clsMap[tag] = enhanced;

        /**
         * get instance immediately
         * e.g const instance = context.registry(tag, Cls)(config)
         * */
        return function () {
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return _this2.initInstance.apply(_this2, [tag].concat(args));
        };
      }

      /**
       * 各个模块处理seek
       * @param {number} time
       */

    }, {
      key: 'seek',
      value: function seek(time) {
        this._emitter.emit(EVENTS.PLAYER_EVENTS.SEEK, time);
      }

      /**
       * 对存在的实例进行
       */

    }, {
      key: 'destroyInstances',
      value: function destroyInstances() {
        var _this3 = this;

        Object.keys(this._instanceMap).forEach(function (tag) {
          if (_this3._instanceMap[tag].destroy) {
            _this3._instanceMap[tag].destroy();
          }
        });
      }

      /**
       * 编解码流程无需关注事件的解绑
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.destroyInstances();
        if (this._emitter) {
          this._emitter.removeAllListeners();
        }
        this._emitter = null;
        this.allowedEvents = [];
        this._clsMap = null;
        this._hooks = null;
        this._player = null;
        this._configs = null;
      }

      /**
       * 对信道进行收拢
       * @param {string} messageName
       * @private
       */

    }, {
      key: '_isMessageNameValid',
      value: function _isMessageNameValid(messageName) {
        if (!this.allowedEvents.indexOf(messageName) < 0) {
          throw new Error('unregistered message name: ' + messageName);
        }
      }
    }]);

    return Context;
  }();

  var _createClass$9 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var CRYPTO_EVENTS$1 = EVENTS.CRYPTO_EVENTS;

  var Crypto = function () {
    function Crypto(config) {
      _classCallCheck$9(this, Crypto);

      this.inputBuffer = config.inputbuffer;
      this.outputBuffer = config.outputbuffer;
      this.key = config.key;
      this.iv = config.iv;
      this.method = config.method;

      this.crypto = window.crypto || window.msCrypto;
    }

    _createClass$9(Crypto, [{
      key: 'init',
      value: function init() {
        this.on(CRYPTO_EVENTS$1.START_DECRYPTO, this.decrypto.bind(this));
      }
    }, {
      key: 'decrypto',
      value: function decrypto() {
        var _this = this;

        if (!this.aeskey) {
          var sbkey = this.crypto.subtle.importKey('raw', this.key.buffer, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
          sbkey.then(function (key) {
            _this.aeskey = key;
            _this.decryptoData();
          });
        } else {
          this.decryptoData();
        }
      }
    }, {
      key: 'decryptoData',
      value: function decryptoData() {
        var _this2 = this;

        var inputbuffer = this._context.getInstance(this.inputBuffer);
        var outputbuffer = this._context.getInstance(this.outputBuffer);
        var data = inputbuffer.shift();
        if (data) {
          this.crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv.buffer }, this.aeskey, data).then(function (res) {
            outputbuffer.push(new Uint8Array(res));
            _this2.emit(CRYPTO_EVENTS$1.DECRYPTED);
            _this2.decryptoData(data);
          });
        }
      }
    }]);

    return Crypto;
  }();

  var _createClass$a = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$a(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Speed = function () {
    function Speed() {
      _classCallCheck$a(this, Speed);

      // milliseconds
      this._firstCheckpoint = 0;
      this._lastCheckpoint = 0;
      this._intervalBytes = 0;
      this._lastSamplingBytes = 0;

      this._now = Date.now;
    }

    _createClass$a(Speed, [{
      key: "reset",
      value: function reset() {
        this._firstCheckpoint = this._lastCheckpoint = 0;
        this._intervalBytes = 0;
        this._lastSamplingBytes = 0;
      }
    }, {
      key: "addBytes",
      value: function addBytes(bytes) {
        var duration = this._now() - this._lastCheckpoint;
        if (this._firstCheckpoint === 0) {
          this._firstCheckpoint = this._now();
          this._lastCheckpoint = this._firstCheckpoint;
          this._intervalBytes += bytes;
        } else if (duration < 5000) {
          this._intervalBytes += bytes;
        } else {
          // duration >= 1000
          this._lastSamplingBytes = this._intervalBytes / (duration / 1000);
          this._intervalBytes = bytes;
          this._lastCheckpoint = this._now();
        }
      }
    }, {
      key: "currentKBps",
      get: function get() {
        this.addBytes(0);

        var durationSeconds = (this._now() - this._lastCheckpoint) / 1000;
        if (durationSeconds === 0) durationSeconds = 1;
        return this._intervalBytes / durationSeconds / 1024;
      }
    }, {
      key: "lastSamplingKBps",
      get: function get() {
        this.addBytes(0);

        if (this._lastSamplingBytes !== 0) {
          return this._lastSamplingBytes / 1024;
        } else {
          // lastSecondBytes === 0
          if (this._now() - this._lastCheckpoint >= 500) {
            // if time interval since last checkpoint has exceeded 500ms
            // the speed is nearly accurate
            return this.currentKBps;
          } else {
            // We don't know
            return 0;
          }
        }
      }
    }]);

    return Speed;
  }();

  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _typeof$2 = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  };

  var _createClass$b = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$b(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOADER_EVENTS$1 = EVENTS.LOADER_EVENTS;
  var READ_STREAM = 0;
  var READ_TEXT = 1;
  var READ_JSON = 2;
  var READ_BUFFER = 3;

  var FetchLoader = function () {
    function FetchLoader(configs) {
      _classCallCheck$b(this, FetchLoader);

      this.configs = Object.assign({}, configs);
      this.url = null;
      this.status = 0;
      this.error = null;
      this._reader = null;
      this._canceled = false;
      this._destroyed = false;
      this.readtype = this.configs.readtype;
      this.buffer = this.configs.buffer || 'LOADER_BUFFER';
      this._loaderTaskNo = 0;
      this._ttfb = 0;
      this._speed = new Speed();
      if (window.AbortController) {
        this.abortControllerEnabled = true;
      }
    }

    _createClass$b(FetchLoader, [{
      key: 'init',
      value: function init() {
        this.on(LOADER_EVENTS$1.LADER_START, this.load.bind(this));
      }
    }, {
      key: 'fetch',

      /**
       * @param {string}      url
       * @param {RequestInit} params
       * @param {number}      timeout
       * @return {Promise<unknown>}
       */
      value: function (_fetch) {
        function fetch(_x, _x2, _x3) {
          return _fetch.apply(this, arguments);
        }

        fetch.toString = function () {
          return _fetch.toString();
        };

        return fetch;
      }(function (url, params, timeout) {
        var _this2 = this;

        var timer = null;
        if (this.abortControllerEnabled) {
          this.abortController = new window.AbortController();
        }
        Object.assign(params, { signal: this.abortController ? this.abortController.signal : undefined });
        var start = new Date().getTime();
        return Promise.race([fetch(url, params), new Promise(function (resolve, reject) {
          timer = setTimeout(function () {
            /* eslint-disable-next-line */
            reject({
              code: 999,
              message: 'fetch timeout'
            });
            if (_this2.abortController) {
              _this2.abortController.abort();
            }
          }, timeout || 1e4); // 10s
        })]).then(function (response) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          var end = new Date().getTime();
          _this2.emit(LOADER_EVENTS$1.LOADER_TTFB, {
            start: start,
            end: end,
            elapsed: end - start
          });
          return response;
        });
      })

      /**
       * @param {string}      url
       * @param {RequestInit} params
       * @param {number}      retryTimes
       * @param {number}      totalRetry
       * @param {number}      delayTime
       * @return {Promise<{ok}>}
       */

    }, {
      key: 'internalLoad',
      value: function internalLoad(url, params, retryTimes, totalRetry) {
        var _this3 = this;

        var delayTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var loadTimeout = arguments[5];

        if (this._destroyed) return;
        this.loading = true;
        return this.fetch(this.url, params, loadTimeout).then(function (response) {
          !_this3._destroyed && _this3.emit(LOADER_EVENTS$1.LOADER_RESPONSE_HEADERS, _this3.TAG, response.headers);

          if (response.ok) {
            _this3.status = response.status;
            Promise.resolve().then(function () {
              _this3._onFetchResponse(response);
            });

            return Promise.resolve(response);
          }

          if (retryTimes-- > 0) {
            _this3._retryTimer = setTimeout(function () {
              _this3.emit(LOADER_EVENTS$1.LOADER_RETRY, _this3.TAG, {
                response: response,
                reason: 'response not ok',
                retryTime: totalRetry - retryTimes
              });
              return _this3.internalLoad(url, params, retryTimes, totalRetry, delayTime, loadTimeout);
            }, delayTime);
          } else {
            _this3.loading = false;
            _this3.emit(LOADER_EVENTS$1.LOADER_ERROR, _this3.TAG, {
              code: response.status || 21,
              message: response.status + ' (' + response.statusText + ')'
            });
          }
        }).catch(function (error) {
          if (_this3._destroyed) {
            _this3.loading = false;
            return;
          }

          if (retryTimes-- > 0) {
            _this3._retryTimer = setTimeout(function () {
              _this3.emit(LOADER_EVENTS$1.LOADER_RETRY, _this3.TAG, {
                error: error,
                reason: 'fetch error',
                retryTime: totalRetry - retryTimes
              });
              return _this3.internalLoad(url, params, retryTimes, totalRetry, delayTime, loadTimeout);
            }, delayTime);
          } else {
            _this3.loading = false;
            if (error && error.name === 'AbortError') {
              return;
            }
            _this3.emit(LOADER_EVENTS$1.LOADER_ERROR, _this3.TAG, Object.assign({ code: 21 }, error));
          }
        });
      }

      /**
       * @param {string}      url
       * @param {RequestInit} opts
       * @param {retryCount, retryDelay, loadTimeout}  pluginConfig
       * @return {Promise<{ok}>}
       */

    }, {
      key: 'load',
      value: function load(url) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            retryCount = _ref.retryCount,
            retryDelay = _ref.retryDelay,
            loadTimeout = _ref.loadTimeout;

        retryCount = retryCount === undefined ? 3 : retryCount;
        this.url = url;
        this._canceled = false;

        // TODO: Add Ranges
        var params = this.getParams(opts);

        return this.internalLoad(url, params, retryCount, retryCount, retryDelay, loadTimeout);
      }
    }, {
      key: '_onFetchResponse',
      value: function _onFetchResponse(response) {
        var _this4 = this;

        var _this = this;
        var buffer = this._context.getInstance(this.buffer);
        this._loaderTaskNo++;
        var taskno = this._loaderTaskNo;
        if (response.ok === true) {
          switch (this.readtype) {
            case READ_JSON:
              response.json().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_TEXT:
              response.text().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_BUFFER:
              response.arrayBuffer().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(new Uint8Array(data));
                    _this4._speed.addBytes(data.byteLength);
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              }).catch(function () {});
              break;
            case READ_STREAM:
            default:
              return this._onReader(response.body.getReader(), taskno);
          }
        }
      }
    }, {
      key: '_onReader',
      value: function _onReader(reader, taskno) {
        var _this5 = this;

        var buffer = this._context.getInstance(this.buffer);
        if (!buffer && this._reader || this._destroyed) {
          try {
            this._reader.cancel();
          } catch (e) {
            // DO NOTHING
          }
        }

        this._reader = reader;
        if (this.loading === false) {
          return;
        }

        // reader read function returns a Promise. get data when callback and has value.done when disconnected.
        // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。
        this._noDataTimer = setTimeout(function () {
          if (_this5.loading === false) return;
          _this5.emit(LOADER_EVENTS$1.LOADER_COMPLETE);
        }, 3000);
        this._reader && this._reader.read().then(function (val) {
          clearTimeout(_this5._noDataTimer);
          if (_this5._canceled || _this5._destroyed) {
            if (_this5._reader) {
              try {
                _this5._reader.cancel();
              } catch (e) {
                // DO NOTHING
              }
            }
            return;
          }
          if (val.done) {
            _this5.loading = false;
            _this5.status = 0;
            Promise.resolve().then(function () {
              _this5.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
            });
            return;
          }

          buffer.push(val.value);
          _this5._speed.addBytes(val.value.byteLength);
          Promise.resolve().then(function () {
            _this5.emit(LOADER_EVENTS$1.LOADER_DATALOADED, buffer);
          });
          return _this5._onReader(reader, taskno);
        }).catch(function (error) {
          clearTimeout(_this5._noDataTimer);
          _this5.loading = false;
          if (error && error.name === 'AbortError') return;
          _this5.emit(LOADER_EVENTS$1.LOADER_ERROR, _this5.TAG, error);
        });
      }

      /**
       *
       * @param {RequestInit} opts
       * @return {{mode: string, headers: Headers, cache: string, method: string}}
       */

    }, {
      key: 'getParams',
      value: function getParams(opts) {
        var options = Object.assign({}, opts);
        var headers = new Headers();

        var params = {
          method: 'GET',
          headers: headers,
          mode: 'cors',
          cache: 'default'

          // add custmor headers
          // 添加自定义头
        };if (_typeof$2(this.configs.headers) === 'object') {
          var configHeaders = this.configs.headers;
          for (var key in configHeaders) {
            if (configHeaders.hasOwnProperty(key)) {
              headers.append(key, configHeaders[key]);
            }
          }
        }

        if (_typeof$2(options.headers) === 'object') {
          var optHeaders = options.headers;
          for (var _key in optHeaders) {
            if (optHeaders.hasOwnProperty(_key)) {
              headers.append(_key, optHeaders[_key]);
            }
          }
        }

        if (options.cors === false) {
          params.mode = 'same-origin';
        }

        // withCredentials is disabled by default
        // withCredentials 在默认情况下不被使用。
        if (options.withCredentials) {
          params.credentials = 'include';
        }

        // TODO: Add ranges;
        return params;
      }

      // in KB/s

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this._reader) {
          try {
            this._reader.cancel();
          } catch (e) {
            // 防止failed: 200错误被打印到控制台上
          }
          this._reader = null;
          this.loading = false;
        }
        clearTimeout(this._noDataTimer);
        this._canceled = true;
        if (this.abortController) {
          this.abortController.abort();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._destroyed = true;
        clearTimeout(this._retryTimer);
        clearTimeout(this._noDataTimer);
        this.cancel();
        this._speed.reset();
      }
    }, {
      key: 'currentSpeed',
      get: function get() {
        return this._speed.lastSamplingKBps;
      }
    }], [{
      key: 'isSupported',
      value: function isSupported() {
        return !!window.fetch;
      }
    }, {
      key: 'type',
      get: function get() {
        return 'loader';
      }
    }]);

    return FetchLoader;
  }();

  var _createClass$c = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck$c(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DevLogger = function () {
    function DevLogger() {
      var _this = this;

      _classCallCheck$c(this, DevLogger);

      try {
        var matched = /xgd=(\d)/.exec(document.cookie);
        this._status = !!matched;
        this._level = matched && matched[1];
      } catch (e) {
        this._status = false;
      }

      ['group', 'groupEnd', 'log', 'warn', 'error'].forEach(function (funName) {
        _this[funName] = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
          var _console;

          if (!_this._status) return;
          var tagName = arg1;
          var args = [arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10].filter(function (x) {
            return x !== undefined;
          });
          (_console = console)[funName].apply(_console, ['[' + tagName + ']:'].concat(_toConsumableArray(args)));
        };
      });
    }

    /**
     * @return {*|boolean|boolean}
     */

    _createClass$c(DevLogger, [{
      key: 'enable',
      get: function get() {
        return this._status;
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'long',
      get: function get() {
        return this._level === '2';
      }
    }]);

    return DevLogger;
  }();

  var logger = new DevLogger();

  var _createClass$d = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$d(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ADTS = function () {
    function ADTS() {
      _classCallCheck$d(this, ADTS);
    }

    _createClass$d(ADTS, null, [{
      key: "isHeader",
      value: function isHeader(data, offset) {
        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        // Layer bits (position 14 and 15) in header should be always 0 for ADTS
        // More info https://wiki.multimedia.cx/index.php?title=ADTS
        if (offset + 1 < data.length && ADTS.isHeaderPattern(data, offset)) {
          return true;
        }

        return false;
      }
    }, {
      key: "getFrameDuration",
      value: function getFrameDuration(samplerate) {
        return 1024 * 90000 / samplerate;
      }
    }, {
      key: "isHeaderPattern",
      value: function isHeaderPattern(data, offset) {
        return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
      }
    }, {
      key: "getHeaderLength",
      value: function getHeaderLength(data, offset) {
        return data[offset + 1] & 0x01 ? 7 : 9;
      }
    }, {
      key: "getFullFrameLength",
      value: function getFullFrameLength(data, offset) {
        return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
      }
    }, {
      key: "parseFrameHeader",
      value: function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
        var headerLength = void 0,
            frameLength = void 0,
            stamp = void 0;
        var length = data.length;

        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = ADTS.getHeaderLength(data, offset);
        // retrieve frame size
        frameLength = ADTS.getFullFrameLength(data, offset);
        frameLength -= headerLength;

        if (frameLength > 0 && offset + headerLength + frameLength <= length) {
          stamp = pts + frameIndex * frameDuration;
          // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
        }

        return undefined;
      }
    }, {
      key: "appendFrame",
      value: function appendFrame(sampleRate, data, offset, pts, frameIndex) {
        var frameDuration = ADTS.getFrameDuration(sampleRate);
        var header = ADTS.parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
        if (header) {
          var stamp = header.stamp;
          var headerLength = header.headerLength;
          var frameLength = header.frameLength;

          // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          var aacSample = {
            unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
            pts: stamp,
            dts: stamp
          };

          return { sample: aacSample, length: frameLength + headerLength };
        }

        return undefined;
      }
    }]);

    return ADTS;
  }();

  var _createClass$e = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$e(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Golomb = function () {
    /**
     * @param {Uint8Array} uint8array
     */
    function Golomb(uint8array) {
      _classCallCheck$e(this, Golomb);

      this.TAG = 'Golomb';
      this._buffer = uint8array;
      this._bufferIndex = 0;
      this._totalBytes = uint8array.byteLength;
      this._totalBits = uint8array.byteLength * 8;
      this._currentWord = 0;
      this._currentWordBitsLeft = 0;
    }

    _createClass$e(Golomb, [{
      key: 'destroy',
      value: function destroy() {
        this._buffer = null;
      }
    }, {
      key: '_fillCurrentWord',
      value: function _fillCurrentWord() {
        var bufferBytesLeft = this._totalBytes - this._bufferIndex;

        var bytesRead = Math.min(4, bufferBytesLeft);
        var word = new Uint8Array(4);
        word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
        this._currentWord = new DataView(word.buffer).getUint32(0);

        this._bufferIndex += bytesRead;
        this._currentWordBitsLeft = bytesRead * 8;
      }

      /**
       * @param size
       * @return {number|*|number}
       */

    }, {
      key: 'readBits',
      value: function readBits(size) {
        var bits = Math.min(this._currentWordBitsLeft, size); // :uint
        var valu = this._currentWord >>> 32 - bits;
        if (size > 32) {
          throw new Error('Cannot read more than 32 bits at a time');
        }
        this._currentWordBitsLeft -= bits;
        if (this._currentWordBitsLeft > 0) {
          this._currentWord <<= bits;
        } else if (this._totalBytes - this._bufferIndex > 0) {
          this._fillCurrentWord();
        }

        bits = size - bits;
        if (bits > 0 && this._currentWordBitsLeft) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'readBool',
      value: function readBool() {
        return this.readBits(1) === 1;
      }

      /**
       * @return {*|number}
       */

    }, {
      key: 'readByte',
      value: function readByte() {
        return this.readBits(8);
      }
    }, {
      key: '_skipLeadingZero',
      value: function _skipLeadingZero() {
        var zeroCount = void 0;
        for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
          if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {
            this._currentWord <<= zeroCount;
            this._currentWordBitsLeft -= zeroCount;
            return zeroCount;
          }
        }
        this._fillCurrentWord();
        return zeroCount + this._skipLeadingZero();
      }

      /**
       * @return {number}
       */

    }, {
      key: 'readUEG',
      value: function readUEG() {
        // unsigned exponential golomb
        var leadingZeros = this._skipLeadingZero();
        return this.readBits(leadingZeros + 1) - 1;
      }

      /**
       * @return {number}
       */

    }, {
      key: 'readSEG',
      value: function readSEG() {
        // signed exponential golomb
        var value = this.readUEG();
        if (value & 0x01) {
          return value + 1 >>> 1;
        } else {
          return -1 * (value >>> 1);
        }
      }
    }, {
      key: 'readSliceType',
      value: function readSliceType() {
        // skip NALu type Nal unit header 8bit
        this.readByte();
        // discard first_mb_in_slice
        this.readUEG();
        // return slice_type
        return this.readUEG();
      }
    }]);

    return Golomb;
  }();

  var _createClass$f = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$f(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SPSParser = function () {
    function SPSParser() {
      _classCallCheck$f(this, SPSParser);
    }

    _createClass$f(SPSParser, null, [{
      key: '_ebsp2rbsp',

      /**
       * 0x00000300  -> 0x000000
       * 0x00000301  -> 0x000001
       * 0x00000302  -> 0x000002
       * 0x00000303  -> 0x000003
       */
      value: function _ebsp2rbsp(uint8array) {
        var src = uint8array;
        var srcLength = src.byteLength;
        var dst = new Uint8Array(srcLength);
        var dstIdx = 0;

        for (var i = 0; i < srcLength; i++) {
          if (i >= 2) {
            if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
              continue;
            }
          }
          dst[dstIdx] = src[i];
          dstIdx++;
        }

        return new Uint8Array(dst.buffer, 0, dstIdx);
      }
    }, {
      key: 'parseSPS',
      value: function parseSPS(uint8array) {
        var rbsp = SPSParser._ebsp2rbsp(uint8array);
        var gb = new Golomb(rbsp);

        gb.readByte();
        var profileIdc = gb.readByte();
        gb.readByte();
        var levelIdc = gb.readByte();
        gb.readUEG();

        var profile_string = SPSParser.getProfileString(profileIdc);
        var level_string = SPSParser.getLevelString(levelIdc);
        var chroma_format_idc = 1;
        var chroma_format = 420;
        var chroma_format_table = [0, 420, 422, 444];
        var bit_depth = 8;

        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {
          chroma_format_idc = gb.readUEG();
          if (chroma_format_idc === 3) {
            gb.readBits(1);
          }
          if (chroma_format_idc <= 3) {
            chroma_format = chroma_format_table[chroma_format_idc];
          }

          bit_depth = gb.readUEG() + 8;
          gb.readUEG();
          gb.readBits(1);
          if (gb.readBool()) {
            var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;
            for (var i = 0; i < scaling_list_count; i++) {
              if (gb.readBool()) {
                if (i < 6) {
                  SPSParser._skipScalingList(gb, 16);
                } else {
                  SPSParser._skipScalingList(gb, 64);
                }
              }
            }
          }
        }
        gb.readUEG();
        var pic_order_cnt_type = gb.readUEG();
        if (pic_order_cnt_type === 0) {
          gb.readUEG();
        } else if (pic_order_cnt_type === 1) {
          gb.readBits(1);
          gb.readSEG();
          gb.readSEG();
          var num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();
          for (var _i = 0; _i < num_ref_frames_in_pic_order_cnt_cycle; _i++) {
            gb.readSEG();
          }
        }
        gb.readUEG();
        gb.readBits(1);

        var pic_width_in_mbs_minus1 = gb.readUEG();
        var pic_height_in_map_units_minus1 = gb.readUEG();

        var frame_mbs_only_flag = gb.readBits(1);
        if (frame_mbs_only_flag === 0) {
          gb.readBits(1);
        }
        gb.readBits(1);

        var frame_crop_left_offset = 0;
        var frame_crop_right_offset = 0;
        var frame_crop_top_offset = 0;
        var frame_crop_bottom_offset = 0;

        var frame_cropping_flag = gb.readBool();
        if (frame_cropping_flag) {
          frame_crop_left_offset = gb.readUEG();
          frame_crop_right_offset = gb.readUEG();
          frame_crop_top_offset = gb.readUEG();
          frame_crop_bottom_offset = gb.readUEG();
        }

        var par_width = 1;var par_height = 1;
        var fps = 0;var fps_fixed = true;var fps_num = 0;var fps_den = 0;

        var vui_parameters_present_flag = gb.readBool();
        if (vui_parameters_present_flag) {
          if (gb.readBool()) {
            // aspect_ratio_info_present_flag
            var aspect_ratio_idc = gb.readByte();
            var par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
            var par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];

            if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
              par_width = par_w_table[aspect_ratio_idc - 1];
              par_height = par_h_table[aspect_ratio_idc - 1];
            } else if (aspect_ratio_idc === 255) {
              par_width = gb.readByte() << 8 | gb.readByte();
              par_height = gb.readByte() << 8 | gb.readByte();
            }
          }

          if (gb.readBool()) {
            gb.readBool();
          }
          if (gb.readBool()) {
            gb.readBits(4);
            if (gb.readBool()) {
              gb.readBits(24);
            }
          }
          if (gb.readBool()) {
            gb.readUEG();
            gb.readUEG();
          }
          if (gb.readBool()) {
            var num_units_in_tick = gb.readBits(32);
            var time_scale = gb.readBits(32);
            fps_fixed = gb.readBool();

            fps_num = time_scale;
            fps_den = num_units_in_tick * 2;
            fps = fps_num / fps_den;
          }
        }

        var parScale = 1;
        if (par_width !== 1 || par_height !== 1) {
          parScale = par_width / par_height;
        }

        var crop_unit_x = 0;var crop_unit_y = 0;
        if (chroma_format_idc === 0) {
          crop_unit_x = 1;
          crop_unit_y = 2 - frame_mbs_only_flag;
        } else {
          var sub_wc = chroma_format_idc === 3 ? 1 : 2;
          var sub_hc = chroma_format_idc === 1 ? 2 : 1;
          crop_unit_x = sub_wc;
          crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);
        }

        var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;
        var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);

        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;
        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;

        var present_width = Math.ceil(codec_width * parScale);

        gb.destroy();
        gb = null;

        return {
          profile_string: profile_string,
          level_string: level_string,
          bit_depth: bit_depth,
          chroma_format: chroma_format,
          chroma_format_string: SPSParser.getChromaFormatString(chroma_format),

          frame_rate: {
            fixed: fps_fixed,
            fps: fps,
            fps_den: fps_den,
            fps_num: fps_num
          },

          par_ratio: {
            width: par_width,
            height: par_height
          },

          codec_size: {
            width: codec_width,
            height: codec_height
          },

          present_size: {
            width: present_width,
            height: codec_height
          }
        };
      }
    }, {
      key: '_skipScalingList',
      value: function _skipScalingList(gb, count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale = 0;
        for (var i = 0; i < count; i++) {
          if (nextScale !== 0) {
            deltaScale = gb.readSEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      }
    }, {
      key: 'getProfileString',
      value: function getProfileString(profileIdc) {
        switch (profileIdc) {
          case 66:
            return 'Baseline';
          case 77:
            return 'Main';
          case 88:
            return 'Extended';
          case 100:
            return 'High';
          case 110:
            return 'High10';
          case 122:
            return 'High422';
          case 244:
            return 'High444';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'getLevelString',
      value: function getLevelString(levelIdc) {
        return (levelIdc / 10).toFixed(1);
      }
    }, {
      key: 'getChromaFormatString',
      value: function getChromaFormatString(chroma) {
        switch (chroma) {
          case 420:
            return '4:2:0';
          case 422:
            return '4:2:2';
          case 444:
            return '4:4:4';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'toVideoMeta',
      value: function toVideoMeta(spsConfig) {
        var meta = {};
        if (spsConfig && spsConfig.codec_size) {
          meta.codecWidth = spsConfig.codec_size.width;
          meta.codecHeight = spsConfig.codec_size.height;
          meta.presentWidth = spsConfig.present_size.width;
          meta.presentHeight = spsConfig.present_size.height;
        }

        meta.profile = spsConfig.profile_string;
        meta.level = spsConfig.level_string;
        meta.bitDepth = spsConfig.bit_depth;
        meta.chromaFormat = spsConfig.chroma_format;

        meta.parRatio = {
          width: spsConfig.par_ratio.width,
          height: spsConfig.par_ratio.height
        };

        meta.frameRate = spsConfig.frame_rate;

        var fpsDen = meta.frameRate.fps_den;
        var fpsNum = meta.frameRate.fps_num;
        meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum));
        return meta;
      }
    }]);

    return SPSParser;
  }();

  var _createClass$g = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$g(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var RBSP = function () {
    function RBSP() {
      _classCallCheck$g(this, RBSP);
    }

    _createClass$g(RBSP, null, [{
      key: "EBSP2RBSP",

      /**
       * convert EBSP to RBSP
       * @param data {Uint8Array}
       * @returns {Uint8Array}
       * @constructor
       */
      value: function EBSP2RBSP(data) {
        return data.filter(function (el, idx) {
          if (idx < 2) {
            return true;
          } else {
            return !(data[idx - 2] === 0 && data[idx - 1] === 0 && el === 3);
          }
        });
      }

      /**
       * EBSP = SODB + '10000000'
       * @param data {Uint8Array}
       * @constructor
       */

    }, {
      key: "EBSP2SODB",
      value: function EBSP2SODB(data) {
        var lastByte = data[data.byteLength - 1];
        if (lastByte && lastByte === 128) {
          return data.slice(0, data.byteLength - 1);
        }

        return data;
      }
    }]);

    return RBSP;
  }();

  var _createClass$h = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$h(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var u8aToString = function u8aToString(data) {
    var result = '';
    for (var i = 0; i < data.byteLength; i++) {
      result += String.fromCharCode(data[i]);
    }
    return result;
  };

  var SEIParser = function () {
    function SEIParser() {
      _classCallCheck$h(this, SEIParser);
    }

    _createClass$h(SEIParser, null, [{
      key: '_resolveNalu',
      value: function _resolveNalu(data) {
        if (data.length >= 1) {
          return RBSP.EBSP2SODB(RBSP.EBSP2RBSP(data.slice(1)));
        }
        return null;
      }
      /**
       *
       * @param data {Uint8Array}
       */

    }, {
      key: 'parse',
      value: function parse(data) {
        var sodb = SEIParser._resolveNalu(data);

        var _SEIParser$switchPayl = SEIParser.switchPayloadType(sodb),
            payloadType = _SEIParser$switchPayl.payloadType,
            offset = _SEIParser$switchPayl.offset;

        var content = sodb.slice(offset);

        switch (payloadType) {
          case 5:
            return SEIParser.user_data_unregistered(content);
          default:
            return {
              code: payloadType,
              content: content
            };
        }
      }

      /**
       *
       * @param data
       * @returns {{payloadType: number, offset: number}}
       */

    }, {
      key: 'switchPayloadType',
      value: function switchPayloadType(data) {
        var dv = new DataView(data.buffer);
        var payloadType = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadType += 255;
        }
        payloadType += dv.getUint8(offset++);

        return {
          payloadType: payloadType,
          offset: offset
        };
      }

      /**
       *
       * @param data {Uint8Array}
       * @return {{ payloadLength: number, offset: number }}
       */

    }, {
      key: 'getPayloadLength',
      value: function getPayloadLength(data) {
        var dv = new DataView(data.buffer);

        var payloadLength = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadLength += 255;
        }
        payloadLength += dv.getUint8(offset++);

        return {
          payloadLength: payloadLength,
          offset: offset
        };
      }

      /**
       * resolve 0x05 user data unregistered
       * @param data {Uint8Array}
       */
      // eslint-disable-next-line camelcase

    }, {
      key: 'user_data_unregistered',
      value: function user_data_unregistered(data) {
        var _SEIParser$getPayload = SEIParser.getPayloadLength(data),
            payloadLength = _SEIParser$getPayload.payloadLength,
            offset = _SEIParser$getPayload.offset;

        if (payloadLength < 16) {
          return {
            uuid: '',
            content: null
          };
        }
        var payload = data.slice(offset);

        var uuid = u8aToString(payload.slice(0, 16));
        var content = u8aToString(payload.slice(16, payloadLength));

        return {
          code: 5, // for user data unregistered
          uuid: uuid,
          content: content
        };
      }
    }]);

    return SEIParser;
  }();

  var _createClass$i = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$i(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Nalunit = function () {
    function Nalunit() {
      _classCallCheck$i(this, Nalunit);
    }

    _createClass$i(Nalunit, null, [{
      key: 'getNalunits',

      // https://en.wikipedia.org/wiki/Network_Abstraction_Layer
      value: function getNalunits(buffer) {
        if (buffer.length - buffer.position < 4) {
          return [];
        }

        var buf = buffer.dataview;
        var position = buffer.position;
        // 0x001 || 0x0001
        if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {
          return Nalunit.getAnnexbNals(buffer);
        } else {
          return Nalunit.getAvccNals(buffer);
        }
      }
    }, {
      key: 'getAnnexbNals',
      value: function getAnnexbNals(buffer) {
        var nals = [];
        var position = Nalunit.getHeaderPositionAnnexB(buffer);
        var start = position.pos;
        var end = start;
        while (start < buffer.length - 4) {
          var header = buffer.buffer.slice(start, start + position.headerLength);
          if (position.pos === buffer.position) {
            buffer.skip(position.headerLength);
          }
          position = Nalunit.getHeaderPositionAnnexB(buffer);
          end = position.pos;
          var body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));
          var unit = { header: header, body: body };
          Nalunit.analyseNal(unit);
          if (unit.type <= 9 && unit.type !== 0) {
            nals.push(unit);
          }
          buffer.skip(end - buffer.position);
          start = end;
        }
        return nals;
      }
    }, {
      key: 'getAvccNals',
      value: function getAvccNals(buffer) {
        // buffer.buffer = RBSP.EBSP2RBSP(new Uint8Array(buffer.buffer)).buffer;
        // buffer.dataview = new DataView(buffer.buffer)
        // buffer.dataview.position = 0;
        var nals = [];
        while (buffer.position < buffer.length - 4) {
          var length = buffer.dataview.getInt32(buffer.dataview.position);
          if (buffer.length - buffer.position >= length) {
            var header = buffer.buffer.slice(buffer.position, buffer.position + 4);
            buffer.skip(4);
            var body = new Uint8Array(buffer.buffer.slice(buffer.position, buffer.position + length));
            buffer.skip(length);
            var unit = { header: header, body: body };
            Nalunit.analyseNal(unit);
            if (unit.type <= 9 && unit.type !== 0) {
              nals.push(unit);
            }
          } else {
            break;
          }
        }
        return nals;
      }

      // * ISO-14496-10 7.3.1
      // *  forbidden_zero_bit  1bit
      // *  nal_ref_idc  2bit
      // *  nal_unit_type 5bit

    }, {
      key: 'analyseNal',
      value: function analyseNal(unit) {
        var type = unit.body[0] & 0x1f;
        unit.type = type;
        switch (type) {
          case 1:
            // NDR
            unit.ndr = true;
            break;
          case 5:
            // IDR
            unit.idr = true;
            break;
          case 6:
            // SEI
            try {
              unit.sei = SEIParser.parse(unit.body);
            } catch (e) {}
            break;
          case 7:
            // SPS
            unit.sps = SPSParser.parseSPS(unit.body);
            break;
          case 8:
            // PPS
            unit.pps = true;
            break;
        }
      }
    }, {
      key: 'getHeaderPositionAnnexB',
      value: function getHeaderPositionAnnexB(buffer) {
        // seperate
        var pos = buffer.position;
        var headerLength = 0;
        var bufferLen = buffer.length;
        while (headerLength !== 3 && headerLength !== 4 && pos < bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            } else if (buffer.dataview.getInt8(pos + 2) === 1) {
              headerLength = 3;
            } else {
              pos++;
            }
          } else {
            pos++;
          }
        }

        if (pos === bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            } else {
              pos = bufferLen;
            }
          } else {
            pos++;
            if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {
              // 0x0000001
              headerLength = 3;
            } else {
              pos = bufferLen;
            }
          }
        }
        return { pos: pos, headerLength: headerLength };
      }

      // 组装AvcDecoderConfigurationRecord
      // *  configurationVerison = 1  uint(8)
      // *  avcProfileIndication      uint(8)
      // *  profile_compatibility     uint(8)
      // *  avcLevelIndication        uint(8)
      // *  reserved   `111111`       bit(6)
      // *  lengthSizeMinusOne        uint(2)
      // *  reserved   `111`          bit(3)
      // *  numOfSPS                  uint(5)
      // *  for(numOfSPS)
      // *    spsLength               uint(16)
      // *    spsNALUnit              spsLength个字节
      // *  numOfPPS                  uint(8)
      // *  for(numOfPPS)
      // *     ppsLength              uint(16)
      // *     ppsNALUnit             ppsLength个字节

    }, {
      key: 'getAvcc',
      value: function getAvcc(sps, pps) {
        var ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);
        ret[0] = 0x01;
        ret[1] = sps[1];
        ret[2] = sps[2];
        ret[3] = sps[3];
        ret[4] = 255;
        ret[5] = 225; // 11100001

        var offset = 6;

        ret.set(new Uint8Array([sps.byteLength >>> 8 & 0xff, sps.byteLength & 0xff]), offset);
        offset += 2;
        ret.set(sps, offset);
        offset += sps.byteLength;

        ret[offset] = 1;
        offset++;

        ret.set(new Uint8Array([pps.byteLength >>> 8 & 0xff, pps.byteLength & 0xff]), offset);
        offset += 2;
        ret.set(pps, offset);
        return ret;
      }
    }]);

    return Nalunit;
  }();



  var _avc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SpsParser: SPSParser,
    NalUnit: Nalunit,
    SEIParser: SEIParser,
    Golomb: Golomb
  });

  var _createClass$j = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$j(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Golomb$1 = function () {
    /**
     * @param {Uint8Array} uint8array
     */
    function Golomb(uint8array) {
      _classCallCheck$j(this, Golomb);

      this.TAG = 'Golomb';
      this._buffer = uint8array;
      this._bufferIndex = 0;
      this._totalBytes = uint8array.byteLength;
      this._totalBits = uint8array.byteLength * 8;
      this._currentWord = 0;
      this._currentWordBitsLeft = 0;
    }

    _createClass$j(Golomb, [{
      key: 'destroy',
      value: function destroy() {
        this._buffer = null;
      }
    }, {
      key: '_fillCurrentWord',
      value: function _fillCurrentWord() {
        var bufferBytesLeft = this._totalBytes - this._bufferIndex;

        var bytesRead = Math.min(4, bufferBytesLeft);
        var word = new Uint8Array(4);
        word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
        this._currentWord = new DataView(word.buffer).getUint32(0);

        this._bufferIndex += bytesRead;
        this._currentWordBitsLeft = bytesRead * 8;
      }

      /**
       * @param size
       * @return {number|*|number}
       */

    }, {
      key: 'readBits',
      value: function readBits(size) {
        var bits = Math.min(this._currentWordBitsLeft, size); // :uint
        var valu = this._currentWord >>> 32 - bits;
        if (size > 32) {
          throw new Error('Cannot read more than 32 bits at a time');
        }
        this._currentWordBitsLeft -= bits;
        if (this._currentWordBitsLeft > 0) {
          this._currentWord <<= bits;
        } else if (this._totalBytes - this._bufferIndex > 0) {
          this._fillCurrentWord();
        }

        bits = size - bits;
        if (bits > 0 && this._currentWordBitsLeft) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'readBool',
      value: function readBool() {
        return this.readBits(1) === 1;
      }

      /**
       * @return {*|number}
       */

    }, {
      key: 'readByte',
      value: function readByte() {
        return this.readBits(8);
      }
    }, {
      key: '_skipLeadingZero',
      value: function _skipLeadingZero() {
        var zeroCount = void 0;
        for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
          if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {
            this._currentWord <<= zeroCount;
            this._currentWordBitsLeft -= zeroCount;
            return zeroCount;
          }
        }
        this._fillCurrentWord();
        return zeroCount + this._skipLeadingZero();
      }

      /**
       * @return {number}
       */

    }, {
      key: 'readUEG',
      value: function readUEG() {
        // unsigned exponential golomb
        var leadingZeros = this._skipLeadingZero();
        return this.readBits(leadingZeros + 1) - 1;
      }

      /**
       * @return {number}
       */

    }, {
      key: 'readSEG',
      value: function readSEG() {
        // signed exponential golomb
        var value = this.readUEG();
        if (value & 0x01) {
          return value + 1 >>> 1;
        } else {
          return -1 * (value >>> 1);
        }
      }
    }, {
      key: 'readSliceType',
      value: function readSliceType() {
        // skip NALu type Nal unit header 8bit
        this.readByte();
        // discard first_mb_in_slice
        this.readUEG();
        // return slice_type
        return this.readUEG();
      }
    }]);

    return Golomb;
  }();

  var _createClass$k = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$k(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SPSParser$1 = function () {
    function SPSParser() {
      _classCallCheck$k(this, SPSParser);
    }

    _createClass$k(SPSParser, null, [{
      key: '_ebsp2rbsp',

      /**
       *
       * @param {Uint8Array} uint8array
       * @return {Uint8Array}
       */
      value: function _ebsp2rbsp(uint8array) {
        var src = uint8array;
        var srcLength = src.byteLength;
        var dst = new Uint8Array(srcLength);
        var dstIdx = 0;

        for (var i = 0; i < srcLength; i++) {
          if (i >= 2) {
            if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
              continue;
            }
          }
          dst[dstIdx] = src[i];
          dstIdx++;
        }

        return new Uint8Array(dst.buffer, 0, dstIdx);
      }

      /**
       * @param {Uint8Array} uint8array
       * @return {{width: *, general_profile_idc: number, chromaFormatIdc: *, general_level_idc: number, general_tier_flag: number, bitDepthLumaMinus8: (*|number), bitDepthChromaMinus8: (*|number), general_profile_space: number, height: *}}
       */

    }, {
      key: 'parseSPS',
      value: function parseSPS(uint8array) {
        var rbsp = SPSParser._ebsp2rbsp(uint8array);
        var gb = new Golomb$1(rbsp);

        var vpsId = 0;
        var maxSubLayersMinus1 = 0;
        var tINf = 0;
        var spsId = 0;
        var separate_colour_plane_flag = 0;
        var chromaFormatIdc = 0;
        var width = 0;
        var height = 0;
        var conf_win_left_offset = 0;
        var conf_win_right_offset = 0;
        var conf_win_top_offset = 0;
        var conf_win_bottom_offset = 0;
        var conformanceWindowFlag = 0;
        var bitDepthLumaMinus8 = 0;
        var bitDepthChromaMinus8 = 0;
        var sub_width_c = 0;
        var sub_height_c = 0;
        var profileTierLevel = {};

        gb.readByte(); // NAL header
        gb.readByte();

        vpsId = gb.readBits(4); // vps_id
        maxSubLayersMinus1 = gb.readBits(3); // max_sub_layers_minus1
        tINf = gb.readBits(1); // temporal_id_nesting_flag

        profileTierLevel = SPSParser._readProfileTierLevel(gb, maxSubLayersMinus1);

        spsId = gb.readUEG(); // sps id
        chromaFormatIdc = gb.readUEG();
        if (chromaFormatIdc === 3) {
          separate_colour_plane_flag = gb.readBits(1); // separate_colour_plane_flag
        }

        width = gb.readUEG(); // pic_width_in_luma_samples
        height = gb.readUEG(); // pic_height_in_luma_samples

        conformanceWindowFlag = gb.readBits(1);
        if (conformanceWindowFlag === 1) {
          conf_win_left_offset = gb.readUEG(); // conf_win_left_offset
          conf_win_right_offset = gb.readUEG(); // conf_win_right_offset
          conf_win_top_offset = gb.readUEG(); // conf_win_top_offset
          conf_win_bottom_offset = gb.readUEG(); // conf_win_bottom_offset
        }

        bitDepthLumaMinus8 = gb.readUEG(); // bit_depth_luma_minus8
        bitDepthChromaMinus8 = gb.readUEG(); // bit_depth_chroma_minus8

        if (conformanceWindowFlag === 1) {
          sub_width_c = (chromaFormatIdc === 1 || chromaFormatIdc === 2) && separate_colour_plane_flag === 0 ? 2 : 1;
          sub_height_c = chromaFormatIdc === 1 && separate_colour_plane_flag === 0 ? 2 : 1;
          width -= sub_width_c * conf_win_right_offset + sub_width_c * conf_win_left_offset;
          height -= sub_height_c * conf_win_bottom_offset + sub_height_c * conf_win_top_offset;
        }

        gb.destroy();
        gb = null;

        return { width: width,
          height: height,
          general_profile_space: profileTierLevel.general_profile_space,
          general_tier_flag: profileTierLevel.general_tier_flag,
          general_profile_idc: profileTierLevel.general_profile_idc,
          general_level_idc: profileTierLevel.general_level_idc,
          chromaFormatIdc: chromaFormatIdc,
          bitDepthLumaMinus8: bitDepthLumaMinus8,
          bitDepthChromaMinus8: bitDepthChromaMinus8 };
      }

      // static parseSPS (uint8array) {
      //   let rbsp = SPSParser._ebsp2rbsp(uint8array)
      //   let gb = new Golomb(rbsp)
      //
      //   gb.readByte()
      //   let profileIdc = gb.readByte()
      //   gb.readByte()
      //   let levelIdc = gb.readByte()
      //   gb.readUEG()
      //
      //   let profile_string = SPSParser.getProfileString(profileIdc)
      //   let level_string = SPSParser.getLevelString(levelIdc)
      //   let chroma_format_idc = 1
      //   let chroma_format = 420
      //   let chroma_format_table = [0, 420, 422, 444]
      //   let bit_depth = 8
      //
      //   if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 ||
      //     profileIdc === 244 || profileIdc === 44 || profileIdc === 83 ||
      //     profileIdc === 86 || profileIdc === 118 || profileIdc === 128 ||
      //     profileIdc === 138 || profileIdc === 144) {
      //     chroma_format_idc = gb.readUEG()
      //     if (chroma_format_idc === 3) {
      //       gb.readBits(1)
      //     }
      //     if (chroma_format_idc <= 3) {
      //       chroma_format = chroma_format_table[chroma_format_idc]
      //     }
      //
      //     bit_depth = gb.readUEG() + 8
      //     gb.readUEG()
      //     gb.readBits(1)
      //     if (gb.readBool()) {
      //       let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12
      //       for (let i = 0; i < scaling_list_count; i++) {
      //         if (gb.readBool()) {
      //           if (i < 6) {
      //             SPSParser._skipScalingList(gb, 16)
      //           } else {
      //             SPSParser._skipScalingList(gb, 64)
      //           }
      //         }
      //       }
      //     }
      //   }
      //   gb.readUEG()
      //   let pic_order_cnt_type = gb.readUEG()
      //   if (pic_order_cnt_type === 0) {
      //     gb.readUEG()
      //   } else if (pic_order_cnt_type === 1) {
      //     gb.readBits(1)
      //     gb.readSEG()
      //     gb.readSEG()
      //     let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG()
      //     for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {
      //       gb.readSEG()
      //     }
      //   }
      //   gb.readUEG()
      //   gb.readBits(1)
      //
      //   let pic_width_in_mbs_minus1 = gb.readUEG()
      //   let pic_height_in_map_units_minus1 = gb.readUEG()
      //
      //   let frame_mbs_only_flag = gb.readBits(1)
      //   if (frame_mbs_only_flag === 0) {
      //     gb.readBits(1)
      //   }
      //   gb.readBits(1)
      //
      //   let frame_crop_left_offset = 0
      //   let frame_crop_right_offset = 0
      //   let frame_crop_top_offset = 0
      //   let frame_crop_bottom_offset = 0
      //
      //   let frame_cropping_flag = gb.readBool()
      //   if (frame_cropping_flag) {
      //     frame_crop_left_offset = gb.readUEG()
      //     frame_crop_right_offset = gb.readUEG()
      //     frame_crop_top_offset = gb.readUEG()
      //     frame_crop_bottom_offset = gb.readUEG()
      //   }
      //
      //   let par_width = 1, par_height = 1
      //   let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0
      //
      //   let vui_parameters_present_flag = gb.readBool()
      //   if (vui_parameters_present_flag) {
      //     if (gb.readBool()) { // aspect_ratio_info_present_flag
      //       let aspect_ratio_idc = gb.readByte()
      //       let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2]
      //       let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1]
      //
      //       if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
      //         par_width = par_w_table[aspect_ratio_idc - 1]
      //         par_height = par_h_table[aspect_ratio_idc - 1]
      //       } else if (aspect_ratio_idc === 255) {
      //         par_width = gb.readByte() << 8 | gb.readByte()
      //         par_height = gb.readByte() << 8 | gb.readByte()
      //       }
      //     }
      //
      //     if (gb.readBool()) {
      //       gb.readBool()
      //     }
      //     if (gb.readBool()) {
      //       gb.readBits(4)
      //       if (gb.readBool()) {
      //         gb.readBits(24)
      //       }
      //     }
      //     if (gb.readBool()) {
      //       gb.readUEG()
      //       gb.readUEG()
      //     }
      //     if (gb.readBool()) {
      //       let num_units_in_tick = gb.readBits(32)
      //       let time_scale = gb.readBits(32)
      //       fps_fixed = gb.readBool()
      //
      //       fps_num = time_scale
      //       fps_den = num_units_in_tick * 2
      //       fps = fps_num / fps_den
      //     }
      //   }
      //
      //   let parScale = 1
      //   if (par_width !== 1 || par_height !== 1) {
      //     parScale = par_width / par_height
      //   }
      //
      //   let crop_unit_x = 0, crop_unit_y = 0
      //   if (chroma_format_idc === 0) {
      //     crop_unit_x = 1
      //     crop_unit_y = 2 - frame_mbs_only_flag
      //   } else {
      //     let sub_wc = (chroma_format_idc === 3) ? 1 : 2
      //     let sub_hc = (chroma_format_idc === 1) ? 2 : 1
      //     crop_unit_x = sub_wc
      //     crop_unit_y = sub_hc * (2 - frame_mbs_only_flag)
      //   }
      //
      //   let codec_width = (pic_width_in_mbs_minus1 + 1) * 16
      //   let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16)
      //
      //   codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x
      //   codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y
      //
      //   let present_width = Math.ceil(codec_width * parScale)
      //
      //   gb.destroy()
      //   gb = null
      //
      //   return {
      //     profile_string: profile_string,
      //     level_string: level_string,
      //     bit_depth: bit_depth,
      //     chroma_format: chroma_format,
      //     chroma_format_string: SPSParser.getChromaFormatString(chroma_format),
      //
      //     frame_rate: {
      //       fixed: fps_fixed,
      //       fps: fps,
      //       fps_den: fps_den,
      //       fps_num: fps_num
      //     },
      //
      //     par_ratio: {
      //       width: par_width,
      //       height: par_height
      //     },
      //
      //     codec_size: {
      //       width: codec_width,
      //       height: codec_height
      //     },
      //
      //     present_size: {
      //       width: present_width,
      //       height: codec_height
      //     }
      //   }
      // }
      /**
       * @param gb
       * @param maxSubLayersMinus1
       * @return {{general_profile_idc: (*|number), general_level_idc: (*|number), general_tier_flag: (*|number), general_profile_space: (*|number)}}
       */

    }, {
      key: '_readProfileTierLevel',
      value: function _readProfileTierLevel(gb, maxSubLayersMinus1) {
        var general_profile_space = 0;
        var general_tier_flag = 0;
        var general_profile_idc = 0;
        var general_level_idc = 0;
        general_profile_space = gb.readBits(2) || 0; // profile_space
        general_tier_flag = gb.readBits(1) || 0; // tierFlag
        general_profile_idc = gb.readBits(5) || 0; // profileIdc

        gb.readBits(16); // some 32bits
        gb.readBits(16);

        gb.readBits(1); // progressiveSourceFlag
        gb.readBits(1); // interlacedSourceFlag
        gb.readBits(1); // nonPackedConstraintFlag
        gb.readBits(1); // frameOnlyConstraintFlag

        gb.readBits(16); // reserved zero bits
        gb.readBits(16);
        gb.readBits(12);

        general_level_idc = gb.readBits(8) || 0; // level_idc

        var subLayerProfilePresentFlag = [];
        var subLayerLevelPresentFlag = [];
        for (var j = 0; j < maxSubLayersMinus1; j++) {
          subLayerProfilePresentFlag[j] = gb.readBits(1);
          subLayerLevelPresentFlag[j] = gb.readBits(1);
        }

        if (maxSubLayersMinus1 > 0) {
          gb.readBits((8 - maxSubLayersMinus1) * 2);
        }

        for (var i = 0; i < maxSubLayersMinus1; i++) {
          if (subLayerProfilePresentFlag[i] !== 0) {
            gb.readBits(2);
            gb.readBits(1);
            gb.readBits(5);

            gb.readBits(16);
            gb.readBits(16);

            gb.readBits(4);

            gb.readBits(16);
            gb.readBits(16);
            gb.readBits(12);
          }
          if (subLayerLevelPresentFlag[i] !== 0) {
            gb.readBits(8);
          }
        }

        return {
          general_profile_space: general_profile_space,
          general_tier_flag: general_tier_flag,
          general_profile_idc: general_profile_idc,
          general_level_idc: general_level_idc
        };
      }

      /**
       *
       *  @param {any} gb
       * @param {number}count
       */

    }, {
      key: '_skipScalingList',
      value: function _skipScalingList(gb, count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale = 0;
        for (var i = 0; i < count; i++) {
          if (nextScale !== 0) {
            deltaScale = gb.readSEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      }

      /**
       *
       * @param {number} profileIdc
       * @return {string}
       */

    }, {
      key: 'getProfileString',
      value: function getProfileString(profileIdc) {
        switch (profileIdc) {
          case 66:
            return 'Baseline';
          case 77:
            return 'Main';
          case 88:
            return 'Extended';
          case 100:
            return 'High';
          case 110:
            return 'High10';
          case 122:
            return 'High422';
          case 244:
            return 'High444';
          default:
            return 'Unknown';
        }
      }

      /**
       * @param {number} levelIdc
       * @return {string}
       */

    }, {
      key: 'getLevelString',
      value: function getLevelString(levelIdc) {
        return (levelIdc / 10).toFixed(1);
      }

      /**
       * @param {number} chroma
       * @return {string}
       */

    }, {
      key: 'getChromaFormatString',
      value: function getChromaFormatString(chroma) {
        switch (chroma) {
          case 420:
            return '4:2:0';
          case 422:
            return '4:2:2';
          case 444:
            return '4:4:4';
          default:
            return 'Unknown';
        }
      }

      /**
       * @param {any} spsConfig
       * @return {any}
       */

    }, {
      key: 'toVideoMeta',
      value: function toVideoMeta(spsConfig) {
        var meta = {};
        if (spsConfig && spsConfig.codec_size) {
          meta.codecWidth = spsConfig.codec_size.width;
          meta.codecHeight = spsConfig.codec_size.height;
          meta.presentWidth = spsConfig.present_size.width;
          meta.presentHeight = spsConfig.present_size.height;
        } else if (spsConfig.width && spsConfig.height) {
          meta.codecWidth = spsConfig.width;
          meta.codecHeight = spsConfig.height;
          meta.presentWidth = spsConfig.width;
          meta.presentHeight = spsConfig.height;
        }

        meta.profile = spsConfig.profile_string;
        meta.level = spsConfig.level_string;
        meta.bitDepth = spsConfig.bit_depth;
        meta.chromaFormat = spsConfig.chroma_format;

        // meta.parRatio = {
        //   width: spsConfig.par_ratio.width,
        //   height: spsConfig.par_ratio.height
        // }

        // meta.frameRate = spsConfig.frame_rate

        // let fpsDen = meta.frameRate.fps_den
        // let fpsNum = meta.frameRate.fps_num
        // meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum))
        return meta;
      }
    }]);

    return SPSParser;
  }();

  var _createClass$l = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$l(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var RBSP$1 = function () {
    function RBSP() {
      _classCallCheck$l(this, RBSP);
    }

    _createClass$l(RBSP, null, [{
      key: "EBSP2RBSP",

      /**
       * convert EBSP to RBSP
       * @param {Uint8Array} data
       * @returns {Uint8Array}
       * @constructor
       */
      value: function EBSP2RBSP(data) {
        return data.filter(function (el, idx) {
          if (idx < 2) {
            return true;
          } else {
            return !(data[idx - 2] === 0 && data[idx - 1] === 0 && el === 3);
          }
        });
      }

      /**
       * @param {Uint8Array} data
       * @constructor
       */

    }, {
      key: "EBSP2SODB",
      value: function EBSP2SODB(data) {
        var lastByte = data[data.byteLength - 1];
        if (lastByte && lastByte === 128) {
          return data.slice(0, data.byteLength - 1);
        }

        return data;
      }
    }]);

    return RBSP;
  }();

  var _createClass$m = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$m(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * @param {Uint8Array} data
   * @return {string}
   */
  var u8aToString$1 = function u8aToString(data) {
    var result = '';
    for (var i = 0; i < data.byteLength; i++) {
      result += String.fromCharCode(data[i]);
    }
    return result;
  };

  var SEIParser$1 = function () {
    function SEIParser() {
      _classCallCheck$m(this, SEIParser);
    }

    _createClass$m(SEIParser, null, [{
      key: '_resolveNalu',
      value: function _resolveNalu(data) {
        if (data.length >= 1) {
          return RBSP$1.EBSP2SODB(RBSP$1.EBSP2RBSP(data.slice(1)));
        }
        return null;
      }

      /**
       * @param {Uint8Array} data
       * @return {{uuid: string, content: null}|{code: number, uuid: string, content: string}|{code: number, content: Uint8Array}}
       */

    }, {
      key: 'parse',
      value: function parse(data) {
        var sodb = SEIParser._resolveNalu(data);

        var _SEIParser$switchPayl = SEIParser.switchPayloadType(sodb),
            payloadType = _SEIParser$switchPayl.payloadType,
            offset = _SEIParser$switchPayl.offset;

        var content = sodb.slice(offset);

        switch (payloadType) {
          case 5:
            return SEIParser.user_data_unregistered(content);
          default:
            return {
              code: payloadType,
              content: content
            };
        }
      }

      /**
       *
       * @param {Uint8Array} data
       * @returns {{payloadType: number, offset: number}}
       */

    }, {
      key: 'switchPayloadType',
      value: function switchPayloadType(data) {
        var dv = new DataView(data.buffer);
        var payloadType = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadType += 255;
        }
        payloadType += dv.getUint8(offset++);

        return {
          payloadType: payloadType,
          offset: offset
        };
      }

      /**
       *
       * @param {Uint8Array} data
       * @return {{ payloadLength: number, offset: number }}
       */

    }, {
      key: 'getPayloadLength',
      value: function getPayloadLength(data) {
        var dv = new DataView(data.buffer);

        var payloadLength = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadLength += 255;
        }
        payloadLength += dv.getUint8(offset++);

        return {
          payloadLength: payloadLength,
          offset: offset
        };
      }

      /**
       * resolve 0x05 user data unregistered
       * @param {Uint8Array} data
       */
      // eslint-disable-next-line camelcase

    }, {
      key: 'user_data_unregistered',
      value: function user_data_unregistered(data) {
        var _SEIParser$getPayload = SEIParser.getPayloadLength(data),
            payloadLength = _SEIParser$getPayload.payloadLength,
            offset = _SEIParser$getPayload.offset;

        if (payloadLength < 16) {
          return {
            uuid: '',
            content: null
          };
        }
        var payload = data.slice(offset);

        var uuid = u8aToString$1(payload.slice(0, 16));
        var content = u8aToString$1(payload.slice(16, payloadLength));

        return {
          code: 5, // for user data unregistered
          uuid: uuid,
          content: content
        };
      }
    }]);

    return SEIParser;
  }();

  var _createClass$n = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$n(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Nalunit$1 = function () {
    function Nalunit() {
      _classCallCheck$n(this, Nalunit);
    }

    _createClass$n(Nalunit, null, [{
      key: 'getNalunits',

      /**
       * @param {any} buffer
       * @return {[]|*[]}
       */
      value: function getNalunits(buffer) {
        if (buffer.length - buffer.position < 4) {
          return [];
        }

        var buf = buffer.dataview;
        var position = buffer.position;

        if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {
          return Nalunit.getAnnexbNals(buffer);
        } else {
          return Nalunit.getHvccNals(buffer);
        }
      }

      /**
       * @param {any} buffer
       * @return {[]}
       */

    }, {
      key: 'getAnnexbNals',
      value: function getAnnexbNals(buffer) {
        var nals = [];
        var position = Nalunit.getHeaderPositionAnnexB(buffer);
        var start = position.pos;
        var end = start;
        while (start < buffer.length - 4) {
          var header = buffer.buffer.slice(start, start + position.headerLength);
          if (position.pos === buffer.position) {
            buffer.skip(position.headerLength);
          }
          position = Nalunit.getHeaderPositionAnnexB(buffer);
          end = position.pos;
          var body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));
          var unit = { header: header, body: body };
          Nalunit.analyseNal(unit);
          if (unit.type <= 40) {
            nals.push(unit);
          }
          buffer.skip(end - buffer.position);
          start = end;
        }
        return nals;
      }

      // |四字节 nalSize| nalUnit |
      /**
       * @param {any} buffer
       * @return {[]}
       */

    }, {
      key: 'getHvccNals',
      value: function getHvccNals(buffer) {
        // console.log('getHvccNals')
        var nals = [];
        while (buffer.position < buffer.length - 4) {
          // console.log('buffer')
          // console.log(buffer)
          // console.log(buffer.position)
          // console.log(buffer.length)
          // console.log(buffer.dataview)
          // let length = buffer.dataview.getInt32();
          var length = buffer.dataview.getInt32(buffer.dataview.position);
          if (buffer.length - buffer.position >= length) {
            var header = buffer.buffer.slice(buffer.position, buffer.position + 4);
            buffer.skip(4);
            var body = new Uint8Array(buffer.buffer.slice(buffer.position, buffer.position + length));
            buffer.skip(length);
            var unit = { header: header, body: body };
            try {
              Nalunit.analyseNal(unit);
            } catch (e) {
              continue;
            }
            if (unit.type <= 40) {
              nals.push(unit);
            }
          } else {
            break;
          }
        }
        return nals;
      }

      /**
       * @param {any} unit
       */

    }, {
      key: 'analyseNal',
      value: function analyseNal(unit) {
        var type = unit.body[0] >>> 1 & 0x3f;
        unit.type = type;
        switch (type) {
          case 0:
            // SLICE_TRAIL_N
            unit.slice_trail_n = true;
            break;
          case 1:
            // SLICE_TRAIL_R
            unit.slice_trail_r = true;
            unit.key = true;
            break;
          case 2:
            // SLICE_TSA_N
            unit.slice_tsa_n = true;
            break;
          case 3:
            // SLICE_TSA_R
            unit.slice_tsa_r = true;
            unit.key = true;
            break;
          case 4:
            // SLICE_STSA_N
            unit.slice_stsa_n = true;
            break;
          case 5:
            // SLICE_STSA_R
            unit.slice_stsa_r = true;
            unit.key = true;
            break;
          case 6:
            // SLICE_RADL_N
            unit.slice_radl_n = true;
            break;
          case 7:
            // SLICE_RADL_R
            unit.slice_radl_r = true;
            unit.key = true;
            break;
          case 8:
            // SLICE_RASL_N
            unit.slice_rasl_n = true;
            break;
          case 9:
            // SLICE_RASL_R
            unit.slice_rasl_r = true;
            unit.key = true;
            break;
          case 16:
            // SLICE_BLA_W_LP
            unit.slice_bla_w_lp = true;
            break;
          case 17:
            // SLICE_BLA_W_RADL
            unit.slice_bla_w_radl = true;
            break;
          case 18:
            // SLICE_BLA_N_LP
            unit.slice_bla_n_lp = true;
            break;
          case 19:
            // SLICE_IDR_W_RADL
            unit.slice_idl_w_radl = true;
            unit.key = true;
            break;
          case 20:
            // SLICE_IDR_N_LP
            unit.slice_idr_n_lp = true;
            unit.key = true;
            break;
          case 21:
            // SLICE_CRA_NUT
            unit.slice_cra_nut = true;
            unit.key = true;
            break;
          case 32:
            // VPS
            unit.vps = true;
            break;
          case 33:
            // SPS
            unit.sps = SPSParser$1.parseSPS(unit.body);
            break;
          case 34:
            // PPS
            unit.pps = true;
            break;
          case 35:
            // AUD
            break;
          case 36:
            // EOS
            unit.aud = true;
            break;
          case 37:
            // EOB
            unit.eob = true;
            break;
          case 38:
            // FD
            unit.fd = true;
            break;
          case 39:
            // PREFIX_SEI
            // unit.prefix_sei = true;
            try {
              unit.sei = SEIParser$1.parse(unit.body.slice(1));
            } catch (e) {}
            break;
          case 40:
            // SUFFIX_SEI
            unit.sei = SEIParser$1.parse(unit.body.slice(1));
            break;
        }
      }
    }, {
      key: 'getHeaderPositionAnnexB',
      value: function getHeaderPositionAnnexB(buffer) {
        // seperate
        var pos = buffer.position;
        var headerLength = 0;
        var bufferLen = buffer.length;
        while (headerLength !== 3 && headerLength !== 4 && pos < bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x00000001
              headerLength = 4;
            } else if (buffer.dataview.getInt8(pos + 2) === 1) {
              headerLength = 3;
            } else {
              pos++;
            }
          } else {
            pos++;
          }
        }

        if (pos === bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x00000001
              headerLength = 4;
            }
          } else {
            pos++;
            if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {
              // 0x000001
              headerLength = 3;
            } else {
              pos = bufferLen;
            }
          }
        }
        return { pos: pos, headerLength: headerLength };
      }
    }]);

    return Nalunit;
  }();



  var _hevc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SpsParserHEVC: SPSParser$1,
    NalUnitHEVC: Nalunit$1
  });

  var ADTS$1 = ADTS;
  var avc = _avc;
  var hevc = _hevc;

  var _createClass$o = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var NalUnitHEVC = hevc.NalUnitHEVC;
  var NalUnit = avc.NalUnit;

  var LOADER_EVENTS$2 = EVENTS.LOADER_EVENTS;
  var DEMUX_EVENTS$1 = EVENTS.DEMUX_EVENTS;
  var HLS_EVENTS$1 = EVENTS.HLS_EVENTS;
  var CRYTO_EVENTS = EVENTS.CRYTO_EVENTS;
  var HLS_ERROR = 'HLS_ERROR';

  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;

  var HlsLiveController = function () {
    function HlsLiveController(configs) {
      _classCallCheck$o(this, HlsLiveController);

      this.configs = Object.assign({}, configs);
      this.url = '';
      this.sequence = 0;
      this._playlist = null;
      this.retrytimes = this.configs.retrytimes || 3;
      this.preloadTime = this.configs.preloadTime;
      this.container = this.configs.container;
      this._m3u8lasttime = 0;
      this._timmer = setInterval(this._checkStatus.bind(this), 50);
      this._lastCheck = 0;

      this.m3u8Text = null;
    }

    _createClass$o(HlsLiveController, [{
      key: 'init',
      value: function init() {
        var _player$hlsOps = this._player.hlsOps,
            XgBuffer = _player$hlsOps.XgBuffer,
            Tracks = _player$hlsOps.Tracks,
            Playlist = _player$hlsOps.Playlist,
            FetchLoader = _player$hlsOps.FetchLoader,
            TsDemuxer = _player$hlsOps.TsDemuxer;
        // 初始化Buffer （M3U8/TS/Playlist);

        this._context.registry('M3U8_BUFFER', XgBuffer);
        this._context.registry('TS_BUFFER', XgBuffer);
        this._context.registry('TRACKS', Tracks);

        this._playlist = this._context.registry('PLAYLIST', Playlist)({ autoclear: true });

        // 初始化M3U8Loader;
        this._m3u8loader = this._context.registry('M3U8_LOADER', FetchLoader)({ buffer: 'M3U8_BUFFER', readtype: 1 });
        this._tsloader = this._context.registry('TS_LOADER', FetchLoader)({ buffer: 'TS_BUFFER', readtype: 3 });

        // 初始化TS Demuxer
        this._context.registry('TS_DEMUXER', TsDemuxer)({ inputbuffer: 'TS_BUFFER' });

        this.initEvents();
      }
    }, {
      key: 'initEvents',
      value: function initEvents() {
        this.on(LOADER_EVENTS$2.LOADER_COMPLETE, this._onLoadComplete.bind(this));

        this.on(DEMUX_EVENTS$1.METADATA_PARSED, this._onMetadataParsed.bind(this));

        this.on(DEMUX_EVENTS$1.SEI_PARSED, this._handleSEIParsed.bind(this));

        this.on(DEMUX_EVENTS$1.DEMUX_COMPLETE, this._onDemuxComplete.bind(this));

        this.on(LOADER_EVENTS$2.LOADER_ERROR, this._onLoadError.bind(this));

        this.on(DEMUX_EVENTS$1.DEMUX_ERROR, this._onDemuxError.bind(this));
      }
    }, {
      key: '_onError',
      value: function _onError(type, mod, err, fatal) {
        var error = {
          errorType: type,
          errorDetails: '[' + mod + ']: ' + (err ? err.message : ''),
          errorFatal: fatal
        };
        this._player.emit(HLS_ERROR, error);
      }
    }, {
      key: '_onDemuxComplete',
      value: function _onDemuxComplete() {
        var _this = this;

        if (this._player.video) {
          var _context$getInstance = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance.videoTrack,
              audioTrack = _context$getInstance.audioTrack;

          videoTrack.samples.forEach(function (sample) {
            if (sample.analyzed) {
              return;
            }
            sample.analyzed = true;
            var buffer = new XGDataView(sample.data.buffer);
            var nals = void 0;
            if (_this._isHEVC(videoTrack.meta)) {
              nals = NalUnitHEVC.getHvccNals(buffer);
            } else {
              nals = NalUnit.getNalunits(buffer);
            }
            var nalsLength = nals.reduce(function (len, current) {
              return len + 4 + current.body.byteLength;
            }, 0);
            var newData = new Uint8Array(nalsLength);
            var offset = 0;
            nals.forEach(function (nal) {
              newData.set([0, 0, 0, 1], offset);
              offset += 4;
              newData.set(new Uint8Array(nal.body), offset);
              offset += nal.body.byteLength;
            });

            sample.data = newData;
          });
          this._player.video.onDemuxComplete(videoTrack, audioTrack);
        }
      }
    }, {
      key: '_onMetadataParsed',
      value: function _onMetadataParsed(type) {
        if (type === 'audio') {
          // 将音频meta信息交给audioContext，不走remux封装
          var _context$getInstance2 = this._context.getInstance('TRACKS'),
              audioTrack = _context$getInstance2.audioTrack;

          if (audioTrack && audioTrack.meta) {
            this._setMetaToAudio(audioTrack.meta);
          }
        } else {
          var _context$getInstance3 = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance3.videoTrack;

          if (videoTrack && videoTrack.meta) {
            this._setMetaToVideo(videoTrack.meta);
          }
        }
      }
    }, {
      key: '_setMetaToAudio',
      value: function _setMetaToAudio(audioMeta) {
        if (this._player.video) {
          this._player.video.setAudioMeta(audioMeta);
        }
      }
    }, {
      key: '_setMetaToVideo',
      value: function _setMetaToVideo(videoMeta) {
        if (this._player.video) {
          this._player.video.setVideoMeta(videoMeta);
        }
      }
    }, {
      key: '_onLoadError',
      value: function _onLoadError(loader, error) {
        if (!this._tsloader.loading && !this._m3u8loader.loading && this.retrytimes > 1) {
          this.retrytimes--;
          this._onError(LOADER_EVENTS$2.LOADER_ERROR, loader, error, false);
        } else if (this.retrytimes <= 1) {
          this._onError(LOADER_EVENTS$2.LOADER_ERROR, loader, error, true);
          this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
          if (this._player.video) {
            this._player.video.handleEnded();
          }
        }
      }
    }, {
      key: '_onDemuxError',
      value: function _onDemuxError(mod, error, fatal) {
        if (fatal === undefined) {
          fatal = true;
        }
        this._onError(LOADER_EVENTS$2.LOADER_ERROR, mod, error, fatal);
      }
    }, {
      key: '_handleSEIParsed',
      value: function _handleSEIParsed(sei) {
        this._player.emit('SEI_PARSED', sei);
      }
    }, {
      key: '_onLoadComplete',
      value: function _onLoadComplete(buffer) {
        if (buffer.TAG === 'M3U8_BUFFER') {
          var mdata = void 0;
          try {
            this.m3u8Text = buffer.shift();
            var result = MASTER_PLAYLIST_REGEX.exec(this.m3u8Text);
            if (result && result[2]) {
              // redirect
              this.load(result[2]);
            } else {
              mdata = this._player.hlsOps.M3U8Parser.parse(this.m3u8Text, this.url);
            }
          } catch (error) {
            this._onError('M3U8_PARSER_ERROR', 'M3U8_PARSER', error, false);
          }

          if (!mdata) {
            if (this.retrytimes > 0) {
              this.retrytimes--;
              this._preload();
            } else {
              this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
              if (this._player.video) {
                this._player.video.handleEnded();
              }
            }
            return;
          }

          try {
            this._playlist.pushM3U8(mdata, true);
          } catch (error) {
            this._onError('M3U8_PARSER_ERROR', 'PLAYLIST', error, false);
          }

          if (this._playlist.encrypt && this._playlist.encrypt.uri && !this._playlist.encrypt.key) {
            var _player$hlsOps2 = this._player.hlsOps,
                XgBuffer = _player$hlsOps2.XgBuffer,
                FetchLoader = _player$hlsOps2.FetchLoader;

            this._context.registry('DECRYPT_BUFFER', XgBuffer)();
            this._context.registry('KEY_BUFFER', XgBuffer)();
            this._tsloader.buffer = 'DECRYPT_BUFFER';
            this._keyLoader = this._context.registry('KEY_LOADER', FetchLoader)({ buffer: 'KEY_BUFFER', readtype: 3 });
            this.emitTo('KEY_LOADER', LOADER_EVENTS$2.LADER_START, this._playlist.encrypt.uri);
          } else {
            this._m3u8Loaded(mdata);
          }
        } else if (buffer.TAG === 'TS_BUFFER') {
          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.downloaded(this._tsloader.url, true);
          this.emit(DEMUX_EVENTS$1.DEMUX_START);
        } else if (buffer.TAG === 'DECRYPT_BUFFER') {
          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.downloaded(this._tsloader.url, true);
          this.emitTo('CRYPTO', CRYTO_EVENTS.START_DECRYPT);
        } else if (buffer.TAG === 'KEY_BUFFER') {
          var Crypto = this._player.hlsOps.Crypto;

          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.encrypt.key = buffer.shift();
          this._crypto = this._context.registry('CRYPTO', Crypto)({
            key: this._playlist.encrypt.key,
            iv: this._playlist.encrypt.ivb,
            method: this._playlist.encrypt.method,
            inputbuffer: 'DECRYPT_BUFFER',
            outputbuffer: 'TS_BUFFER'
          });
          this._crypto.on(CRYTO_EVENTS.DECRYPTED, this._onDcripted.bind(this));
        }
      }
    }, {
      key: '_onDcripted',
      value: function _onDcripted() {
        this.emit(DEMUX_EVENTS$1.DEMUX_START);
      }
    }, {
      key: '_m3u8Loaded',
      value: function _m3u8Loaded(mdata) {
        if (!this.preloadTime) {
          this.preloadTime = this._playlist.targetduration ? this._playlist.targetduration : 5;
        }
        if (this._playlist.fragLength > 0 && this._playlist.sequence < mdata.sequence) {
          this.retrytimes = this.configs.retrytimes || 3;
        } else {
          if (this.retrytimes > 0) {
            this.retrytimes--;
            this._preload();
          } else {
            this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
            if (this._player.video) {
              this._player.video.handleEnded();
            }
          }
        }
      }
    }, {
      key: '_checkStatus',
      value: function _checkStatus() {
        if (this.retrytimes < 1 && new Date().getTime() - this._lastCheck < 10000) {
          return;
        }
        this._lastCheck = new Date().getTime();
        if (this.container.buffered.length < 1) {
          this._preload();
        } else {
          // Check for load.
          var currentTime = this.container.currentTime;
          if (this.container.readyState <= 2) {
            this._preload();
          }
          var bufferend = this.container.buffered.end(this.container.buffered.length - 1);

          if (currentTime > bufferend - this.preloadTime) {
            this._preload();
          }
        }
      }
    }, {
      key: '_preload',
      value: function _preload() {
        if (this._tsloader.loading || this._m3u8loader.loading) {
          return;
        }
        var frag = this._playlist.getTs();

        if (frag && !frag.downloaded && !frag.downloading) {
          this._playlist.downloading(frag.url, true);
          this.emitTo('TS_LOADER', LOADER_EVENTS$2.LADER_START, frag.url);
        } else {
          var preloadTime = this.preloadTime ? this.preloadTime : 0;
          var current = new Date().getTime();
          if ((!frag || frag.downloaded) && (current - this._m3u8lasttime) / 1000 > preloadTime) {
            this._m3u8lasttime = current;
            this.emitTo('M3U8_LOADER', LOADER_EVENTS$2.LADER_START, this.url);
          }
        }
      }
    }, {
      key: '_isHEVC',
      value: function _isHEVC(meta) {
        return meta && meta.codec === 'hev1.1.6.L93.B0';
      }
    }, {
      key: 'load',
      value: function load(url) {
        this.url = url;
        this._preload();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearInterval(this._timmer);
        this.off(LOADER_EVENTS$2.LOADER_COMPLETE, this._onLoadComplete);
        // this.off(REMUX_EVENTS.REMUX_ERROR);
        this.off(DEMUX_EVENTS$1.METADATA_PARSED, this._onMetadataParsed);
        this.off(DEMUX_EVENTS$1.DEMUX_COMPLETE, this._onDemuxComplete);

        this.m3u8Text = null;
      }
    }]);

    return HlsLiveController;
  }();

  var eventemitter3$1 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty,
      prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
        events,
        name;

    if (this._eventsCount === 0) return names;

    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  var _typeof2$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var _typeof$3 = typeof Symbol === "function" && _typeof2$1(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2$1(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2$1(obj);
  };

  var _createClass$p = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$p(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$2(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2$1(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2$1(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * @typedef {import('xgplayer-helper-models').TsFrag } TsFrag
   */
  /**
   * @typedef {import('xgplayer-helper-models').Buffer } Buffer
   */
  var NalUnit$1 = avc.NalUnit;
  var NalUnitHEVC$1 = hevc.NalUnitHEVC;

  var StreamType = {
    0x01: ['video', 'MPEG-1'],
    0x02: ['video', 'MPEG-2'],
    0x1b: ['video', 'AVC.H264'],
    0x24: ['video', 'HVC.H265'],
    0xea: ['video', 'VC-1'],
    0x03: ['audio', 'MPEG-1'],
    0x04: ['audio', 'MPEG-2'],
    0x0f: ['audio', 'MPEG-2.AAC'],
    0x11: ['audio', 'MPEG-4.AAC'],
    0x80: ['audio', 'LPCM'],
    0x81: ['audio', 'AC3'],
    0x06: ['audio', 'AC3'],
    0x82: ['audio', 'DTS'],
    0x83: ['audio', 'Dolby TrueHD'],
    0x84: ['audio', 'AC3-Plus'],
    0x85: ['audio', 'DTS-HD'],
    0x86: ['audio', 'DTS-MA'],
    0xa1: ['audio', 'AC3-Plus-SEC'],
    0xa2: ['audio', 'DTS-HD-SEC']
  };

  var TsDemuxer = function (_EventEmitter) {
    _inherits$2(TsDemuxer, _EventEmitter);

    _createClass$p(TsDemuxer, null, [{
      key: 'EVENTS',
      get: function get() {
        return {
          DEMUX_COMPLETE: 'DEMUX_COMPLETE',
          METADATA_PARSED: 'METADATA_PARSED',
          VIDEO_SAMPLE_PARSED: 'VIDEO_SAMPLE_PARSED',
          AUDIO_SAMPLE_PARSED: 'AUDIO_SAMPLES_PARSED',
          SEI_PARSED: 'SEI_PARSED'
        };
      }

      /**
       * @param {any} videoTrack
       * @param {any} audioTrack
       */

    }]);

    function TsDemuxer(_ref) {
      var videoTrack = _ref.videoTrack,
          audioTrack = _ref.audioTrack;

      _classCallCheck$p(this, TsDemuxer);

      var _this = _possibleConstructorReturn$2(this, (TsDemuxer.__proto__ || Object.getPrototypeOf(TsDemuxer)).call(this));

      _this.TAG = 'TsDemuxer';
      _this.demuxing = false;
      _this.videoTrack = videoTrack;
      _this.audioTrack = audioTrack;
      _this.pat = [];
      _this.pmt = [];
      _this._hasVideoMeta = false;
      _this._hasAudioMeta = false;
      _this.gopId = 0;
      return _this;
    }

    /**
     *
     * @param {TsFrag} frag ts fragment parsed from m3u8
     * @param {Buffer} buffer u8a-buffer
     * @param {boolean} isVod is a vod m3u8
     */

    _createClass$p(TsDemuxer, [{
      key: 'demux',
      value: function demux(frag, buffer, isVod) {
        if (frag) {
          logger.log(this.TAG, 'do demux: id=' + frag.id + ',demuxing=' + this.demuxing);
        }
        if (this.demuxing) {
          return;
        }

        var frags = { pat: [], pmt: [] };
        var peses = {};
        while (buffer.length >= 188) {
          if (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {
            throw new Error('Untrust sync code: ' + buffer.array[0][buffer.offset] + ', try to recover;');
          }
          while (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {
            buffer.shift(1);
          }
          if (buffer.length < 188) {
            continue;
          }
          var buf = buffer.shift(188);
          // console.log(buf);
          var tsStream = new XGDataView(buf.buffer);
          var ts = {};
          TsDemuxer.read(tsStream, ts, frags);
          var pes = peses[ts.header.pid];
          if (ts.pes) {
            ts.pes.codec = ts.header.codec;
            ts.pes.streamType = ts.header.streamType;
            if (!peses[ts.header.pid]) {
              peses[ts.header.pid] = [];
            }
            peses[ts.header.pid].push(ts.pes);
            ts.pes.ES.buffer = [ts.pes.ES.buffer];
          } else if (pes) {
            pes[pes.length - 1].ES.buffer.push(ts.payload.stream);
          }
        }

        var AudioOptions = Object.assign({}, frag);
        var VideoOptions = Object.assign({}, frag);

        var noAudio = isVod && this._hasVideoMeta && !this._hasAudioMeta;
        var noVideo = isVod && this._hasAudioMeta && !this._hasVideoMeta;

        // Get Frames data
        for (var i = 0; i < Object.keys(peses).length; i++) {
          var epeses = peses[Object.keys(peses)[i]];
          for (var j = 0; j < epeses.length; j++) {
            var cPes = epeses[j];
            cPes.id = Object.keys(peses)[i];

            // 1. !noAudio 首片无音频,后续分片当无音频处理
            // 2. cPes.streamType === 0x0f || cPes.streamType === 0x11 只处理aac,其他音频格式当无音频
            var isAAC = cPes.streamType === 0x0f || cPes.streamType === 0x11;
            if (cPes.type === 'audio' && !noAudio && isAAC) {
              cPes.ES.buffer = TsDemuxer.mergeAudioES(cPes.ES.buffer);
              this.pushAudioSample(cPes, AudioOptions);
              AudioOptions = {};
            } else if (cPes.type === 'video' && !noVideo) {
              cPes.ES.buffer = TsDemuxer.mergeVideoES(cPes.ES.buffer);
              if (cPes.codec === 'HVC.H265') {
                this.pushVideoSampleHEVC(epeses[j], VideoOptions);
              } else {
                this.pushVideoSample(epeses[j], VideoOptions);
              }
              VideoOptions = { spsFound: !!VideoOptions.spsFound };
            }
          }
        }
      }
    }, {
      key: 'pushAudioSample',
      value: function pushAudioSample(pes, options) {
        var meta = new AudioTrackMeta({
          audioSampleRate: pes.ES.frequence,
          sampleRate: pes.ES.frequence,
          channelCount: pes.ES.channel,
          codec: 'mp4a.40.' + pes.ES.audioObjectType,
          originCodec: 'mp4a.40.' + pes.ES.originAudioObjectType,
          originObjectType: pes.ES.originAudioObjectType,
          config: pes.ES.audioConfig,
          id: 2,
          sampleRateIndex: pes.ES.frequencyIndex
        });
        meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);

        var metaEqual = TsDemuxer.compareMeta(this.audioTrack.meta, meta, true);

        if (!this._hasAudioMeta || !metaEqual) {
          this._hasAudioMeta = true;
          if (options) {
            options.meta = Object.assign({}, meta);
          } else {
            options = {
              meta: Object.assign({}, meta)
            };
          }
          this.emit(TsDemuxer.EVENTS.METADATA_PARSED, 'audio', meta);
        }

        var frameIndex = 0;
        pes.ES.buffer.skip(pes.pesHeaderLength + 9);
        var streamChanged = false;
        while (pes.ES.buffer.position < pes.ES.buffer.length) {
          if (ADTS$1.isHeader(new Uint8Array(pes.ES.buffer.buffer), pes.ES.buffer.position) && pes.ES.buffer.position + 5 < pes.ES.buffer.length) {
            var frame = ADTS$1.appendFrame(this.audioTrack.meta.sampleRate, new Uint8Array(pes.ES.buffer.buffer), pes.ES.buffer.position, pes.pts, frameIndex);
            if (frame && frame.sample) {
              // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
              pes.ES.buffer.skip(frame.length);
              var sample = new AudioSample({
                dts: frame.sample.dts,
                pts: frame.sample.pts,
                data: frame.sample.unit,
                options: streamChanged ? {} : options
              });
              if (options.meta) {
                streamChanged = true;
              }
              sample.dts = sample.pts = Math.ceil(sample.pts / 90);
              this.emit(TsDemuxer.EVENTS.AUDIO_SAMPLE_PARSED, sample);
              frameIndex++;
            } else {
              // logger.log('Unable to parse AAC frame');
              break;
            }
          } else {
            // nothing found, keep looking
            pes.ES.buffer.skip(1);
          }
        }
      }
    }, {
      key: 'pushVideoSample',
      value: function pushVideoSample(pes, options) {
        var _this2 = this;

        var nals = NalUnit$1.getNalunits(pes.ES.buffer);
        var meta = new VideoTrackMeta();
        var spsFound = options.spsFound; // 保存当前分片内是否解析过sps
        var sampleLength = 0;
        var sps = false;
        var pps = false;
        var seiList = [];
        for (var i = 0; i < nals.length; i++) {
          var nal = nals[i];
          if (nal.type < 9 && !nal.sei) {
            sampleLength += 4 + nal.body.byteLength;
          }
          if (nal.sps) {
            sps = nal;
            meta.sps = nal.body;
            meta.chromaFormat = sps.sps.chroma_format;
            meta.codec = 'avc1.';
            for (var j = 1; j < 4; j++) {
              var h = sps.body[j].toString(16);
              if (h.length < 2) {
                h = '0' + h;
              }
              meta.codec += h;
            }
            meta.codecHeight = sps.sps.codec_size.height;
            meta.codecWidth = sps.sps.codec_size.width;
            meta.frameRate = sps.sps.frame_rate;
            meta.id = 1;
            meta.level = sps.sps.level_string;
            meta.presentHeight = sps.sps.present_size.height;
            meta.presentWidth = sps.sps.present_size.width;
            meta.profile = sps.sps.profile_string;
            meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));
            meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;
          } else if (nal.pps) {
            meta.pps = nal.body;
            pps = nal;
          } else if (nal.sei) {
            seiList.push(nal.sei);
          }
        }

        if (sps && pps) {
          meta.avcc = NalUnit$1.getAvcc(sps.body, pps.body);
          var metaEqual = TsDemuxer.compareMeta(this.videoTrack.meta, meta, true);
          if (!this._hasVideoMeta || !metaEqual) {
            if (options) {
              options.meta = Object.assign({}, meta);
            } else {
              options = {
                meta: Object.assign({}, meta)
              };
            }
            if (!spsFound) {
              this.emit(TsDemuxer.EVENTS.METADATA_PARSED, 'video', meta);
            }
            options.spsFound = true;
            this._hasVideoMeta = true;
          }
        }

        var data = new Uint8Array(sampleLength);
        var offset = 0;
        var isKeyframe = false;
        for (var _i = 0; _i < nals.length; _i++) {
          var _nal = nals[_i];
          if (_nal.type && _nal.type >= 9) {
            continue;
          }
          var length = _nal.body.byteLength;
          if (_nal.idr) {
            isKeyframe = true;
          }
          if (!_nal.sei) {
            data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);
            offset += 4;
            data.set(_nal.body, offset);
            offset += length;
          }
        }
        var dts = parseInt(pes.dts / 90);
        var pts = parseInt(pes.pts / 90);

        if (seiList.length) {
          seiList.forEach(function (sei) {
            sei.dts = dts;
            _this2.emit(TsDemuxer.EVENTS.SEI_PARSED, sei);
          });
        }
        var sample = new VideoSample({
          dts: dts,
          pts: pts,
          cts: pts - dts,
          originDts: pes.dts,
          purePts: pes.purePts,
          isKeyframe: isKeyframe,
          data: data,
          nals: nals,
          options: options,
          firstInGop: isKeyframe,
          gopId: isKeyframe ? ++this.gopId : this.gopId
        });
        this.emit(TsDemuxer.EVENTS.VIDEO_SAMPLE_PARSED, sample);
      }
    }, {
      key: 'pushVideoSampleHEVC',
      value: function pushVideoSampleHEVC(pes, options) {
        var _this3 = this;

        var nals = NalUnitHEVC$1.getNalunits(pes.ES.buffer);
        nals = nals.filter(function (x) {
          return x.body && x.body.length;
        });
        var meta = new VideoTrackMeta();
        meta.streamType = 0x24;

        var sampleLength = 0;
        var vps = false;
        var sps = false;
        var pps = false;
        var seiList = [];
        var hasVPS = false;
        var hasSPS = false;
        var hasPPS = false;
        var firstInGop = false;
        for (var i = 0; i < nals.length; i++) {
          var nal = nals[i];

          if (nal.vps) {
            if (hasVPS) {
              continue;
            } else {
              hasVPS = true;
            }
          } else if (nal.sps) {
            if (hasSPS) {
              continue;
            } else {
              hasSPS = true;
            }
          } else if (nal.pps) {
            if (hasPPS) {
              continue;
            } else {
              hasPPS = true;
            }
          } else if (nal.key) {
            if (nal.type === 20 || nal.type === 19) {
              firstInGop = true;
            }
          } else if (nal.type === 0) ; else if (nal.type === 35) {
            continue;
          }
          if (nal.sps) {
            sps = nal;
            meta.sps = nal.body;

            meta.presentWidth = sps.sps.width;
            meta.presentHeight = sps.sps.height;
            meta.general_profile_space = sps.sps.general_profile_space;
            meta.general_tier_flag = sps.sps.general_tier_flag;
            meta.general_profile_idc = sps.sps.general_profile_idc;
            meta.general_level_idc = sps.sps.general_level_idc;
            // meta.duration = this._duration;
            meta.codec = 'hev1.1.6.L93.B0';
            meta.chromaFormatIdc = sps.sps.chromaFormatIdc;
            meta.bitDepthLumaMinus8 = sps.sps.bitDepthLumaMinus8;
            meta.bitDepthChromaMinus8 = sps.sps.bitDepthChromaMinus8;
          } else if (nal.pps) {
            meta.pps = nal.body;
            pps = nal;
          } else if (nal.vps) {
            meta.vps = nal.body;
            vps = nal;
          } else if (nal.sei) {
            seiList.push(nal.sei);
          }
          if (nal.type <= 40) {
            sampleLength += 4 + nal.body.byteLength;
          }
        }

        if (sps && pps && vps) {
          // meta.avcc = NalUnitHEVC.getAvcc(sps.body, pps.body);
          var metaEqual = TsDemuxer.compareMeta(this.videoTrack.meta, meta, true);
          if (!this._hasVideoMeta || !metaEqual) {
            if (options) {
              options.meta = Object.assign({}, meta);
            } else {
              options = {
                meta: Object.assign({}, meta)
              };
            }
            meta.streamType = 0x24;
            this.videoTrack.meta = meta;
            this._hasVideoMeta = true;
            this.emit(TsDemuxer.EVENTS.METADATA_PARSED, 'video', meta);
          }
        }

        var data = new Uint8Array(sampleLength);
        var offset = 0;
        var isKeyframe = false;
        hasVPS = false;
        hasSPS = false;
        hasPPS = false;
        for (var _i2 = 0; _i2 < nals.length; _i2++) {
          var _nal2 = nals[_i2];
          if (_nal2.type && _nal2.type > 40) {
            continue;
          }

          if (_nal2.vps) {
            if (hasVPS) {
              continue;
            } else {
              hasVPS = true;
            }
          } else if (_nal2.sps) {
            if (hasSPS) {
              continue;
            } else {
              hasSPS = true;
            }
          } else if (_nal2.pps) {
            if (hasPPS) {
              continue;
            } else {
              hasPPS = true;
            }
          } else if (_nal2.key) ; else if (_nal2.type === 0) ; else if (_nal2.type === 35) {
            continue;
          }
          var length = _nal2.body.byteLength;
          if (_nal2.key) {
            isKeyframe = true;
          }
          // if (!nal.vps && !nal.pps && !nal.sps) {
          data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);
          offset += 4;
          data.set(_nal2.body, offset);
          offset += length;
          // }
        }
        var dts = parseInt(pes.dts / 90);
        var pts = parseInt(pes.pts / 90);

        if (seiList) {
          seiList.forEach(function (sei) {
            sei.dts = dts;
            _this3.emit(TsDemuxer.EVENTS.SEI_PARSED, sei);
          });
        }

        var sample = new VideoSample({
          dts: dts,
          pts: pts,
          cts: pts - dts,
          originDts: pes.dts,
          purePts: pes.purePts,
          isKeyframe: isKeyframe,
          data: data,
          nals: nals,
          options: options,
          firstInGop: firstInGop,
          gopId: firstInGop ? ++this.gopId : this.gopId
        });
        this.emit(TsDemuxer.EVENTS.VIDEO_SAMPLE_PARSED, sample);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.removeAllListeners();
        this.configs = {};
        this.demuxing = false;
        this.pat = [];
        this.pmt = [];
        this._hasVideoMeta = false;
        this._hasAudioMeta = false;
      }
    }], [{
      key: 'compareArray',
      value: function compareArray(a, b, type) {
        var al = 0;
        var bl = 0;
        if (type === 'Uint8Array') {
          al = a.byteLength;
          bl = b.byteLength;
        } else if (type === 'Array') {
          al = a.length;
          bl = b.length;
        }
        if (al !== bl) {
          return false;
        }

        for (var i = 0; i < al; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: 'compareMeta',
      value: function compareMeta(a, b, ignoreDuration) {
        if (!a || !b) {
          return false;
        }

        for (var i = 0, k = Object.keys(a).length; i < k; i++) {
          var itema = a[Object.keys(a)[i]];
          var itemb = b[Object.keys(a)[i]];
          if (!itema && !itemb) {
            return true;
          }

          if ((itema === undefined || itema === null) && itemb || itema && itemb === undefined) {
            return false;
          }

          if ((typeof itema === 'undefined' ? 'undefined' : _typeof$3(itema)) !== 'object') {
            if (ignoreDuration && Object.keys(a)[i] !== 'duration' && Object.keys(a)[i] !== 'refSampleDuration' && Object.keys(a)[i] !== 'refSampleDurationFixed' && itema !== itemb) {
              return false;
            }
          } else if (itema.byteLength !== undefined) {
            if (itemb.byteLength === undefined) {
              return false;
            }
            if (!TsDemuxer.compareArray(itema, itemb, 'Uint8Array')) {
              return false;
            }
          } else if (itema.length !== undefined) {
            if (itemb.length === undefined) {
              return false;
            }
            if (!TsDemuxer.compareArray(itema, itemb, 'Array')) {
              return false;
            }
          } else {
            if (!TsDemuxer.compareMeta(itema, itemb)) {
              return false;
            }
          }
        }
        return true;
      }
    }, {
      key: 'mergeVideoES',
      value: function mergeVideoES(buffers) {
        var data = void 0;
        var length = 0;
        var offset = 0;
        for (var i = 0; i < buffers.length; i++) {
          length += buffers[i].length - buffers[i].position;
        }

        data = new Uint8Array(length);
        for (var _i3 = 0; _i3 < buffers.length; _i3++) {
          var buffer = buffers[_i3];
          data.set(new Uint8Array(buffer.buffer, buffer.position), offset);
          offset += buffer.length - buffer.position;
        }
        return new XGDataView(data.buffer);
      }
    }, {
      key: 'mergeAudioES',
      value: function mergeAudioES(buffers) {
        var data = void 0;
        var length = 0;
        var offset = 0;
        for (var i = 0; i < buffers.length; i++) {
          length += buffers[i].length;
        }

        data = new Uint8Array(length);
        for (var _i4 = 0; _i4 < buffers.length; _i4++) {
          var buffer = buffers[_i4];
          data.set(new Uint8Array(buffer.buffer), offset);
          offset += buffer.length;
        }

        return new XGDataView(data.buffer);
      }
    }, {
      key: 'read',
      value: function read(stream, ts, frags) {
        TsDemuxer.readHeader(stream, ts);
        TsDemuxer.readPayload(stream, ts, frags);
        // console.log('start', window.performance.now());
        // console.log('end', window.performance.now());
        if (ts.header.packet === 'MEDIA' && ts.header.payload === 1 && !ts.unknownPIDs) {
          ts.pes = TsDemuxer.PES(ts);
        }
      }
    }, {
      key: 'readPayload',
      value: function readPayload(stream, ts, frags) {
        var header = ts.header;
        var pid = header.pid;
        switch (pid) {
          case 0:
            TsDemuxer.PAT(stream, ts, frags);
            break;
          case 1:
            TsDemuxer.CAT(stream, ts, frags);
            break;
          case 2:
            TsDemuxer.TSDT(stream, ts, frags);
            break;
          case 0x1fff:
            break;
          default:
            var isPMT = false;
            for (var i = 0, len = frags.pat.length; i < len; i++) {
              if (frags.pat[i].pid === pid) {
                isPMT = true;
                break;
              }
            }
            // TODO: some的写法不太好，得改
            if (isPMT) {
              TsDemuxer.PMT(stream, ts, frags);
            } else {
              var sts = [];
              for (var _i5 = 0, _len = frags.pmt.length; _i5 < _len; _i5++) {
                if (frags.pmt[_i5].pid === pid) {
                  sts.push(frags.pmt[_i5]);
                  break;
                }
              }
              if (sts.length > 0) {
                var streamType = sts[0].streamType;
                TsDemuxer.Media(stream, ts, streamType);
              } else {
                ts.unknownPIDs = true;
              }
            }
        }
      }
    }, {
      key: 'readHeader',
      value: function readHeader(stream, ts) {
        var header = {};
        header.sync = stream.readUint8();
        var next = stream.readUint16();
        header.error = next >>> 15;
        header.payload = next >>> 14 & 1;
        header.priority = next >>> 13 & 1;
        header.pid = next & 0x1fff;

        next = stream.readUint8();

        header.scrambling = next >> 6 & 0x3; // 是否加密，00表示不加密

        /**
         * 00 ISO/IEC未来使用保留
         * 01 没有调整字段，仅含有184B有效净荷
         * 02 没有有效净荷，仅含有183B调整字段
         * 03 0~182B调整字段后为有效净荷
         */
        header.adaptation = next >> 4 & 0x3;
        header.continuity = next & 15;
        header.packet = header.pid === 0 ? 'PAT' : 'MEDIA';
        ts.header = header;
      }
    }, {
      key: 'PAT',
      value: function PAT(stream, ts, frags) {
        var ret = {};
        var next = stream.readUint8();
        stream.skip(next);
        next = stream.readUint8();
        ret.tabelID = next;
        next = stream.readUint16();
        ret.error = next >>> 7;
        ret.zero = next >>> 6 & 1;
        ret.sectionLength = next & 0xfff;
        ret.streamID = stream.readUint16();
        ret.current = stream.readUint8() & 1;
        ret.sectionNumber = stream.readUint8();
        ret.lastSectionNumber = stream.readUint8();
        var N = (ret.sectionLength - 9) / 4;
        var list = [];
        for (var i = 0; i < N; i++) {
          var programNumber = stream.readUint16();
          var pid = stream.readUint16() & 0x1fff;
          list.push({
            program: programNumber,
            pid: pid,
            type: programNumber === 0 ? 'network' : 'mapPID'
          });
        }
        if (list.length > 0) {
          frags.pat = frags.pat.concat(list);
        }
        ret.list = list;
        ret.program = stream.readUint16();
        ret.pid = stream.readUint16() & 0x1fff;
        ts.payload = ret;
        // TODO CRC
      }

      /**
       * ISO-13818-1 Table-2-25
       * payload 针对 PMT:
       *  1 字节： table id [table 第一字节]
       *  section_length : 12bit 【table 第2字节后四位，3字节】
       *  program_number : 16bit 【table第4，5字节】
       *  program_info_length : 12bit 【table 第11字节后 4bit + 第12 byte】
       *  N * 8 : descriptor
       *    stream_type : 8bit
       *    pid
       *
       * // 4 字节
       *  reserved : 3bit
       *  elementary_PID : 13bit
       *  reserved : 4bit
       *  ES_info_length: 12bit
       */

    }, {
      key: 'PMT',
      value: function PMT(stream, ts, frags) {
        var header = ts.header;
        header.packet = 'PMT';

        var offset = stream.position;

        offset += stream.getUint8(offset);

        offset += 1; // add 1 byte for table id

        var sectionLength = (stream.getUint8(offset + 1) & 0x0f) << 8 | stream.getUint8(offset + 2);

        var tableEnd = offset + 3 + sectionLength - 4;

        var programInfoLength = (stream.getUint8(offset + 10) & 0x0f) << 8 | stream.getUint8(offset + 11);

        offset += 12 + programInfoLength;

        var list = [];

        while (offset < tableEnd) {
          var pid = (stream.getUint8(offset + 1) & 0x1f) << 8 | stream.getUint8(offset + 2);
          list.push({
            streamType: stream.getUint8(offset),
            pid: pid
          });
          offset += ((stream.getUint8(offset + 3) & 0x0f) << 8 | stream.getUint8(offset + 4)) + 5;
        }
        frags.pmt = list;
        stream.skip(tableEnd + 4);
      }
    }, {
      key: 'Media',
      value: function Media(stream, ts, streamType) {
        var header = ts.header;
        var payload = {};

        var _StreamType$streamTyp = _slicedToArray(StreamType[streamType], 2),
            type = _StreamType$streamTyp[0],
            codec = _StreamType$streamTyp[1];

        header.streamType = streamType;
        header.type = type;
        header.codec = codec;

        if (header.adaptation === 0x03) {
          payload.adaptationLength = stream.readUint8();
          if (payload.adaptationLength > 0) {
            var next = stream.readUint8();
            payload.discontinue = next >>> 7;
            payload.access = next >>> 6 & 0x01;
            payload.priority = next >>> 5 & 0x01;
            payload.PCR = next >>> 4 & 0x01;
            payload.OPCR = next >>> 3 & 0x01;
            payload.splicePoint = next >>> 2 & 0x01;
            payload.transportPrivate = next >>> 1 & 0x01;
            payload.adaptationField = next & 0x01;
            var _start = stream.position;
            if (payload.PCR === 1) {
              payload.programClockBase = stream.readUint32() << 1;
              next = stream.readUint16();
              payload.programClockBase |= next >>> 15;
              payload.programClockExtension = next & 0x1ff;
            }
            if (payload.OPCR === 1) {
              payload.originProgramClockBase = stream.readUint32() << 1;
              next = stream.readUint16();
              payload.originProgramClockBase += next >>> 15;
              payload.originProgramClockExtension = next & 0x1ff;
            }
            if (payload.splicePoint === 1) {
              payload.spliceCountdown = stream.readUint8();
            }
            if (payload.transportPrivate === 1) {
              var length = stream.readUint8();
              var transportPrivateData = [];
              for (var i = 0; i < length; i++) {
                transportPrivateData.push(stream.readUint8());
              }
            }
            if (payload.adaptationField === 1) {
              var _length = stream.readUint8();
              var _next = stream.readUint8();
              var start = stream.position;
              var ltw = _next >>> 7;
              var piecewise = _next >>> 6 & 0x1;
              var seamless = _next >>> 5 & 0x1;
              if (ltw === 1) {
                _next = stream.readUint16();
                payload.ltwValid = _next >>> 15;
                payload.ltwOffset = _next & 0xefff;
              }
              if (piecewise === 1) {
                _next = stream.readUint24();
                payload.piecewiseRate = _next & 0x3fffff;
              }
              if (seamless === 1) {
                _next = stream.readInt8();
                payload.spliceType = _next >>> 4;
                payload.dtsNextAU1 = _next >>> 1 & 0x7;
                payload.marker1 = _next & 0x1;
                _next = stream.readUint16();
                payload.dtsNextAU2 = _next >>> 1;
                payload.marker2 = _next & 0x1;
                _next = stream.readUint16();
                payload.dtsNextAU3 = _next;
              }
              stream.skip(_length - 1 - (stream.position - start));
            }
            var lastStuffing = payload.adaptationLength - 1 - (stream.position - _start);
            stream.skip(lastStuffing);
          }
        }
        payload.stream = new XGDataView(stream.buffer.slice(stream.position));
        ts.payload = payload;
      }

      /**
       * http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
       * ISO-13818-1 Table-2-17
       * packet_start_code_prefix : 24bit 0x000001
       * stream_id : 8bit
       * PES_packet_length : 16bit
       * PTS_DTS_flags : 2bit 【PES_packet_length后第2字节前2位】& 0xc0  [0x10 0x11]
       * PES_header_data_length : 【PTS_DTS_flags 后第1字节】
       *
       * | 6字节header | 3字节扩展 | PES Header data | payload |
       */

    }, {
      key: 'PES',
      value: function PES(ts) {
        var ret = {};
        var buffer = ts.payload.stream;

        var next = buffer.readUint24();
        if (next !== 1) {
          ret.ES = {};
          ret.ES.buffer = buffer;
        } else {
          var streamID = buffer.readUint8();
          if (streamID >= 0xe0 && streamID <= 0xef) {
            ret.type = 'video';
          }
          if (streamID >= 0xc0 && streamID <= 0xdf) {
            ret.type = 'audio';
          }
          var packetLength = buffer.readUint16();
          ret.packetLength = packetLength;
          if (ret.type === 'video' || ret.type === 'audio') {
            var _next2 = buffer.readUint8();
            var first = _next2 >>> 6;
            if (first !== 0x02) {
              throw new Error('error when parse pes header');
            }
            _next2 = buffer.readUint8();
            ret.ptsDTSFlag = _next2 >>> 6;
            ret.escrFlag = _next2 >>> 5 & 0x01;
            ret.esRateFlag = _next2 >>> 4 & 0x01;
            ret.dsmFlag = _next2 >>> 3 & 0x01;
            ret.additionalFlag = _next2 >>> 2 & 0x01;
            ret.crcFlag = _next2 >>> 1 & 0x01;
            ret.extensionFlag = _next2 & 0x01;
            ret.pesHeaderLength = buffer.readUint8();
            var N1 = ret.pesHeaderLength;

            // 计算pts
            var pts = [];

            pts.push(buffer.readUint8());
            pts.push(buffer.readUint8());
            pts.push(buffer.readUint8());
            pts.push(buffer.readUint8());
            pts.push(buffer.readUint8());

            var p = (pts[0] & 0x0e) * 536870912 + // 1 << 29
            (pts[1] & 0xff) * 4194304 + // 1 << 22
            (pts[2] & 0xfe) * 16384 + // 1 << 14
            (pts[3] & 0xff) * 128 + // 1 << 7
            (pts[4] & 0xfe) / 2;
            // 不经过任何处理的原始的pts
            ret.purePts = p;
            buffer.dataview.position -= 5;
            pts = [];

            _next2 = buffer.readUint8();
            pts.push(_next2 >>> 1 & 0x07);
            _next2 = buffer.readUint16();
            pts.push(_next2 >>> 1);
            _next2 = buffer.readUint16();
            pts.push(_next2 >>> 1);
            ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];
            N1 -= 5;

            // 视频如果没有dts用pts
            if (ret.type === 'video') {
              ret.dts = ret.pts;
            }

            if (ret.ptsDTSFlag === 3) {
              var dts = [];
              _next2 = buffer.readUint8();
              dts.push(_next2 >>> 1 & 0x07);
              _next2 = buffer.readUint16();
              dts.push(_next2 >>> 1);
              _next2 = buffer.readUint16();
              dts.push(_next2 >>> 1);
              ret.dts = dts[0] << 30 | dts[1] << 15 | dts[2];
              N1 -= 5;
            }

            if (ret.escrFlag === 1) {
              var escr = [];
              var ex = [];
              _next2 = buffer.readUint8();
              escr.push(_next2 >>> 3 & 0x07);
              escr.push(_next2 & 0x03);
              _next2 = buffer.readUint16();
              escr.push(_next2 >>> 13);
              escr.push(_next2 & 0x03);
              _next2 = buffer.readUint16();
              escr.push(_next2 >>> 13);
              ex.push(_next2 & 0x03);
              _next2 = buffer.readUint8();
              ex.push(_next2 >>> 1);
              ret.escr = (escr[0] << 30 | escr[1] << 28 | escr[2] << 15 | escr[3] << 13 | escr[4]) * 300 + (ex[0] << 7 | ex[1]);
              N1 -= 6;
            }
            if (ret.esRateFlag === 1) {
              _next2 = buffer.readUint24();
              ret.esRate = _next2 >>> 1 & 0x3fffff;
              N1 -= 3;
            }
            if (ret.dsmFlag === 1) {
              throw new Error('not support DSM_trick_mode');
            }
            if (ret.additionalFlag === 1) {
              _next2 = buffer.readUint8();
              ret.additionalCopyInfo = _next2 & 0x7f;
              N1 -= 1;
            }
            if (ret.crcFlag === 1) {
              ret.pesCRC = buffer.readUint16();
              N1 -= 2;
            }
            if (ret.extensionFlag === 1) {
              throw new Error('not support extension');
            }
            if (N1 > 0) {
              buffer.skip(N1);
            }
            if (ret.dts > ret.pts) {
              ret.dts = ret.pts;
            }
            ret.ES = TsDemuxer.ES(buffer, ret.type, ts.header.streamType);
          } else {
            throw new Error('format is not supported');
          }
        }
        return ret;
      }
    }, {
      key: 'ES',
      value: function ES(buffer, type, streamType) {
        var ret = {};
        if (type === 'video') {
          // TODO readnalu
          ret.buffer = buffer;
        } else if (type === 'audio') {
          if (streamType === 0x0f || streamType === 0x11) {
            ret = TsDemuxer.parseADTSHeader(buffer);
          }
          ret.buffer = buffer;
        } else {
          throw new Error('ES ' + type + ' is not supported');
        }

        return ret;
      }
    }, {
      key: 'parseADTSHeader',
      value: function parseADTSHeader(buffer) {
        var ret = {};
        var next = buffer.readUint16();
        // adts的同步字节，12位
        if (next >>> 4 !== 0xfff) {
          throw new Error('aac ES parse Error');
        }
        var fq = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
        ret.id = (next >>> 3 & 0x01) === 0 ? 'MPEG-4' : 'MPEG-2';
        ret.layer = next >>> 1 & 0x03;
        ret.absent = next & 0x01;
        next = buffer.readUint16();
        ret.audioObjectType = (next >>> 14 & 0x03) + 1;
        ret.profile = ret.audioObjectType - 1;
        ret.frequencyIndex = next >>> 10 & 0x0f;
        ret.frequence = fq[ret.frequencyIndex];
        ret.channel = next >>> 6 & 0x07;
        ret.frameLength = (next & 0x03) << 11 | buffer.readUint16() >>> 5;
        TsDemuxer.getAudioConfig(ret);
        buffer.skip(1);
        ret.buffer = buffer;
        return ret;
      }
    }, {
      key: 'TSDT',
      value: function TSDT(stream, ts, frags) {
        // TODO
        ts.payload = {};
      }
    }, {
      key: 'CAT',
      value: function CAT(stream, ts, frags) {
        var ret = {};
        ret.tableID = stream.readUint8();
        var next = stream.readUint16();
        ret.sectionIndicator = next >>> 7;
        ret.sectionLength = next & 0x0fff;
        stream.skip(2);
        next = stream.readUint8();
        ret.version = next >>> 3;
        ret.currentNextIndicator = next & 0x01;
        ret.sectionNumber = stream.readUint8();
        ret.lastSectionNumber = stream.readUint8();
        var N = (this.sectionLength - 9) / 4;
        ret.crc32 = stream.readUint32();
        ts.payload = ret;
      }
    }, {
      key: 'getAudioConfig',
      value: function getAudioConfig(ret) {
        var userAgent = navigator.userAgent.toLowerCase();
        var config = void 0;
        var extensionSampleIndex = void 0;
        ret.originAudioObjectType = ret.audioObjectType;
        if (/firefox/i.test(userAgent)) {
          if (ret.frequencyIndex >= 8) {
            ret.audioObjectType = 5;
            config = new Array(4);
            extensionSampleIndex = ret.frequencyIndex - 3;
          } else {
            ret.audioObjectType = 2;
            config = new Array(2);
            extensionSampleIndex = ret.frequencyIndex;
          }
        } else if (userAgent.indexOf('android') !== -1) {
          ret.audioObjectType = 2;
          config = new Array(2);
          extensionSampleIndex = ret.frequencyIndex;
        } else {
          ret.audioObjectType = 5;
          config = new Array(4);
          if (ret.frequencyIndex >= 6) {
            extensionSampleIndex = ret.frequencyIndex - 3;
          } else {
            if (ret.channel === 1) {
              ret.audioObjectType = 2;
              config = new Array(2);
            }
            extensionSampleIndex = ret.frequencyIndex;
          }
        }

        config[0] = ret.audioObjectType << 3;
        config[0] |= (ret.frequencyIndex & 0x0e) >> 1;
        config[1] = (ret.frequencyIndex & 0x01) << 7;
        config[1] |= ret.channel << 3;
        if (ret.audioObjectType === 5) {
          config[1] |= (extensionSampleIndex & 0x0e) >> 1;
          config[2] = (extensionSampleIndex & 0x01) << 7;
          config[2] |= 2 << 2;
          config[3] = 0;
        }

        ret.audioConfig = config;
      }
    }]);

    return TsDemuxer;
  }(eventemitter3$1);

  var _createClass$q = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$q(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var DEMUX_EVENTS$2 = EVENTS.DEMUX_EVENTS;

  /**
   * @typedef {import('xgplayer-helper-models').TsFrag} TsFrag
   */

  var TsDemuxer$1 = function () {
    function TsDemuxer$1(configs) {
      _classCallCheck$q(this, TsDemuxer$1);

      this.configs = Object.assign({}, configs);
      this.demuxer = null;
    }

    _createClass$q(TsDemuxer$1, [{
      key: 'init',
      value: function init() {
        this.on(DEMUX_EVENTS$2.DEMUX_START, this.demux.bind(this));
      }
    }, {
      key: 'initDemuxer',
      value: function initDemuxer() {
        this.demuxer.on(TsDemuxer.EVENTS.METADATA_PARSED, this.onMetaDataParsed.bind(this));
        this.demuxer.on(TsDemuxer.EVENTS.VIDEO_SAMPLE_PARSED, this.onVideoSampleParsed.bind(this));
        this.demuxer.on(TsDemuxer.EVENTS.AUDIO_SAMPLE_PARSED, this.onAudioSampleParsed.bind(this));
        this.demuxer.on(TsDemuxer.EVENTS.SEI_PARSED, this.emit.bind(this, DEMUX_EVENTS$2.SEI_PARSED));
      }

      /**
       * @param {TsFrag} frag
       * @param {boolean} isVod
       */

    }, {
      key: 'demux',
      value: function demux(frag, isVod) {
        if (!this._tracks) {
          return;
        }
        if (!this._tracks.audioTrack) {
          this._tracks.audioTrack = new AudioTrack();
        }

        if (!this._tracks.videoTrack) {
          this._tracks.videoTrack = new VideoTrack();
        }

        if (!this.demuxer) {
          this.demuxer = new TsDemuxer(this._tracks);
          this.initDemuxer();
        }
        try {
          this.demuxer.demux(frag, this.inputBuffer, isVod);
        } catch (e) {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, e, false);
        }
        var hasVideo = this._tracks.videoTrack && this._tracks.videoTrack.samples.length ? 1 : 0;
        var hasAudio = this._tracks.audioTrack && this._tracks.audioTrack.samples.length ? 1 : 0;
        this.emit(DEMUX_EVENTS$2.DEMUX_COMPLETE, hasVideo, hasAudio);
      }
    }, {
      key: 'onMetaDataParsed',
      value: function onMetaDataParsed(type, meta) {
        var _tracks = this._tracks,
            videoTrack = _tracks.videoTrack,
            audioTrack = _tracks.audioTrack;

        var track = videoTrack;

        switch (type) {
          case 'video':
            track = videoTrack;
            break;
          case 'audio':
            track = audioTrack;
            break;
          default:
            track = videoTrack;
        }
        track.meta = meta;
        this.emit(DEMUX_EVENTS$2.METADATA_PARSED, type, meta);
      }
    }, {
      key: 'onVideoSampleParsed',
      value: function onVideoSampleParsed(sample) {
        if (sample.isKeyframe) {
          this.emit(DEMUX_EVENTS$2.ISKEYFRAME, sample.pts);
        }
        this._tracks.videoTrack.samples.push(sample);
      }
    }, {
      key: 'onAudioSampleParsed',
      value: function onAudioSampleParsed(sample) {
        this._tracks.audioTrack.samples.push(sample);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.off(DEMUX_EVENTS$2.DEMUX_START, this.demux);
        this.configs = {};
        this.demuxer && this.demuxer.destroy();
      }
    }, {
      key: 'inputBuffer',
      get: function get() {
        return this._context.getInstance(this.configs.inputbuffer);
      }
    }, {
      key: '_tracks',
      get: function get() {
        return this._context.getInstance('TRACKS');
      }
    }]);

    return TsDemuxer$1;
  }();

  var _createClass$r = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$r(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var REGEXP_ABSOLUTE_URL = /^(?:[a-zA-Z0-9+\-.]+:)?\/\//;
  var REGEXP_URL_PAIR = /^((?:[a-zA-Z0-9+\-.]+:)?\/\/[^/?#]*)?([^?#]*\/)?/;

  function getAbsoluteUrl(url, parentUrl) {
    if (!parentUrl || !url || REGEXP_ABSOLUTE_URL.test(url)) return url;
    var pairs = REGEXP_URL_PAIR.exec(parentUrl);
    if (!pairs) return url;
    if (url[0] === '/') return pairs[1] + url;
    return pairs[1] + pairs[2] + url;
  }

  /**
   * Reference: https://tools.ietf.org/html/rfc8216#section-4.3
   */

  var M3U8Parser = function () {
    function M3U8Parser() {
      _classCallCheck$r(this, M3U8Parser);
    }

    _createClass$r(M3U8Parser, null, [{
      key: 'parse',

      /**
       * @param {string} text
       * @param {string} baseurl
       * @return {{duration: number}}
       */
      value: function parse(text) {
        var baseurl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        var ret = {
          duration: 0
        };
        if (!text || !text.split) {
          return;
        }
        var refs = text.split(/\r|\n/);
        refs = refs.filter(function (ref) {
          return ref;
        });
        var ref = refs.shift();
        if (!ref.match('#EXTM3U')) {
          throw new Error('Invalid m3u8 file: not "#EXTM3U"');
        }
        ref = refs.shift();
        var nextDiscontinue = false;
        var nextId = 0;
        while (ref) {
          var refm = ref.match(/#(.[A-Z|-]*):(.*)/);
          var refd = ref.match(/#(.[A-Z|-]*)/);
          if (refd && refm && refm.length > 2) {
            switch (refm[1]) {
              case 'EXT-X-VERSION':
                ret.version = parseInt(refm[2]);
                break;
              case 'EXT-X-MEDIA-SEQUENCE':
                ret.sequence = parseInt(refm[2]);
                break;
              case 'EXT-X-TARGETDURATION':
                ret.targetduration = parseFloat(refm[2]);
                break;
              case 'EXTINF':
                nextId = M3U8Parser.parseFrag(refm, refs, ret, baseurl, nextDiscontinue, nextId);
                nextDiscontinue = false;
                break;
              case 'EXT-X-KEY':
                M3U8Parser.parseDecrypt(refm[2], ret);
                break;
            }
          }if (refd && refd.length > 1) {
            switch (refd[1]) {
              case 'EXT-X-DISCONTINUITY':
                nextDiscontinue = true;
                break;
              case 'EXT-X-ENDLIST':
                var last = ret.frags[ret.frags.length - 1];
                last.isLast = true;
                ret.end = true;
                break;
            }
          }
          ref = refs[nextId++];
        }
        return ret;
      }

      /**
       *
       * @param {string[]}refm
       * @param {string[]}refs
       * @param {*} ret
       * @param {string} baseurl
       * @param {boolean} discontinue
       * @param {number} nextId
       * @return {*}
       */

    }, {
      key: 'parseFrag',
      value: function parseFrag(refm, refs, ret, baseurl, discontinue, nextId) {
        if (!ret.frags) {
          ret.frags = [];
        }

        var frag = new TsFrag({
          start: ret.duration,
          duration: parseInt(parseFloat(refm[2]) * 1000)
        });

        if (frag.duration < 200) {
          return nextId;
        }

        ret.duration += frag.duration;
        var nextline = refs[nextId++];
        if (nextline.match(/#(.*):(.*)/) || nextline.match(/^#/)) {
          nextline = refs[nextId++];
        }

        frag.url = getAbsoluteUrl(nextline, baseurl);

        frag.discontinue = discontinue;
        // add id
        if (ret.frags.length) {
          var last = ret.frags[ret.frags.length - 1];
          frag.id = last.id + 1;
          frag.cc = discontinue ? last.cc + 1 : last.cc;
        } else {
          frag.id = ret.sequence || 1;
          frag.cc = 0;
        }
        ret.frags.push(frag);
        return nextId;
      }

      /**
       * @param {string[]}refm
       * @param {*} ret
       */

    }, {
      key: 'parseDecrypt',
      value: function parseDecrypt(refm, ret) {
        ret.encrypt = {};
        var refs = refm.split(',');
        for (var i in refs) {
          var cmd = refs[i];
          if (cmd.match(/METHOD=(.*)/)) {
            ret.encrypt.method = cmd.match(/METHOD=(.*)/)[1];
          }
          if (cmd.match(/URI="(.*)"/)) {
            ret.encrypt.uri = cmd.match(/URI="(.*)"/)[1];
          }

          if (cmd.match(/IV=0x(.*)/)) {
            var iv = cmd.match(/IV=0x(.*)/)[1];
            var length = Math.ceil(iv.length / 2);
            ret.encrypt.ivb = new Uint8Array(length);
            for (var _i = length - 1; _i >= 0; _i--) {
              var im = parseInt(iv.substr(_i * 2, 2), 16);
              ret.encrypt.ivb[_i] = im;
            }
            ret.encrypt.iv = iv;
          }
        }    }

      /**
       * @param {string} url
       * @return {boolean}
       */

    }, {
      key: 'isHTTPS',
      value: function isHTTPS(url) {
        var httpsUrlRegex = /^https:\/\//i;
        return httpsUrlRegex.test(url);
      }
    }]);

    return M3U8Parser;
  }();

  var defaultConfig = {
    Tracks: Track,
    XgBuffer: XgBuffer,
    FetchLoader: FetchLoader,
    Crypto: Crypto,
    M3U8Parser: M3U8Parser,
    TsDemuxer: TsDemuxer$1,
    Playlist: Playlist
  };

  var _get$1 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

  var _createClass$s = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
  // import 'xgplayer-mobilevideo'
  var HlsAllowedEvents$1 = EVENTS.HlsAllowedEvents;

  var HlsLivePlayer = function (_Player) {
    _inherits$3(HlsLivePlayer, _Player);

    _createClass$s(HlsLivePlayer, null, [{
      key: 'isSupported',
      value: function isSupported() {
        var wasmSupported = 'WebAssembly' in window;
        var WebComponentSupported = 'customElements' in window && window.customElements.define;
        var isComponentDefined = false;
        if (WebComponentSupported) {
          isComponentDefined = window.customElements.get('live-video');
        }
        return wasmSupported && isComponentDefined;
      }
    }]);

    function HlsLivePlayer(options) {
      _classCallCheck$s(this, HlsLivePlayer);

      if (!options.mediaType) {
        options.mediaType = 'live-video';
        if (options.videoConfig) {
          options.videoConfig.preloadtime = options.preloadTime || 5;
        } else {
          options.videoConfig = {
            preloadtime: options.preloadTime || 5
          };
        }
      }

      var _this = _possibleConstructorReturn$3(this, (HlsLivePlayer.__proto__ || Object.getPrototypeOf(HlsLivePlayer)).call(this, options));

      _this.hlsOps = {};
      _this.util = Player.util;
      _this.hlsOps = Object.assign(_this.hlsOps, defaultConfig);
      _this.util.deepCopy(_this.hlsOps, options);
      if (!_this.playerInited) {
        _this.initPlayer();
      }
      // this.started = false;
      return _this;
    }

    _createClass$s(HlsLivePlayer, [{
      key: 'initPlayer',
      value: function initPlayer() {
        this.video.width = Number.parseInt(this.hlsOps.width || 600);
        this.video.height = Number.parseInt(this.hlsOps.height || 337.5);
        this.video.style.outline = 'none';
        this.playerInited = true;
      }
    }, {
      key: '_initEvents',
      value: function _initEvents() {
        var _this2 = this;

        this.once('canplay', function () {
          _this2.video.play();
        });
      }
    }, {
      key: 'start',
      value: function start() {
        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hlsOps.url;

        if (!url || this.started) {
          return;
        }

        if (!this.playerInited) {
          this.initPlayer();
        }

        if (!this._context) {
          this._context = new Context(HlsAllowedEvents$1);
        }

        this.__core__ = this._context.registry('HLS_LIVE_CONTROLLER', HlsLiveController)({ player: this, container: this.video, preloadTime: this.config.preloadTime });
        this._context.init();
        this.url = url;
        this.__core__.load(url);
        _get$1(HlsLivePlayer.prototype.__proto__ || Object.getPrototypeOf(HlsLivePlayer.prototype), 'start', this).call(this, url);
        this._initEvents();
        this.started = true;
        this.addLiveFlag();
      }
    }, {
      key: 'play',
      value: function play() {
        if (this.started) {
          this._context.destroy();
          this._context = new Context(HlsAllowedEvents$1);
          this.__core__ = this._context.registry('HLS_LIVE_CONTROLLER', HlsLiveController)({ player: this, container: this.video, preloadTime: this.config.preloadTime });
          this._context.init();
          this._initEvents();
          this.__core__.load(this.url);
        }
        _get$1(HlsLivePlayer.prototype.__proto__ || Object.getPrototypeOf(HlsLivePlayer.prototype), 'play', this).call(this);
      }
    }, {
      key: 'addLiveFlag',
      value: function addLiveFlag() {
        var player = this;
        Player.util.addClass(player.root, 'xgplayer-is-live');
        if (!Player.util.findDom(this.root, 'xg-live')) {
          var live = Player.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        var isDelDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        return new Promise(function (resolve) {
          _get$1(HlsLivePlayer.prototype.__proto__ || Object.getPrototypeOf(HlsLivePlayer.prototype), 'destroy', _this3).call(_this3);
          var video = _this3.video,
              root = _this3.root;

          _get$1(HlsLivePlayer.prototype.__proto__ || Object.getPrototypeOf(HlsLivePlayer.prototype), 'destroy', _this3).call(_this3, isDelDOM);
          if (video && video.remove) {
            video.remove();
          } else if (root) {
            root.removeChild(video);
          }
          if (video) {
            video.destroy();
          }
          setTimeout(function () {
            resolve();
          }, 50);
        });
      }
    }, {
      key: 'src',
      set: function set(url) {
        this.onWaiting = this.onWaiting.bind(this);
        this._context.destroy();
        this._context = null;
        this.started = false;
        this.video.currentTime = 0;

        this.start(url);
      }
    }], [{
      key: 'install',
      value: function install(name, plugin) {
        return Player.install(name, plugin);
      }
    }]);

    return HlsLivePlayer;
  }(Player);


  HlsLivePlayer.install = Player.install.bind(Player);

  return HlsLivePlayer;

})));
//# sourceMappingURL=index.js.map
