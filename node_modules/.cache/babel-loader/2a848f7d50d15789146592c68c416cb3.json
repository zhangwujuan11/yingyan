{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nwindow.HlsJsPlayer = function (e) {\n  var t = {};\n\n  function r(a) {\n    if (t[a]) return t[a].exports;\n    var i = t[a] = {\n      i: a,\n      l: !1,\n      exports: {}\n    };\n    return e[a].call(i.exports, i, i.exports, r), i.l = !0, i.exports;\n  }\n\n  return r.m = e, r.c = t, r.d = function (e, t, a) {\n    r.o(e, t) || Object.defineProperty(e, t, {\n      enumerable: !0,\n      get: a\n    });\n  }, r.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, r.t = function (e, t) {\n    if (1 & t && (e = r(e)), 8 & t) return e;\n    if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n    var a = Object.create(null);\n    if (r.r(a), Object.defineProperty(a, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & t && \"string\" != typeof e) for (var i in e) r.d(a, i, function (t) {\n      return e[t];\n    }.bind(null, i));\n    return a;\n  }, r.n = function (e) {\n    var t = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return r.d(t, \"a\", t), t;\n  }, r.o = function (e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  }, r.p = \"\", r(r.s = 31);\n}([function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.logger = t.enableLogs = void 0;\n  var a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  },\n      i = r(5);\n\n  function n() {}\n\n  var o = {\n    trace: n,\n    debug: n,\n    log: n,\n    warn: n,\n    info: n,\n    error: n\n  },\n      s = o;\n\n  function l(e, t) {\n    return t = \"[\" + e + \"] > \" + t;\n  }\n\n  var u = (0, i.getSelfScope)();\n\n  function d(e) {\n    var t = u.console[e];\n    return t ? function () {\n      for (var r = arguments.length, a = Array(r), i = 0; i < r; i++) a[i] = arguments[i];\n\n      a[0] && (a[0] = l(e, a[0])), t.apply(u.console, a);\n    } : n;\n  }\n\n  t.enableLogs = function (e) {\n    if (!0 === e || \"object\" === (void 0 === e ? \"undefined\" : a(e))) {\n      !function (e) {\n        for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) r[a - 1] = arguments[a];\n\n        r.forEach(function (t) {\n          s[t] = e[t] ? e[t].bind(e) : d(t);\n        });\n      }(e, \"debug\", \"log\", \"info\", \"warn\", \"error\");\n\n      try {\n        s.log();\n      } catch (e) {\n        s = o;\n      }\n    } else s = o;\n  }, t.logger = s;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  t.default = {\n    MEDIA_ATTACHING: \"hlsMediaAttaching\",\n    MEDIA_ATTACHED: \"hlsMediaAttached\",\n    MEDIA_DETACHING: \"hlsMediaDetaching\",\n    MEDIA_DETACHED: \"hlsMediaDetached\",\n    BUFFER_RESET: \"hlsBufferReset\",\n    BUFFER_CODECS: \"hlsBufferCodecs\",\n    BUFFER_CREATED: \"hlsBufferCreated\",\n    BUFFER_APPENDING: \"hlsBufferAppending\",\n    BUFFER_APPENDED: \"hlsBufferAppended\",\n    BUFFER_EOS: \"hlsBufferEos\",\n    BUFFER_FLUSHING: \"hlsBufferFlushing\",\n    BUFFER_FLUSHED: \"hlsBufferFlushed\",\n    MANIFEST_LOADING: \"hlsManifestLoading\",\n    MANIFEST_LOADED: \"hlsManifestLoaded\",\n    MANIFEST_PARSED: \"hlsManifestParsed\",\n    LEVEL_SWITCHING: \"hlsLevelSwitching\",\n    LEVEL_SWITCHED: \"hlsLevelSwitched\",\n    LEVEL_LOADING: \"hlsLevelLoading\",\n    LEVEL_LOADED: \"hlsLevelLoaded\",\n    LEVEL_UPDATED: \"hlsLevelUpdated\",\n    LEVEL_PTS_UPDATED: \"hlsLevelPtsUpdated\",\n    AUDIO_TRACKS_UPDATED: \"hlsAudioTracksUpdated\",\n    AUDIO_TRACK_SWITCHING: \"hlsAudioTrackSwitching\",\n    AUDIO_TRACK_SWITCHED: \"hlsAudioTrackSwitched\",\n    AUDIO_TRACK_LOADING: \"hlsAudioTrackLoading\",\n    AUDIO_TRACK_LOADED: \"hlsAudioTrackLoaded\",\n    SUBTITLE_TRACKS_UPDATED: \"hlsSubtitleTracksUpdated\",\n    SUBTITLE_TRACK_SWITCH: \"hlsSubtitleTrackSwitch\",\n    SUBTITLE_TRACK_LOADING: \"hlsSubtitleTrackLoading\",\n    SUBTITLE_TRACK_LOADED: \"hlsSubtitleTrackLoaded\",\n    SUBTITLE_FRAG_PROCESSED: \"hlsSubtitleFragProcessed\",\n    INIT_PTS_FOUND: \"hlsInitPtsFound\",\n    FRAG_LOADING: \"hlsFragLoading\",\n    FRAG_LOAD_PROGRESS: \"hlsFragLoadProgress\",\n    FRAG_LOAD_EMERGENCY_ABORTED: \"hlsFragLoadEmergencyAborted\",\n    FRAG_LOADED: \"hlsFragLoaded\",\n    FRAG_DECRYPTED: \"hlsFragDecrypted\",\n    FRAG_PARSING_INIT_SEGMENT: \"hlsFragParsingInitSegment\",\n    FRAG_PARSING_USERDATA: \"hlsFragParsingUserdata\",\n    FRAG_PARSING_METADATA: \"hlsFragParsingMetadata\",\n    FRAG_PARSING_DATA: \"hlsFragParsingData\",\n    FRAG_PARSED: \"hlsFragParsed\",\n    FRAG_BUFFERED: \"hlsFragBuffered\",\n    FRAG_CHANGED: \"hlsFragChanged\",\n    FPS_DROP: \"hlsFpsDrop\",\n    FPS_DROP_LEVEL_CAPPING: \"hlsFpsDropLevelCapping\",\n    ERROR: \"hlsError\",\n    DESTROYING: \"hlsDestroying\",\n    KEY_LOADING: \"hlsKeyLoading\",\n    KEY_LOADED: \"hlsKeyLoaded\",\n    STREAM_STATE_TRANSITION: \"hlsStreamStateTransition\"\n  }, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  t.ErrorTypes = {\n    NETWORK_ERROR: \"networkError\",\n    MEDIA_ERROR: \"mediaError\",\n    KEY_SYSTEM_ERROR: \"keySystemError\",\n    MUX_ERROR: \"muxError\",\n    OTHER_ERROR: \"otherError\"\n  }, t.ErrorDetails = {\n    KEY_SYSTEM_NO_KEYS: \"keySystemNoKeys\",\n    KEY_SYSTEM_NO_ACCESS: \"keySystemNoAccess\",\n    KEY_SYSTEM_NO_SESSION: \"keySystemNoSession\",\n    KEY_SYSTEM_LICENSE_REQUEST_FAILED: \"keySystemLicenseRequestFailed\",\n    MANIFEST_LOAD_ERROR: \"manifestLoadError\",\n    MANIFEST_LOAD_TIMEOUT: \"manifestLoadTimeOut\",\n    MANIFEST_PARSING_ERROR: \"manifestParsingError\",\n    MANIFEST_INCOMPATIBLE_CODECS_ERROR: \"manifestIncompatibleCodecsError\",\n    LEVEL_LOAD_ERROR: \"levelLoadError\",\n    LEVEL_LOAD_TIMEOUT: \"levelLoadTimeOut\",\n    LEVEL_SWITCH_ERROR: \"levelSwitchError\",\n    AUDIO_TRACK_LOAD_ERROR: \"audioTrackLoadError\",\n    AUDIO_TRACK_LOAD_TIMEOUT: \"audioTrackLoadTimeOut\",\n    FRAG_LOAD_ERROR: \"fragLoadError\",\n    FRAG_LOAD_TIMEOUT: \"fragLoadTimeOut\",\n    FRAG_DECRYPT_ERROR: \"fragDecryptError\",\n    FRAG_PARSING_ERROR: \"fragParsingError\",\n    REMUX_ALLOC_ERROR: \"remuxAllocError\",\n    KEY_LOAD_ERROR: \"keyLoadError\",\n    KEY_LOAD_TIMEOUT: \"keyLoadTimeOut\",\n    BUFFER_ADD_CODEC_ERROR: \"bufferAddCodecError\",\n    BUFFER_APPEND_ERROR: \"bufferAppendError\",\n    BUFFER_APPENDING_ERROR: \"bufferAppendingError\",\n    BUFFER_STALLED_ERROR: \"bufferStalledError\",\n    BUFFER_FULL_ERROR: \"bufferFullError\",\n    BUFFER_SEEK_OVER_HOLE: \"bufferSeekOverHole\",\n    BUFFER_NUDGE_ON_STALL: \"bufferNudgeOnStall\",\n    INTERNAL_EXCEPTION: \"internalException\"\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  },\n      n = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      o = r(0),\n      s = r(2),\n      l = r(1),\n      u = (a = l) && a.__esModule ? a : {\n    default: a\n  };\n\n  function d(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var f = {\n    hlsEventGeneric: !0,\n    hlsHandlerDestroying: !0,\n    hlsHandlerDestroyed: !0\n  },\n      c = function () {\n    function e(t) {\n      d(this, e), this.hls = t, this.onEvent = this.onEvent.bind(this);\n\n      for (var r = arguments.length, a = Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) a[i - 1] = arguments[i];\n\n      this.handledEvents = a, this.useGenericHandler = !0, this.registerListeners();\n    }\n\n    return n(e, [{\n      key: \"destroy\",\n      value: function () {\n        this.onHandlerDestroying(), this.unregisterListeners(), this.onHandlerDestroyed();\n      }\n    }, {\n      key: \"onHandlerDestroying\",\n      value: function () {}\n    }, {\n      key: \"onHandlerDestroyed\",\n      value: function () {}\n    }, {\n      key: \"isEventHandler\",\n      value: function () {\n        return \"object\" === i(this.handledEvents) && this.handledEvents.length && \"function\" == typeof this.onEvent;\n      }\n    }, {\n      key: \"registerListeners\",\n      value: function () {\n        this.isEventHandler() && this.handledEvents.forEach(function (e) {\n          if (f[e]) throw new Error(\"Forbidden event-name: \" + e);\n          this.hls.on(e, this.onEvent);\n        }, this);\n      }\n    }, {\n      key: \"unregisterListeners\",\n      value: function () {\n        this.isEventHandler() && this.handledEvents.forEach(function (e) {\n          this.hls.off(e, this.onEvent);\n        }, this);\n      }\n    }, {\n      key: \"onEvent\",\n      value: function (e, t) {\n        this.onEventGeneric(e, t);\n      }\n    }, {\n      key: \"onEventGeneric\",\n      value: function (e, t) {\n        try {\n          (function (e, t) {\n            var r = \"on\" + e.replace(\"hls\", \"\");\n            if (\"function\" != typeof this[r]) throw new Error(\"Event \" + e + \" has no generic handler in this \" + this.constructor.name + \" class (tried \" + r + \")\");\n            return this[r].bind(this, t);\n          }).call(this, e, t).call();\n        } catch (t) {\n          o.logger.error(\"An internal error happened while handling event \" + e + '. Error message: \"' + t.message + '\". Here is a stacktrace:', t), this.hls.trigger(u.default.ERROR, {\n            type: s.ErrorTypes.OTHER_ERROR,\n            details: s.ErrorDetails.INTERNAL_EXCEPTION,\n            fatal: !1,\n            event: e,\n            err: t\n          });\n        }\n      }\n    }]), e;\n  }();\n\n  t.default = c, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  t.BufferHelper = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n    }\n\n    return a(e, null, [{\n      key: \"isBuffered\",\n      value: function (e, t) {\n        try {\n          if (e) for (var r = e.buffered, a = 0; a < r.length; a++) if (t >= r.start(a) && t <= r.end(a)) return !0;\n        } catch (e) {}\n\n        return !1;\n      }\n    }, {\n      key: \"bufferInfo\",\n      value: function (e, t, r) {\n        try {\n          if (e) {\n            var a = e.buffered,\n                i = [],\n                n = void 0;\n\n            for (n = 0; n < a.length; n++) i.push({\n              start: a.start(n),\n              end: a.end(n)\n            });\n\n            return this.bufferedInfo(i, t, r);\n          }\n        } catch (e) {}\n\n        return {\n          len: 0,\n          start: t,\n          end: t,\n          nextStart: void 0\n        };\n      }\n    }, {\n      key: \"bufferedInfo\",\n      value: function (e, t, r) {\n        var a = [],\n            i = void 0,\n            n = void 0,\n            o = void 0,\n            s = void 0,\n            l = void 0;\n\n        for (e.sort(function (e, t) {\n          var r = e.start - t.start;\n          return r || t.end - e.end;\n        }), l = 0; l < e.length; l++) {\n          var u = a.length;\n\n          if (u) {\n            var d = a[u - 1].end;\n            e[l].start - d < r ? e[l].end > d && (a[u - 1].end = e[l].end) : a.push(e[l]);\n          } else a.push(e[l]);\n        }\n\n        for (l = 0, i = 0, n = o = t; l < a.length; l++) {\n          var f = a[l].start,\n              c = a[l].end;\n          if (t + r >= f && t < c) n = f, i = (o = c) - t;else if (t + r < f) {\n            s = f;\n            break;\n          }\n        }\n\n        return {\n          len: i,\n          start: n,\n          end: o,\n          nextStart: s\n        };\n      }\n    }]), e;\n  }();\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.getSelfScope = function () {\n    return \"undefined\" == typeof window ? self : window;\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.FragmentTracker = t.FragmentState = void 0;\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = o(r(3)),\n      n = o(r(1));\n\n  function o(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var s = t.FragmentState = {\n    NOT_LOADED: \"NOT_LOADED\",\n    APPENDING: \"APPENDING\",\n    PARTIAL: \"PARTIAL\",\n    OK: \"OK\"\n  };\n\n  t.FragmentTracker = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n.default.BUFFER_APPENDED, n.default.FRAG_BUFFERED, n.default.FRAG_LOADED));\n\n      return r.bufferPadding = .2, r.fragments = Object.create(null), r.timeRanges = Object.create(null), r.config = e.config, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.config = null, i.default.prototype.destroy.call(this), function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"destroy\", this).call(this);\n      }\n    }, {\n      key: \"getBufferedFrag\",\n      value: function (e, t) {\n        var r = this.fragments,\n            a = Object.keys(r).filter(function (a) {\n          var i = r[a];\n          if (i.body.type !== t) return !1;\n          if (!i.buffered) return !1;\n          var n = i.body;\n          return n.startPTS <= e && e <= n.endPTS;\n        });\n        if (0 === a.length) return null;\n        var i = a.pop();\n        return r[i].body;\n      }\n    }, {\n      key: \"detectEvictedFragments\",\n      value: function (e, t) {\n        var r = this,\n            a = void 0,\n            i = void 0;\n        Object.keys(this.fragments).forEach(function (n) {\n          var o = r.fragments[n];\n\n          if (!0 === o.buffered) {\n            var s = o.range[e];\n\n            if (s) {\n              a = s.time;\n\n              for (var l = 0; l < a.length; l++) if (i = a[l], !1 === r.isTimeBuffered(i.startPTS, i.endPTS, t)) {\n                r.removeFragment(o.body);\n                break;\n              }\n            }\n          }\n        });\n      }\n    }, {\n      key: \"detectPartialFragments\",\n      value: function (e) {\n        var t = this,\n            r = this.getFragmentKey(e),\n            a = this.fragments[r];\n        a && (a.buffered = !0, Object.keys(this.timeRanges).forEach(function (r) {\n          if (e.hasElementaryStream(r)) {\n            var i = t.timeRanges[r];\n            a.range[r] = t.getBufferedTimes(e.startPTS, e.endPTS, i);\n          }\n        }));\n      }\n    }, {\n      key: \"getBufferedTimes\",\n      value: function (e, t, r) {\n        for (var a = [], i = void 0, n = void 0, o = !1, s = 0; s < r.length; s++) {\n          if (i = r.start(s) - this.bufferPadding, n = r.end(s) + this.bufferPadding, e >= i && t <= n) {\n            a.push({\n              startPTS: Math.max(e, r.start(s)),\n              endPTS: Math.min(t, r.end(s))\n            });\n            break;\n          }\n\n          if (e < n && t > i) a.push({\n            startPTS: Math.max(e, r.start(s)),\n            endPTS: Math.min(t, r.end(s))\n          }), o = !0;else if (t <= i) break;\n        }\n\n        return {\n          time: a,\n          partial: o\n        };\n      }\n    }, {\n      key: \"getFragmentKey\",\n      value: function (e) {\n        return e.type + \"_\" + e.level + \"_\" + e.urlId + \"_\" + e.sn;\n      }\n    }, {\n      key: \"getPartialFragment\",\n      value: function (e) {\n        var t = this,\n            r = void 0,\n            a = void 0,\n            i = void 0,\n            n = null,\n            o = 0;\n        return Object.keys(this.fragments).forEach(function (s) {\n          var l = t.fragments[s];\n          t.isPartial(l) && (a = l.body.startPTS - t.bufferPadding, i = l.body.endPTS + t.bufferPadding, e >= a && e <= i && (r = Math.min(e - a, i - e), o <= r && (n = l.body, o = r)));\n        }), n;\n      }\n    }, {\n      key: \"getState\",\n      value: function (e) {\n        var t = this.getFragmentKey(e),\n            r = this.fragments[t],\n            a = s.NOT_LOADED;\n        return void 0 !== r && (a = r.buffered ? !0 === this.isPartial(r) ? s.PARTIAL : s.OK : s.APPENDING), a;\n      }\n    }, {\n      key: \"isPartial\",\n      value: function (e) {\n        return !0 === e.buffered && (void 0 !== e.range.video && !0 === e.range.video.partial || void 0 !== e.range.audio && !0 === e.range.audio.partial);\n      }\n    }, {\n      key: \"isTimeBuffered\",\n      value: function (e, t, r) {\n        for (var a = void 0, i = void 0, n = 0; n < r.length; n++) {\n          if (a = r.start(n) - this.bufferPadding, i = r.end(n) + this.bufferPadding, e >= a && t <= i) return !0;\n          if (t <= a) return !1;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = e.frag;\n        Number.isFinite(t.sn) && !t.bitrateTest && (this.fragments[this.getFragmentKey(t)] = {\n          body: t,\n          range: Object.create(null),\n          buffered: !1\n        });\n      }\n    }, {\n      key: \"onBufferAppended\",\n      value: function (e) {\n        var t = this;\n        this.timeRanges = e.timeRanges, Object.keys(this.timeRanges).forEach(function (e) {\n          var r = t.timeRanges[e];\n          t.detectEvictedFragments(e, r);\n        });\n      }\n    }, {\n      key: \"onFragBuffered\",\n      value: function (e) {\n        this.detectPartialFragments(e.frag);\n      }\n    }, {\n      key: \"hasFragment\",\n      value: function (e) {\n        var t = this.getFragmentKey(e);\n        return void 0 !== this.fragments[t];\n      }\n    }, {\n      key: \"removeFragment\",\n      value: function (e) {\n        var t = this.getFragmentKey(e);\n        delete this.fragments[t];\n      }\n    }, {\n      key: \"removeAllFragments\",\n      value: function () {\n        this.fragments = Object.create(null);\n      }\n    }]), t;\n  }(i.default);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.addGroupId = function (e, t, r) {\n    switch (t) {\n      case \"audio\":\n        e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(r);\n        break;\n\n      case \"text\":\n        e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(r);\n    }\n  }, t.updatePTS = i, t.updateFragPTSDTS = n, t.mergeDetails = function (e, t) {\n    t.initSegment && e.initSegment && (t.initSegment = e.initSegment);\n    var r = 0,\n        i = void 0;\n    if (o(e, t, function (e, a) {\n      r = e.cc - a.cc, Number.isFinite(e.startPTS) && (a.start = a.startPTS = e.startPTS, a.endPTS = e.endPTS, a.duration = e.duration, a.backtracked = e.backtracked, a.dropped = e.dropped, i = a), t.PTSKnown = !0;\n    }), !t.PTSKnown) return;\n\n    if (r) {\n      a.logger.log(\"discontinuity sliding from playlist, take drift into account\");\n\n      for (var l = t.fragments, u = 0; u < l.length; u++) l[u].cc += r;\n    }\n\n    i ? n(t, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : s(e, t);\n    t.PTSKnown = e.PTSKnown;\n  }, t.mergeSubtitlePlaylists = function (e, t) {\n    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,\n        a = -1;\n    o(e, t, function (e, t, r) {\n      t.start = e.start, a = r;\n    });\n    var i = t.fragments;\n    if (a < 0) return void i.forEach(function (e) {\n      e.start += r;\n    });\n\n    for (var n = a + 1; n < i.length; n++) i[n].start = i[n - 1].start + i[n - 1].duration;\n  }, t.mapFragmentIntersection = o, t.adjustSliding = s, t.computeReloadInterval = function (e, t, r) {\n    var a = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration),\n        i = a / 2;\n    e && t.endSN === e.endSN && (a = i);\n    r && (a = Math.max(i, a - (window.performance.now() - r)));\n    return Math.round(a);\n  };\n  var a = r(0);\n\n  function i(e, t, r) {\n    var i = e[t],\n        n = e[r],\n        o = n.startPTS;\n    Number.isFinite(o) ? r > t ? (i.duration = o - i.start, i.duration < 0 && a.logger.warn(\"negative duration computed for frag \" + i.sn + \",level \" + i.level + \", there should be some duration drift between playlist and fragment!\")) : (n.duration = i.start - o, n.duration < 0 && a.logger.warn(\"negative duration computed for frag \" + n.sn + \",level \" + n.level + \", there should be some duration drift between playlist and fragment!\")) : n.start = r > t ? i.start + i.duration : Math.max(i.start - n.duration, 0);\n  }\n\n  function n(e, t, r, a, n, o) {\n    var s = r;\n\n    if (Number.isFinite(t.startPTS)) {\n      var l = Math.abs(t.startPTS - r);\n      Number.isFinite(t.deltaPTS) ? t.deltaPTS = Math.max(l, t.deltaPTS) : t.deltaPTS = l, s = Math.max(r, t.startPTS), r = Math.min(r, t.startPTS), a = Math.max(a, t.endPTS), n = Math.min(n, t.startDTS), o = Math.max(o, t.endDTS);\n    }\n\n    var u = r - t.start;\n    t.start = t.startPTS = r, t.maxStartPTS = s, t.endPTS = a, t.startDTS = n, t.endDTS = o, t.duration = a - r;\n    var d = t.sn;\n    if (!e || d < e.startSN || d > e.endSN) return 0;\n    var f,\n        c = void 0,\n        h = void 0;\n\n    for (f = d - e.startSN, (c = e.fragments)[f] = t, h = f; h > 0; h--) i(c, h, h - 1);\n\n    for (h = f; h < c.length - 1; h++) i(c, h, h + 1);\n\n    return e.PTSKnown = !0, u;\n  }\n\n  function o(e, t, r) {\n    if (e && t) for (var a = Math.max(e.startSN, t.startSN) - t.startSN, i = Math.min(e.endSN, t.endSN) - t.startSN, n = t.startSN - e.startSN, o = a; o <= i; o++) {\n      var s = e.fragments[n + o],\n          l = t.fragments[o];\n      if (!s || !l) break;\n      r(s, l, o);\n    }\n  }\n\n  function s(e, t) {\n    var r = t.startSN - e.startSN,\n        a = e.fragments,\n        i = t.fragments;\n    if (!(r < 0 || r > a.length)) for (var n = 0; n < i.length; n++) i[n].start += a[r].start;\n  }\n}, function (e, t, r) {\n  var a, i, n, o, s;\n  a = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/\\?#]*\\/)*.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/, i = /^([^\\/?#]*)(.*)$/, n = /(?:\\/|^)\\.(?=\\/)/g, o = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g, s = {\n    buildAbsoluteURL: function (e, t, r) {\n      if (r = r || {}, e = e.trim(), !(t = t.trim())) {\n        if (!r.alwaysNormalize) return e;\n        var a = s.parseURL(e);\n        if (!a) throw new Error(\"Error trying to parse base URL.\");\n        return a.path = s.normalizePath(a.path), s.buildURLFromParts(a);\n      }\n\n      var n = s.parseURL(t);\n      if (!n) throw new Error(\"Error trying to parse relative URL.\");\n      if (n.scheme) return r.alwaysNormalize ? (n.path = s.normalizePath(n.path), s.buildURLFromParts(n)) : t;\n      var o = s.parseURL(e);\n      if (!o) throw new Error(\"Error trying to parse base URL.\");\n\n      if (!o.netLoc && o.path && \"/\" !== o.path[0]) {\n        var l = i.exec(o.path);\n        o.netLoc = l[1], o.path = l[2];\n      }\n\n      o.netLoc && !o.path && (o.path = \"/\");\n      var u = {\n        scheme: o.scheme,\n        netLoc: n.netLoc,\n        path: null,\n        params: n.params,\n        query: n.query,\n        fragment: n.fragment\n      };\n      if (!n.netLoc && (u.netLoc = o.netLoc, \"/\" !== n.path[0])) if (n.path) {\n        var d = o.path,\n            f = d.substring(0, d.lastIndexOf(\"/\") + 1) + n.path;\n        u.path = s.normalizePath(f);\n      } else u.path = o.path, n.params || (u.params = o.params, n.query || (u.query = o.query));\n      return null === u.path && (u.path = r.alwaysNormalize ? s.normalizePath(n.path) : n.path), s.buildURLFromParts(u);\n    },\n    parseURL: function (e) {\n      var t = a.exec(e);\n      return t ? {\n        scheme: t[1] || \"\",\n        netLoc: t[2] || \"\",\n        path: t[3] || \"\",\n        params: t[4] || \"\",\n        query: t[5] || \"\",\n        fragment: t[6] || \"\"\n      } : null;\n    },\n    normalizePath: function (e) {\n      for (e = e.split(\"\").reverse().join(\"\").replace(n, \"\"); e.length !== (e = e.replace(o, \"\")).length;);\n\n      return e.split(\"\").reverse().join(\"\");\n    },\n    buildURLFromParts: function (e) {\n      return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment;\n    }\n  }, e.exports = s;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  t.default = {\n    search: function (e, t) {\n      for (var r = 0, a = e.length - 1, i = null, n = null; r <= a;) {\n        var o = t(n = e[i = (r + a) / 2 | 0]);\n        if (o > 0) r = i + 1;else {\n          if (!(o < 0)) return n;\n          a = i - 1;\n        }\n      }\n\n      return null;\n    }\n  }, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n    }\n\n    return a(e, null, [{\n      key: \"isHeader\",\n      value: function (e, t) {\n        return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128;\n      }\n    }, {\n      key: \"isFooter\",\n      value: function (e, t) {\n        return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128;\n      }\n    }, {\n      key: \"getID3Data\",\n      value: function (t, r) {\n        for (var a = r, i = 0; e.isHeader(t, r);) {\n          i += 10, i += e._readSize(t, r + 6), e.isFooter(t, r + 10) && (i += 10), r += i;\n        }\n\n        if (i > 0) return t.subarray(a, a + i);\n      }\n    }, {\n      key: \"_readSize\",\n      value: function (e, t) {\n        var r = 0;\n        return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3];\n      }\n    }, {\n      key: \"getTimeStamp\",\n      value: function (t) {\n        for (var r = e.getID3Frames(t), a = 0; a < r.length; a++) {\n          var i = r[a];\n          if (e.isTimeStampFrame(i)) return e._readTimeStamp(i);\n        }\n      }\n    }, {\n      key: \"isTimeStampFrame\",\n      value: function (e) {\n        return e && \"PRIV\" === e.key && \"com.apple.streaming.transportStreamTimestamp\" === e.info;\n      }\n    }, {\n      key: \"_getFrameData\",\n      value: function (t) {\n        var r = String.fromCharCode(t[0], t[1], t[2], t[3]),\n            a = e._readSize(t, 4);\n\n        return {\n          type: r,\n          size: a,\n          data: t.subarray(10, 10 + a)\n        };\n      }\n    }, {\n      key: \"getID3Frames\",\n      value: function (t) {\n        for (var r = 0, a = []; e.isHeader(t, r);) {\n          for (var i = e._readSize(t, r + 6), n = (r += 10) + i; r + 8 < n;) {\n            var o = e._getFrameData(t.subarray(r)),\n                s = e._decodeFrame(o);\n\n            s && a.push(s), r += o.size + 10;\n          }\n\n          e.isFooter(t, r) && (r += 10);\n        }\n\n        return a;\n      }\n    }, {\n      key: \"_decodeFrame\",\n      value: function (t) {\n        return \"PRIV\" === t.type ? e._decodePrivFrame(t) : \"T\" === t.type[0] ? e._decodeTextFrame(t) : \"W\" === t.type[0] ? e._decodeURLFrame(t) : void 0;\n      }\n    }, {\n      key: \"_readTimeStamp\",\n      value: function (e) {\n        if (8 === e.data.byteLength) {\n          var t = new Uint8Array(e.data),\n              r = 1 & t[3],\n              a = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];\n          return a /= 45, r && (a += 47721858.84), Math.round(a);\n        }\n      }\n    }, {\n      key: \"_decodePrivFrame\",\n      value: function (t) {\n        if (!(t.size < 2)) {\n          var r = e._utf8ArrayToStr(t.data, !0),\n              a = new Uint8Array(t.data.subarray(r.length + 1));\n\n          return {\n            key: t.type,\n            info: r,\n            data: a.buffer\n          };\n        }\n      }\n    }, {\n      key: \"_decodeTextFrame\",\n      value: function (t) {\n        if (!(t.size < 2)) {\n          if (\"TXXX\" === t.type) {\n            var r = 1,\n                a = e._utf8ArrayToStr(t.data.subarray(r));\n\n            r += a.length + 1;\n\n            var i = e._utf8ArrayToStr(t.data.subarray(r));\n\n            return {\n              key: t.type,\n              info: a,\n              data: i\n            };\n          }\n\n          var n = e._utf8ArrayToStr(t.data.subarray(1));\n\n          return {\n            key: t.type,\n            data: n\n          };\n        }\n      }\n    }, {\n      key: \"_decodeURLFrame\",\n      value: function (t) {\n        if (\"WXXX\" === t.type) {\n          if (t.size < 2) return;\n\n          var r = 1,\n              a = e._utf8ArrayToStr(t.data.subarray(r));\n\n          r += a.length + 1;\n\n          var i = e._utf8ArrayToStr(t.data.subarray(r));\n\n          return {\n            key: t.type,\n            info: a,\n            data: i\n          };\n        }\n\n        var n = e._utf8ArrayToStr(t.data);\n\n        return {\n          key: t.type,\n          data: n\n        };\n      }\n    }, {\n      key: \"_utf8ArrayToStr\",\n      value: function (e) {\n        for (var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = e.length, a = void 0, i = void 0, n = void 0, o = \"\", s = 0; s < r;) {\n          if (0 === (a = e[s++]) && t) return o;\n          if (0 !== a && 3 !== a) switch (a >> 4) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n              o += String.fromCharCode(a);\n              break;\n\n            case 12:\n            case 13:\n              i = e[s++], o += String.fromCharCode((31 & a) << 6 | 63 & i);\n              break;\n\n            case 14:\n              i = e[s++], n = e[s++], o += String.fromCharCode((15 & a) << 12 | (63 & i) << 6 | (63 & n) << 0);\n          }\n        }\n\n        return o;\n      }\n    }]), e;\n  }(),\n      n = i._utf8ArrayToStr;\n\n  t.default = i, t.utf8ArrayToStr = n;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(8)),\n      o = r(17),\n      s = (a = o) && a.__esModule ? a : {\n    default: a\n  };\n\n  function l(e, t, r) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = r, e;\n  }\n\n  var u = function () {\n    function e() {\n      var t;\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this._url = null, this._byteRange = null, this._decryptdata = null, this.tagList = [], this.programDateTime = null, this.rawProgramDateTime = null, this._elementaryStreams = (l(t = {}, e.ElementaryStreamTypes.AUDIO, !1), l(t, e.ElementaryStreamTypes.VIDEO, !1), t);\n    }\n\n    return i(e, [{\n      key: \"addElementaryStream\",\n      value: function (e) {\n        this._elementaryStreams[e] = !0;\n      }\n    }, {\n      key: \"hasElementaryStream\",\n      value: function (e) {\n        return !0 === this._elementaryStreams[e];\n      }\n    }, {\n      key: \"createInitializationVector\",\n      value: function (e) {\n        for (var t = new Uint8Array(16), r = 12; r < 16; r++) t[r] = e >> 8 * (15 - r) & 255;\n\n        return t;\n      }\n    }, {\n      key: \"fragmentDecryptdataFromLevelkey\",\n      value: function (e, t) {\n        var r = e;\n        return e && e.method && e.uri && !e.iv && ((r = new s.default()).method = e.method, r.baseuri = e.baseuri, r.reluri = e.reluri, r.iv = this.createInitializationVector(t)), r;\n      }\n    }, {\n      key: \"url\",\n      get: function () {\n        return !this._url && this.relurl && (this._url = n.buildAbsoluteURL(this.baseurl, this.relurl, {\n          alwaysNormalize: !0\n        })), this._url;\n      },\n      set: function (e) {\n        this._url = e;\n      }\n    }, {\n      key: \"byteRange\",\n      get: function () {\n        if (!this._byteRange && !this.rawByteRange) return [];\n        if (this._byteRange) return this._byteRange;\n        var e = [];\n\n        if (this.rawByteRange) {\n          var t = this.rawByteRange.split(\"@\", 2);\n\n          if (1 === t.length) {\n            var r = this.lastByteRangeEndOffset;\n            e[0] = r || 0;\n          } else e[0] = parseInt(t[1]);\n\n          e[1] = parseInt(t[0]) + e[0], this._byteRange = e;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"byteRangeStartOffset\",\n      get: function () {\n        return this.byteRange[0];\n      }\n    }, {\n      key: \"byteRangeEndOffset\",\n      get: function () {\n        return this.byteRange[1];\n      }\n    }, {\n      key: \"decryptdata\",\n      get: function () {\n        return this._decryptdata || (this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn)), this._decryptdata;\n      }\n    }, {\n      key: \"endProgramDateTime\",\n      get: function () {\n        if (!Number.isFinite(this.programDateTime)) return null;\n        var e = Number.isFinite(this.duration) ? this.duration : 0;\n        return this.programDateTime + 1e3 * e;\n      }\n    }, {\n      key: \"encrypted\",\n      get: function () {\n        return !(!this.decryptdata || null === this.decryptdata.uri || null !== this.decryptdata.key);\n      }\n    }], [{\n      key: \"ElementaryStreamTypes\",\n      get: function () {\n        return {\n          AUDIO: \"audio\",\n          VIDEO: \"video\"\n        };\n      }\n    }]), e;\n  }();\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = d(r(42)),\n      n = d(r(43)),\n      o = d(r(44)),\n      s = r(2),\n      l = r(0),\n      u = d(r(1));\n\n  function d(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  function f(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var c = (0, r(5).getSelfScope)(),\n      h = function () {\n    function e(t, r) {\n      var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n          i = a.removePKCS7Padding,\n          n = void 0 === i || i;\n      if (f(this, e), this.logEnabled = !0, this.observer = t, this.config = r, this.removePKCS7Padding = n, n) try {\n        var o = c.crypto;\n        o && (this.subtle = o.subtle || o.webkitSubtle);\n      } catch (e) {}\n      this.disableWebCrypto = !this.subtle;\n    }\n\n    return a(e, [{\n      key: \"isSync\",\n      value: function () {\n        return this.disableWebCrypto && this.config.enableSoftwareAES;\n      }\n    }, {\n      key: \"decrypt\",\n      value: function (e, t, r, a) {\n        var s = this;\n\n        if (this.disableWebCrypto && this.config.enableSoftwareAES) {\n          this.logEnabled && (l.logger.log(\"JS AES decrypt\"), this.logEnabled = !1);\n          var u = this.decryptor;\n          u || (this.decryptor = u = new o.default()), u.expandKey(t), a(u.decrypt(e, 0, r, this.removePKCS7Padding));\n        } else {\n          this.logEnabled && (l.logger.log(\"WebCrypto AES decrypt\"), this.logEnabled = !1);\n          var d = this.subtle;\n          this.key !== t && (this.key = t, this.fastAesKey = new n.default(d, t)), this.fastAesKey.expandKey().then(function (n) {\n            new i.default(d, r).decrypt(e, n).catch(function (i) {\n              s.onWebCryptoError(i, e, t, r, a);\n            }).then(function (e) {\n              a(e);\n            });\n          }).catch(function (i) {\n            s.onWebCryptoError(i, e, t, r, a);\n          });\n        }\n      }\n    }, {\n      key: \"onWebCryptoError\",\n      value: function (e, t, r, a, i) {\n        this.config.enableSoftwareAES ? (l.logger.log(\"WebCrypto Error, disable WebCrypto API\"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(t, r, a, i)) : (l.logger.error(\"decrypting error : \" + e.message), this.observer.trigger(u.default.ERROR, {\n          type: s.ErrorTypes.MEDIA_ERROR,\n          details: s.ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: !0,\n          reason: e.message\n        }));\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        var e = this.decryptor;\n        e && (e.destroy(), this.decryptor = void 0);\n      }\n    }]), e;\n  }();\n\n  t.default = h, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.getMediaSource = function () {\n    if (\"undefined\" != typeof window) return window.MediaSource || window.WebKitMediaSource;\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.State = void 0;\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(28),\n      o = (a = n) && a.__esModule ? a : {\n    default: a\n  },\n      s = r(6),\n      l = r(4),\n      u = r(0);\n\n  function d(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function f(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  var c = t.State = {\n    STOPPED: \"STOPPED\",\n    STARTING: \"STARTING\",\n    IDLE: \"IDLE\",\n    PAUSED: \"PAUSED\",\n    KEY_LOADING: \"KEY_LOADING\",\n    FRAG_LOADING: \"FRAG_LOADING\",\n    FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n    WAITING_TRACK: \"WAITING_TRACK\",\n    PARSING: \"PARSING\",\n    PARSED: \"PARSED\",\n    BUFFER_FLUSHING: \"BUFFER_FLUSHING\",\n    ENDED: \"ENDED\",\n    ERROR: \"ERROR\",\n    WAITING_INIT_PTS: \"WAITING_INIT_PTS\",\n    WAITING_LEVEL: \"WAITING_LEVEL\"\n  },\n      h = function (e) {\n    function t() {\n      return d(this, t), f(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), i(t, [{\n      key: \"doTick\",\n      value: function () {}\n    }, {\n      key: \"startLoad\",\n      value: function () {}\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        var e = this.fragCurrent;\n        e && (e.loader && e.loader.abort(), this.fragmentTracker.removeFragment(e)), this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = c.STOPPED;\n      }\n    }, {\n      key: \"_streamEnded\",\n      value: function (e, t) {\n        var r = this.fragCurrent,\n            a = this.fragmentTracker;\n\n        if (!t.live && r && !r.backtracked && r.sn === t.endSN && !e.nextStart) {\n          var i = a.getState(r);\n          return i === s.FragmentState.PARTIAL || i === s.FragmentState.OK;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"onMediaSeeking\",\n      value: function () {\n        var e = this.config,\n            t = this.media,\n            r = this.mediaBuffer,\n            a = this.state,\n            i = t ? t.currentTime : null,\n            n = l.BufferHelper.bufferInfo(r || t, i, this.config.maxBufferHole);\n\n        if (Number.isFinite(i) && u.logger.log(\"media seeking to \" + i.toFixed(3)), a === c.FRAG_LOADING) {\n          var o = this.fragCurrent;\n\n          if (0 === n.len && o) {\n            var s = e.maxFragLookUpTolerance,\n                d = o.start - s,\n                f = o.start + o.duration + s;\n            i < d || i > f ? (o.loader && (u.logger.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\"), o.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = c.IDLE) : u.logger.log(\"seeking outside of buffer but within currently loaded fragment range\");\n          }\n        } else a === c.ENDED && (0 === n.len && (this.fragPrevious = null, this.fragCurrent = null), this.state = c.IDLE);\n\n        t && (this.lastCurrentTime = i), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = i), this.tick();\n      }\n    }, {\n      key: \"onMediaEnded\",\n      value: function () {\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n    }, {\n      key: \"onHandlerDestroying\",\n      value: function () {\n        this.stopLoad(), function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"onHandlerDestroying\", this).call(this);\n      }\n    }, {\n      key: \"onHandlerDestroyed\",\n      value: function () {\n        this.state = c.STOPPED, this.fragmentTracker = null;\n      }\n    }]), t;\n  }(o.default);\n\n  t.default = h;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = d(r(1)),\n      n = d(r(3)),\n      o = r(2),\n      s = r(0),\n      l = d(r(16)),\n      u = d(r(35));\n\n  function d(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var f = window.performance,\n      c = {\n    MANIFEST: \"manifest\",\n    LEVEL: \"level\",\n    AUDIO_TRACK: \"audioTrack\",\n    SUBTITLE_TRACK: \"subtitleTrack\"\n  },\n      h = {\n    MAIN: \"main\",\n    AUDIO: \"audio\",\n    SUBTITLE: \"subtitle\"\n  },\n      v = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MANIFEST_LOADING, i.default.LEVEL_LOADING, i.default.AUDIO_TRACK_LOADING, i.default.SUBTITLE_TRACK_LOADING));\n\n      return r.loaders = {}, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"createInternalLoader\",\n      value: function (e) {\n        var t = this.hls.config,\n            r = t.pLoader,\n            a = t.loader,\n            i = new (r || a)(t);\n        return e.loader = i, this.loaders[e.type] = i, i;\n      }\n    }, {\n      key: \"getInternalLoader\",\n      value: function (e) {\n        return this.loaders[e.type];\n      }\n    }, {\n      key: \"resetInternalLoader\",\n      value: function (e) {\n        this.loaders[e] && delete this.loaders[e];\n      }\n    }, {\n      key: \"destroyInternalLoaders\",\n      value: function () {\n        for (var e in this.loaders) {\n          var t = this.loaders[e];\n          t && t.destroy(), this.resetInternalLoader(e);\n        }\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        this.destroyInternalLoaders(), function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"destroy\", this).call(this);\n      }\n    }, {\n      key: \"onManifestLoading\",\n      value: function (e) {\n        this.load(e.url, {\n          type: c.MANIFEST,\n          level: 0,\n          id: null\n        });\n      }\n    }, {\n      key: \"onLevelLoading\",\n      value: function (e) {\n        this.load(e.url, {\n          type: c.LEVEL,\n          level: e.level,\n          id: e.id\n        });\n      }\n    }, {\n      key: \"onAudioTrackLoading\",\n      value: function (e) {\n        this.load(e.url, {\n          type: c.AUDIO_TRACK,\n          level: null,\n          id: e.id\n        });\n      }\n    }, {\n      key: \"onSubtitleTrackLoading\",\n      value: function (e) {\n        this.load(e.url, {\n          type: c.SUBTITLE_TRACK,\n          level: null,\n          id: e.id\n        });\n      }\n    }, {\n      key: \"load\",\n      value: function (e, t) {\n        var r = this.hls.config;\n        s.logger.debug(\"Loading playlist of type \" + t.type + \", level: \" + t.level + \", id: \" + t.id);\n        var a = this.getInternalLoader(t);\n\n        if (a) {\n          var i = a.context;\n          if (i && i.url === e) return s.logger.trace(\"playlist request ongoing\"), !1;\n          s.logger.warn(\"aborting previous loader for type: \" + t.type), a.abort();\n        }\n\n        var n = void 0,\n            o = void 0,\n            l = void 0,\n            u = void 0;\n\n        switch (t.type) {\n          case c.MANIFEST:\n            n = r.manifestLoadingMaxRetry, o = r.manifestLoadingTimeOut, l = r.manifestLoadingRetryDelay, u = r.manifestLoadingMaxRetryTimeout;\n            break;\n\n          case c.LEVEL:\n            n = 0, o = r.levelLoadingTimeOut;\n            break;\n\n          default:\n            n = r.levelLoadingMaxRetry, o = r.levelLoadingTimeOut, l = r.levelLoadingRetryDelay, u = r.levelLoadingMaxRetryTimeout;\n        }\n\n        a = this.createInternalLoader(t), t.url = e, t.responseType = t.responseType || \"\";\n        var d = {\n          timeout: o,\n          maxRetry: n,\n          retryDelay: l,\n          maxRetryDelay: u\n        },\n            f = {\n          onSuccess: this.loadsuccess.bind(this),\n          onError: this.loaderror.bind(this),\n          onTimeout: this.loadtimeout.bind(this)\n        };\n        return s.logger.debug(\"Calling internal loader delegate for URL: \" + e), a.load(t, d, f), !0;\n      }\n    }, {\n      key: \"loadsuccess\",\n      value: function (e, t, r) {\n        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;\n        if (r.isSidxRequest) return this._handleSidxRequest(e, r), void this._handlePlaylistLoaded(e, t, r, a);\n        this.resetInternalLoader(r.type);\n        var i = e.data;\n        t.tload = f.now(), 0 === i.indexOf(\"#EXTM3U\") ? i.indexOf(\"#EXTINF:\") > 0 || i.indexOf(\"#EXT-X-TARGETDURATION:\") > 0 ? this._handleTrackOrLevelPlaylist(e, t, r, a) : this._handleMasterPlaylist(e, t, r, a) : this._handleManifestParsingError(e, r, \"no EXTM3U delimiter\", a);\n      }\n    }, {\n      key: \"loaderror\",\n      value: function (e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;\n\n        this._handleNetworkError(t, r, !1, e);\n      }\n    }, {\n      key: \"loadtimeout\",\n      value: function (e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;\n\n        this._handleNetworkError(t, r, !0);\n      }\n    }, {\n      key: \"_handleMasterPlaylist\",\n      value: function (e, r, a, n) {\n        var o = this.hls,\n            l = e.data,\n            d = t.getResponseUrl(e, a),\n            f = u.default.parseMasterPlaylist(l, d);\n\n        if (f.length) {\n          var c = f.map(function (e) {\n            return {\n              id: e.attrs.AUDIO,\n              codec: e.audioCodec\n            };\n          }),\n              h = u.default.parseMasterPlaylistMedia(l, d, \"AUDIO\", c),\n              v = u.default.parseMasterPlaylistMedia(l, d, \"SUBTITLES\");\n\n          if (h.length) {\n            var g = !1;\n            h.forEach(function (e) {\n              e.url || (g = !0);\n            }), !1 === g && f[0].audioCodec && !f[0].attrs.AUDIO && (s.logger.log(\"audio codec signaled in quality level, but no embedded audio track signaled, create one\"), h.unshift({\n              type: \"main\",\n              name: \"main\"\n            }));\n          }\n\n          o.trigger(i.default.MANIFEST_LOADED, {\n            levels: f,\n            audioTracks: h,\n            subtitles: v,\n            url: d,\n            stats: r,\n            networkDetails: n\n          });\n        } else this._handleManifestParsingError(e, a, \"no level found in manifest\", n);\n      }\n    }, {\n      key: \"_handleTrackOrLevelPlaylist\",\n      value: function (e, r, a, n) {\n        var o = this.hls,\n            s = a.id,\n            l = a.level,\n            d = a.type,\n            h = t.getResponseUrl(e, a),\n            v = Number.isFinite(s) ? s : 0,\n            g = Number.isFinite(l) ? l : v,\n            p = t.mapContextToLevelType(a),\n            y = u.default.parseLevelPlaylist(e.data, h, g, p, v);\n\n        if (y.tload = r.tload, d === c.MANIFEST) {\n          var m = {\n            url: h,\n            details: y\n          };\n          o.trigger(i.default.MANIFEST_LOADED, {\n            levels: [m],\n            audioTracks: [],\n            url: h,\n            stats: r,\n            networkDetails: n\n          });\n        }\n\n        if (r.tparsed = f.now(), y.needSidxRanges) {\n          var b = y.initSegment.url;\n          this.load(b, {\n            isSidxRequest: !0,\n            type: d,\n            level: l,\n            levelDetails: y,\n            id: s,\n            rangeStart: 0,\n            rangeEnd: 2048,\n            responseType: \"arraybuffer\"\n          });\n        } else a.levelDetails = y, this._handlePlaylistLoaded(e, r, a, n);\n      }\n    }, {\n      key: \"_handleSidxRequest\",\n      value: function (e, t) {\n        var r = l.default.parseSegmentIndex(new Uint8Array(e.data));\n\n        if (r) {\n          var a = r.references,\n              i = t.levelDetails;\n          a.forEach(function (e, t) {\n            var r = e.info,\n                a = i.fragments[t];\n            0 === a.byteRange.length && (a.rawByteRange = String(1 + r.end - r.start) + \"@\" + String(r.start));\n          }), i.initSegment.rawByteRange = String(r.moovEndOffset) + \"@0\";\n        }\n      }\n    }, {\n      key: \"_handleManifestParsingError\",\n      value: function (e, t, r, a) {\n        this.hls.trigger(i.default.ERROR, {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: o.ErrorDetails.MANIFEST_PARSING_ERROR,\n          fatal: !0,\n          url: e.url,\n          reason: r,\n          networkDetails: a\n        });\n      }\n    }, {\n      key: \"_handleNetworkError\",\n      value: function (e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;\n        s.logger.info(\"A network error occured while loading a \" + e.type + \"-type playlist\");\n        var n = void 0,\n            l = void 0,\n            u = this.getInternalLoader(e);\n\n        switch (e.type) {\n          case c.MANIFEST:\n            n = r ? o.ErrorDetails.MANIFEST_LOAD_TIMEOUT : o.ErrorDetails.MANIFEST_LOAD_ERROR, l = !0;\n            break;\n\n          case c.LEVEL:\n            n = r ? o.ErrorDetails.LEVEL_LOAD_TIMEOUT : o.ErrorDetails.LEVEL_LOAD_ERROR, l = !1;\n            break;\n\n          case c.AUDIO_TRACK:\n            n = r ? o.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : o.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, l = !1;\n            break;\n\n          default:\n            l = !1;\n        }\n\n        u && (u.abort(), this.resetInternalLoader(e.type));\n        var d = {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: n,\n          fatal: l,\n          url: u.url,\n          loader: u,\n          context: e,\n          networkDetails: t\n        };\n        a && (d.response = a), this.hls.trigger(i.default.ERROR, d);\n      }\n    }, {\n      key: \"_handlePlaylistLoaded\",\n      value: function (e, r, a, n) {\n        var o = a.type,\n            s = a.level,\n            l = a.id,\n            u = a.levelDetails;\n        if (u.targetduration) {\n          if (t.canHaveQualityLevels(a.type)) this.hls.trigger(i.default.LEVEL_LOADED, {\n            details: u,\n            level: s || 0,\n            id: l || 0,\n            stats: r,\n            networkDetails: n\n          });else switch (o) {\n            case c.AUDIO_TRACK:\n              this.hls.trigger(i.default.AUDIO_TRACK_LOADED, {\n                details: u,\n                id: l,\n                stats: r,\n                networkDetails: n\n              });\n              break;\n\n            case c.SUBTITLE_TRACK:\n              this.hls.trigger(i.default.SUBTITLE_TRACK_LOADED, {\n                details: u,\n                id: l,\n                stats: r,\n                networkDetails: n\n              });\n          }\n        } else this._handleManifestParsingError(e, a, \"invalid target duration\", n);\n      }\n    }], [{\n      key: \"canHaveQualityLevels\",\n      value: function (e) {\n        return e !== c.AUDIO_TRACK && e !== c.SUBTITLE_TRACK;\n      }\n    }, {\n      key: \"mapContextToLevelType\",\n      value: function (e) {\n        switch (e.type) {\n          case c.AUDIO_TRACK:\n            return h.AUDIO;\n\n          case c.SUBTITLE_TRACK:\n            return h.SUBTITLE;\n\n          default:\n            return h.MAIN;\n        }\n      }\n    }, {\n      key: \"getResponseUrl\",\n      value: function (e, t) {\n        var r = e.url;\n        return void 0 !== r && 0 !== r.indexOf(\"data:\") || (r = t.url), r;\n      }\n    }, {\n      key: \"ContextType\",\n      get: function () {\n        return c;\n      }\n    }, {\n      key: \"LevelType\",\n      get: function () {\n        return h;\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = v, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(0),\n      o = r(1),\n      s = (a = o) && a.__esModule ? a : {\n    default: a\n  };\n\n  var l = Math.pow(2, 32) - 1,\n      u = function () {\n    function e(t, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.remuxer = r;\n    }\n\n    return i(e, [{\n      key: \"resetTimeStamp\",\n      value: function (e) {\n        this.initPTS = e;\n      }\n    }, {\n      key: \"resetInitSegment\",\n      value: function (t, r, a, i) {\n        if (t && t.byteLength) {\n          var n = this.initData = e.parseInitSegment(t);\n          null == r && (r = \"mp4a.40.5\"), null == a && (a = \"avc1.42e01e\");\n          var o = {};\n          n.audio && n.video ? o.audiovideo = {\n            container: \"video/mp4\",\n            codec: r + \",\" + a,\n            initSegment: i ? t : null\n          } : (n.audio && (o.audio = {\n            container: \"audio/mp4\",\n            codec: r,\n            initSegment: i ? t : null\n          }), n.video && (o.video = {\n            container: \"video/mp4\",\n            codec: a,\n            initSegment: i ? t : null\n          })), this.observer.trigger(s.default.FRAG_PARSING_INIT_SEGMENT, {\n            tracks: o\n          });\n        } else r && (this.audioCodec = r), a && (this.videoCodec = a);\n      }\n    }, {\n      key: \"append\",\n      value: function (t, r, a, i) {\n        var n = this.initData;\n        n || (this.resetInitSegment(t, this.audioCodec, this.videoCodec, !1), n = this.initData);\n        var o,\n            l = this.initPTS;\n\n        if (void 0 === l) {\n          var u = e.getStartDTS(n, t);\n          this.initPTS = l = u - r, this.observer.trigger(s.default.INIT_PTS_FOUND, {\n            initPTS: l\n          });\n        }\n\n        e.offsetStartDTS(n, t, l), o = e.getStartDTS(n, t), this.remuxer.remux(n.audio, n.video, null, null, o, a, i, t);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {}\n    }], [{\n      key: \"probe\",\n      value: function (t) {\n        return e.findBox({\n          data: t,\n          start: 0,\n          end: Math.min(t.length, 16384)\n        }, [\"moof\"]).length > 0;\n      }\n    }, {\n      key: \"bin2str\",\n      value: function (e) {\n        return String.fromCharCode.apply(null, e);\n      }\n    }, {\n      key: \"readUint16\",\n      value: function (e, t) {\n        e.data && (t += e.start, e = e.data);\n        var r = e[t] << 8 | e[t + 1];\n        return r < 0 ? 65536 + r : r;\n      }\n    }, {\n      key: \"readUint32\",\n      value: function (e, t) {\n        e.data && (t += e.start, e = e.data);\n        var r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];\n        return r < 0 ? 4294967296 + r : r;\n      }\n    }, {\n      key: \"writeUint32\",\n      value: function (e, t, r) {\n        e.data && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r;\n      }\n    }, {\n      key: \"findBox\",\n      value: function (t, r) {\n        var a = [],\n            i = void 0,\n            n = void 0,\n            o = void 0,\n            s = void 0,\n            l = void 0,\n            u = void 0;\n        if (t.data ? (l = t.start, o = t.end, t = t.data) : (l = 0, o = t.byteLength), !r.length) return null;\n\n        for (i = l; i < o;) u = (n = e.readUint32(t, i)) > 1 ? i + n : o, e.bin2str(t.subarray(i + 4, i + 8)) === r[0] && (1 === r.length ? a.push({\n          data: t,\n          start: i + 8,\n          end: u\n        }) : (s = e.findBox({\n          data: t,\n          start: i + 8,\n          end: u\n        }, r.slice(1))).length && (a = a.concat(s))), i = u;\n\n        return a;\n      }\n    }, {\n      key: \"parseSegmentIndex\",\n      value: function (t) {\n        var r = e.findBox(t, [\"moov\"])[0],\n            a = r ? r.end : null,\n            i = 0,\n            n = e.findBox(t, [\"sidx\"]),\n            o = void 0;\n        if (!n || !n[0]) return null;\n        o = [];\n        var s = (n = n[0]).data[0];\n        i = 0 === s ? 8 : 16;\n        var l = e.readUint32(n, i);\n        i += 4;\n        i += 0 === s ? 8 : 16, i += 2;\n        var u = n.end + 0,\n            d = e.readUint16(n, i);\n        i += 2;\n\n        for (var f = 0; f < d; f++) {\n          var c = i,\n              h = e.readUint32(n, c);\n          c += 4;\n          var v = 2147483647 & h;\n          if (1 === (2147483648 & h) >>> 31) return void console.warn(\"SIDX has hierarchical references (not supported)\");\n          var g = e.readUint32(n, c);\n          c += 4, o.push({\n            referenceSize: v,\n            subsegmentDuration: g,\n            info: {\n              duration: g / l,\n              start: u,\n              end: u + v - 1\n            }\n          }), u += v, i = c += 4;\n        }\n\n        return {\n          earliestPresentationTime: 0,\n          timescale: l,\n          version: s,\n          referencesCount: d,\n          references: o,\n          moovEndOffset: a\n        };\n      }\n    }, {\n      key: \"parseInitSegment\",\n      value: function (t) {\n        var r = [];\n        return e.findBox(t, [\"moov\", \"trak\"]).forEach(function (t) {\n          var a = e.findBox(t, [\"tkhd\"])[0];\n\n          if (a) {\n            var i = a.data[a.start],\n                o = 0 === i ? 12 : 20,\n                s = e.readUint32(a, o),\n                l = e.findBox(t, [\"mdia\", \"mdhd\"])[0];\n\n            if (l) {\n              o = 0 === (i = l.data[l.start]) ? 12 : 20;\n              var u = e.readUint32(l, o),\n                  d = e.findBox(t, [\"mdia\", \"hdlr\"])[0];\n\n              if (d) {\n                var f = {\n                  soun: \"audio\",\n                  vide: \"video\"\n                }[e.bin2str(d.data.subarray(d.start + 8, d.start + 12))];\n\n                if (f) {\n                  var c = e.findBox(t, [\"mdia\", \"minf\", \"stbl\", \"stsd\"]);\n\n                  if (c.length) {\n                    c = c[0];\n                    var h = e.bin2str(c.data.subarray(c.start + 12, c.start + 16));\n                    n.logger.log(\"MP4Demuxer:\" + f + \":\" + h + \" found\");\n                  }\n\n                  r[s] = {\n                    timescale: u,\n                    type: f\n                  }, r[f] = {\n                    timescale: u,\n                    id: s\n                  };\n                }\n              }\n            }\n          }\n        }), r;\n      }\n    }, {\n      key: \"getStartDTS\",\n      value: function (t, r) {\n        var a,\n            i,\n            n = void 0;\n        return n = e.findBox(r, [\"moof\", \"traf\"]), a = [].concat.apply([], n.map(function (r) {\n          return e.findBox(r, [\"tfhd\"]).map(function (a) {\n            var i, n;\n            return i = e.readUint32(a, 4), n = t[i].timescale || 9e4, e.findBox(r, [\"tfdt\"]).map(function (t) {\n              var r,\n                  a = void 0;\n              return r = t.data[t.start], a = e.readUint32(t, 4), 1 === r && (a *= Math.pow(2, 32), a += e.readUint32(t, 8)), a;\n            })[0] / n;\n          });\n        })), i = Math.min.apply(null, a), isFinite(i) ? i : 0;\n      }\n    }, {\n      key: \"offsetStartDTS\",\n      value: function (t, r, a) {\n        e.findBox(r, [\"moof\", \"traf\"]).map(function (r) {\n          return e.findBox(r, [\"tfhd\"]).map(function (i) {\n            var n = e.readUint32(i, 4),\n                o = t[n].timescale || 9e4;\n            e.findBox(r, [\"tfdt\"]).map(function (t) {\n              var r = t.data[t.start],\n                  i = e.readUint32(t, 4);\n              if (0 === r) e.writeUint32(t, 4, i - a * o);else {\n                i *= Math.pow(2, 32), i += e.readUint32(t, 8), i -= a * o, i = Math.max(i, 0);\n                var n = Math.floor(i / (l + 1)),\n                    s = Math.floor(i % (l + 1));\n                e.writeUint32(t, 4, n), e.writeUint32(t, 8, s);\n              }\n            });\n          });\n        });\n      }\n    }]), e;\n  }();\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(8));\n\n  var n = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.method = null, this.key = null, this.iv = null, this._uri = null;\n    }\n\n    return a(e, [{\n      key: \"uri\",\n      get: function () {\n        return !this._uri && this.reluri && (this._uri = i.buildAbsoluteURL(this.baseuri, this.reluri, {\n          alwaysNormalize: !0\n        })), this._uri;\n      }\n    }]), e;\n  }();\n\n  t.default = n, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = {\n    audio: {\n      a3ds: !0,\n      \"ac-3\": !0,\n      \"ac-4\": !0,\n      alac: !0,\n      alaw: !0,\n      dra1: !0,\n      \"dts+\": !0,\n      \"dts-\": !0,\n      dtsc: !0,\n      dtse: !0,\n      dtsh: !0,\n      \"ec-3\": !0,\n      enca: !0,\n      g719: !0,\n      g726: !0,\n      m4ae: !0,\n      mha1: !0,\n      mha2: !0,\n      mhm1: !0,\n      mhm2: !0,\n      mlpa: !0,\n      mp4a: !0,\n      \"raw \": !0,\n      Opus: !0,\n      samr: !0,\n      sawb: !0,\n      sawp: !0,\n      sevc: !0,\n      sqcp: !0,\n      ssmv: !0,\n      twos: !0,\n      ulaw: !0\n    },\n    video: {\n      avc1: !0,\n      avc2: !0,\n      avc3: !0,\n      avc4: !0,\n      avcp: !0,\n      drac: !0,\n      dvav: !0,\n      dvhe: !0,\n      encv: !0,\n      hev1: !0,\n      hvc1: !0,\n      mjp2: !0,\n      mp4v: !0,\n      mvc1: !0,\n      mvc2: !0,\n      mvc3: !0,\n      mvc4: !0,\n      resv: !0,\n      rv60: !0,\n      s263: !0,\n      svc1: !0,\n      svc2: !0,\n      \"vc-1\": !0,\n      vp08: !0,\n      vp09: !0\n    }\n  };\n  t.isCodecType = function (e, t) {\n    var r = a[t];\n    return !!r && !0 === r[e.slice(0, 4)];\n  }, t.isCodecSupportedInMp4 = function (e, t) {\n    return window.MediaSource.isTypeSupported((t || \"video\") + '/mp4;codecs=\"' + e + '\"');\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = (r(20), function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(41))),\n      n = c(r(1)),\n      o = c(r(21)),\n      s = r(0),\n      l = r(2),\n      u = r(13),\n      d = r(5),\n      f = r(24);\n\n  function c(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var h = (0, d.getSelfScope)(),\n      v = (0, u.getMediaSource)(),\n      g = function () {\n    function e(t, r) {\n      var a = this;\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.hls = t, this.id = r;\n\n      var u = this.observer = new f.Observer(),\n          d = t.config,\n          c = function (e, r) {\n        (r = r || {}).frag = a.frag, r.id = a.id, t.trigger(e, r);\n      };\n\n      u.on(n.default.FRAG_DECRYPTED, c), u.on(n.default.FRAG_PARSING_INIT_SEGMENT, c), u.on(n.default.FRAG_PARSING_DATA, c), u.on(n.default.FRAG_PARSED, c), u.on(n.default.ERROR, c), u.on(n.default.FRAG_PARSING_METADATA, c), u.on(n.default.FRAG_PARSING_USERDATA, c), u.on(n.default.INIT_PTS_FOUND, c);\n      var g = {\n        mp4: v.isTypeSupported(\"video/mp4\"),\n        mpeg: v.isTypeSupported(\"audio/mpeg\"),\n        mp3: v.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n      },\n          p = navigator.vendor;\n\n      if (d.enableWorker && \"undefined\" != typeof Worker) {\n        s.logger.log(\"demuxing in webworker\");\n        var y = void 0;\n\n        try {\n          y = this.w = i(55), this.onwmsg = this.onWorkerMessage.bind(this), y.addEventListener(\"message\", this.onwmsg), y.onerror = function (e) {\n            t.trigger(n.default.ERROR, {\n              type: l.ErrorTypes.OTHER_ERROR,\n              details: l.ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: !0,\n              event: \"demuxerWorker\",\n              err: {\n                message: e.message + \" (\" + e.filename + \":\" + e.lineno + \")\"\n              }\n            });\n          }, y.postMessage({\n            cmd: \"init\",\n            typeSupported: g,\n            vendor: p,\n            id: r,\n            config: JSON.stringify(d)\n          });\n        } catch (e) {\n          s.logger.warn(\"Error in worker:\", e), s.logger.error(\"Error while initializing DemuxerWorker, fallback on DemuxerInline\"), y && h.URL.revokeObjectURL(y.objectURL), this.demuxer = new o.default(u, g, d, p), this.w = void 0;\n        }\n      } else this.demuxer = new o.default(u, g, d, p);\n    }\n\n    return a(e, [{\n      key: \"destroy\",\n      value: function () {\n        var e = this.w;\n        if (e) e.removeEventListener(\"message\", this.onwmsg), e.terminate(), this.w = null;else {\n          var t = this.demuxer;\n          t && (t.destroy(), this.demuxer = null);\n        }\n        var r = this.observer;\n        r && (r.removeAllListeners(), this.observer = null);\n      }\n    }, {\n      key: \"push\",\n      value: function (e, t, r, a, i, n, o, l) {\n        var u = this.w,\n            d = Number.isFinite(i.startPTS) ? i.startPTS : i.start,\n            f = i.decryptdata,\n            c = this.frag,\n            h = !(c && i.cc === c.cc),\n            v = !(c && i.level === c.level),\n            g = c && i.sn === c.sn + 1,\n            p = !v && g;\n        if (h && s.logger.log(this.id + \":discontinuity detected\"), v && s.logger.log(this.id + \":switch detected\"), this.frag = i, u) u.postMessage({\n          cmd: \"demux\",\n          data: e,\n          decryptdata: f,\n          initSegment: t,\n          audioCodec: r,\n          videoCodec: a,\n          timeOffset: d,\n          discontinuity: h,\n          trackSwitch: v,\n          contiguous: p,\n          duration: n,\n          accurateTimeOffset: o,\n          defaultInitPTS: l\n        }, e instanceof ArrayBuffer ? [e] : []);else {\n          var y = this.demuxer;\n          y && y.push(e, f, t, r, a, d, h, v, p, n, o, l);\n        }\n      }\n    }, {\n      key: \"onWorkerMessage\",\n      value: function (e) {\n        var t = e.data,\n            r = this.hls;\n\n        switch (t.event) {\n          case \"init\":\n            h.URL.revokeObjectURL(this.w.objectURL);\n            break;\n\n          case n.default.FRAG_PARSING_DATA:\n            t.data.data1 = new Uint8Array(t.data1), t.data2 && (t.data.data2 = new Uint8Array(t.data2));\n\n          default:\n            t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data);\n        }\n      }\n    }]), e;\n  }();\n\n  t.default = g, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  var a,\n      i = \"object\" == typeof Reflect ? Reflect : null,\n      n = i && \"function\" == typeof i.apply ? i.apply : function (e, t, r) {\n    return Function.prototype.apply.call(e, t, r);\n  };\n  a = i && \"function\" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function (e) {\n    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n  } : function (e) {\n    return Object.getOwnPropertyNames(e);\n  };\n\n  var o = Number.isNaN || function (e) {\n    return e != e;\n  };\n\n  function s() {\n    s.init.call(this);\n  }\n\n  e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;\n  var l = 10;\n\n  function u(e) {\n    if (\"function\" != typeof e) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof e);\n  }\n\n  function d(e) {\n    return void 0 === e._maxListeners ? s.defaultMaxListeners : e._maxListeners;\n  }\n\n  function f(e, t, r, a) {\n    var i, n, o, s;\n    if (u(r), void 0 === (n = e._events) ? (n = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== n.newListener && (e.emit(\"newListener\", t, r.listener ? r.listener : r), n = e._events), o = n[t]), void 0 === o) o = n[t] = r, ++e._eventsCount;else if (\"function\" == typeof o ? o = n[t] = a ? [r, o] : [o, r] : a ? o.unshift(r) : o.push(r), (i = d(e)) > 0 && o.length > i && !o.warned) {\n      o.warned = !0;\n      var l = new Error(\"Possible EventEmitter memory leak detected. \" + o.length + \" \" + String(t) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      l.name = \"MaxListenersExceededWarning\", l.emitter = e, l.type = t, l.count = o.length, s = l, console && console.warn && console.warn(s);\n    }\n    return e;\n  }\n\n  function c() {\n    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n  }\n\n  function h(e, t, r) {\n    var a = {\n      fired: !1,\n      wrapFn: void 0,\n      target: e,\n      type: t,\n      listener: r\n    },\n        i = c.bind(a);\n    return i.listener = r, a.wrapFn = i, i;\n  }\n\n  function v(e, t, r) {\n    var a = e._events;\n    if (void 0 === a) return [];\n    var i = a[t];\n    return void 0 === i ? [] : \"function\" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) {\n      for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];\n\n      return t;\n    }(i) : p(i, i.length);\n  }\n\n  function g(e) {\n    var t = this._events;\n\n    if (void 0 !== t) {\n      var r = t[e];\n      if (\"function\" == typeof r) return 1;\n      if (void 0 !== r) return r.length;\n    }\n\n    return 0;\n  }\n\n  function p(e, t) {\n    for (var r = new Array(t), a = 0; a < t; ++a) r[a] = e[a];\n\n    return r;\n  }\n\n  Object.defineProperty(s, \"defaultMaxListeners\", {\n    enumerable: !0,\n    get: function () {\n      return l;\n    },\n    set: function (e) {\n      if (\"number\" != typeof e || e < 0 || o(e)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n      l = e;\n    }\n  }), s.init = function () {\n    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n  }, s.prototype.setMaxListeners = function (e) {\n    if (\"number\" != typeof e || e < 0 || o(e)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n    return this._maxListeners = e, this;\n  }, s.prototype.getMaxListeners = function () {\n    return d(this);\n  }, s.prototype.emit = function (e) {\n    for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);\n\n    var a = \"error\" === e,\n        i = this._events;\n    if (void 0 !== i) a = a && void 0 === i.error;else if (!a) return !1;\n\n    if (a) {\n      var o;\n      if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;\n      var s = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n      throw s.context = o, s;\n    }\n\n    var l = i[e];\n    if (void 0 === l) return !1;\n    if (\"function\" == typeof l) n(l, this, t);else {\n      var u = l.length,\n          d = p(l, u);\n\n      for (r = 0; r < u; ++r) n(d[r], this, t);\n    }\n    return !0;\n  }, s.prototype.addListener = function (e, t) {\n    return f(this, e, t, !1);\n  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function (e, t) {\n    return f(this, e, t, !0);\n  }, s.prototype.once = function (e, t) {\n    return u(t), this.on(e, h(this, e, t)), this;\n  }, s.prototype.prependOnceListener = function (e, t) {\n    return u(t), this.prependListener(e, h(this, e, t)), this;\n  }, s.prototype.removeListener = function (e, t) {\n    var r, a, i, n, o;\n    if (u(t), void 0 === (a = this._events)) return this;\n    if (void 0 === (r = a[e])) return this;\n    if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete a[e], a.removeListener && this.emit(\"removeListener\", e, r.listener || t));else if (\"function\" != typeof r) {\n      for (i = -1, n = r.length - 1; n >= 0; n--) if (r[n] === t || r[n].listener === t) {\n        o = r[n].listener, i = n;\n        break;\n      }\n\n      if (i < 0) return this;\n      0 === i ? r.shift() : function (e, t) {\n        for (; t + 1 < e.length; t++) e[t] = e[t + 1];\n\n        e.pop();\n      }(r, i), 1 === r.length && (a[e] = r[0]), void 0 !== a.removeListener && this.emit(\"removeListener\", e, o || t);\n    }\n    return this;\n  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function (e) {\n    var t, r, a;\n    if (void 0 === (r = this._events)) return this;\n    if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;\n\n    if (0 === arguments.length) {\n      var i,\n          n = Object.keys(r);\n\n      for (a = 0; a < n.length; ++a) \"removeListener\" !== (i = n[a]) && this.removeAllListeners(i);\n\n      return this.removeAllListeners(\"removeListener\"), this._events = Object.create(null), this._eventsCount = 0, this;\n    }\n\n    if (\"function\" == typeof (t = r[e])) this.removeListener(e, t);else if (void 0 !== t) for (a = t.length - 1; a >= 0; a--) this.removeListener(e, t[a]);\n    return this;\n  }, s.prototype.listeners = function (e) {\n    return v(this, e, !0);\n  }, s.prototype.rawListeners = function (e) {\n    return v(this, e, !1);\n  }, s.listenerCount = function (e, t) {\n    return \"function\" == typeof e.listenerCount ? e.listenerCount(t) : g.call(e, t);\n  }, s.prototype.listenerCount = g, s.prototype.eventNames = function () {\n    return this._eventsCount > 0 ? a(this._events) : [];\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = g(r(1)),\n      n = r(2),\n      o = g(r(12)),\n      s = g(r(45)),\n      l = g(r(16)),\n      u = g(r(46)),\n      d = g(r(49)),\n      f = g(r(50)),\n      c = g(r(53)),\n      h = r(5),\n      v = r(0);\n\n  function g(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var p = (0, h.getSelfScope)(),\n      y = void 0;\n\n  try {\n    y = p.performance.now.bind(p.performance);\n  } catch (e) {\n    v.logger.debug(\"Unable to use Performance API on this environment\"), y = p.Date.now;\n  }\n\n  var m = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.typeSupported = r, this.config = a, this.vendor = i;\n    }\n\n    return a(e, [{\n      key: \"destroy\",\n      value: function () {\n        var e = this.demuxer;\n        e && e.destroy();\n      }\n    }, {\n      key: \"push\",\n      value: function (e, t, r, a, n, s, l, u, d, f, c, h) {\n        var v = this;\n\n        if (e.byteLength > 0 && null != t && null != t.key && \"AES-128\" === t.method) {\n          var g = this.decrypter;\n          null == g && (g = this.decrypter = new o.default(this.observer, this.config));\n          var p = y();\n          g.decrypt(e, t.key.buffer, t.iv.buffer, function (e) {\n            var o = y();\n            v.observer.trigger(i.default.FRAG_DECRYPTED, {\n              stats: {\n                tstart: p,\n                tdecrypt: o\n              }\n            }), v.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, n, s, l, u, d, f, c, h);\n          });\n        } else this.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, n, s, l, u, d, f, c, h);\n      }\n    }, {\n      key: \"pushDecrypted\",\n      value: function (e, t, r, a, o, h, v, g, p, y, m, b) {\n        var E = this.demuxer;\n\n        if (!E || (v || g) && !this.probe(e)) {\n          for (var _ = this.observer, T = this.typeSupported, S = this.config, k = [{\n            demux: u.default,\n            remux: f.default\n          }, {\n            demux: l.default,\n            remux: c.default\n          }, {\n            demux: s.default,\n            remux: f.default\n          }, {\n            demux: d.default,\n            remux: f.default\n          }], R = 0, A = k.length; R < A; R++) {\n            var w = k[R],\n                O = w.demux.probe;\n\n            if (O(e)) {\n              var L = this.remuxer = new w.remux(_, S, T, this.vendor);\n              E = new w.demux(_, L, S, T), this.probe = O;\n              break;\n            }\n          }\n\n          if (!E) return void _.trigger(i.default.ERROR, {\n            type: n.ErrorTypes.MEDIA_ERROR,\n            details: n.ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: !0,\n            reason: \"no demux matching with content found\"\n          });\n          this.demuxer = E;\n        }\n\n        var D = this.remuxer;\n        (v || g) && (E.resetInitSegment(r, a, o, y), D.resetInitSegment()), v && (E.resetTimeStamp(b), D.resetTimeStamp(b)), \"function\" == typeof E.setDecryptData && E.setDecryptData(t), E.append(e, h, p, m);\n      }\n    }]), e;\n  }();\n\n  t.default = m, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.getAudioConfig = l, t.isHeaderPattern = u, t.getHeaderLength = d, t.getFullFrameLength = f, t.isHeader = function (e, t) {\n    if (t + 1 < e.length && u(e, t)) return !0;\n    return !1;\n  }, t.probe = function (e, t) {\n    if (t + 1 < e.length && u(e, t)) {\n      var r = d(e, t);\n      t + 5 < e.length && (r = f(e, t));\n      var a = t + r;\n      if (a === e.length || a + 1 < e.length && u(e, a)) return !0;\n    }\n\n    return !1;\n  }, t.initTrackConfig = function (e, t, r, a, n) {\n    if (!e.samplerate) {\n      var o = l(t, r, a, n);\n      e.config = o.config, e.samplerate = o.samplerate, e.channelCount = o.channelCount, e.codec = o.codec, e.manifestCodec = o.manifestCodec, i.logger.log(\"parsed codec:\" + e.codec + \",rate:\" + o.samplerate + \",nb channel:\" + o.channelCount);\n    }\n  }, t.getFrameDuration = c, t.parseFrameHeader = h, t.appendFrame = function (e, t, r, a, i) {\n    var n = c(e.samplerate),\n        o = h(t, r, a, i, n);\n\n    if (o) {\n      var s = o.stamp,\n          l = o.headerLength,\n          u = o.frameLength,\n          d = {\n        unit: t.subarray(r + l, r + l + u),\n        pts: s,\n        dts: s\n      };\n      return e.samples.push(d), e.len += u, {\n        sample: d,\n        length: u + l\n      };\n    }\n\n    return;\n  };\n  var a,\n      i = r(0),\n      n = r(2),\n      o = r(1),\n      s = (a = o) && a.__esModule ? a : {\n    default: a\n  };\n  r(5);\n\n  function l(e, t, r, a) {\n    var o,\n        l = void 0,\n        u = void 0,\n        d = void 0,\n        f = void 0,\n        c = navigator.userAgent.toLowerCase(),\n        h = a,\n        v = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];\n    if (l = 1 + ((192 & t[r + 2]) >>> 6), !((o = (60 & t[r + 2]) >>> 2) > v.length - 1)) return d = (1 & t[r + 2]) << 2, d |= (192 & t[r + 3]) >>> 6, i.logger.log(\"manifest codec:\" + a + \",ADTS data:type:\" + l + \",sampleingIndex:\" + o + \"[\" + v[o] + \"Hz],channelConfig:\" + d), /firefox/i.test(c) ? o >= 6 ? (l = 5, f = new Array(4), u = o - 3) : (l = 2, f = new Array(2), u = o) : -1 !== c.indexOf(\"android\") ? (l = 2, f = new Array(2), u = o) : (l = 5, f = new Array(4), a && (-1 !== a.indexOf(\"mp4a.40.29\") || -1 !== a.indexOf(\"mp4a.40.5\")) || !a && o >= 6 ? u = o - 3 : ((a && -1 !== a.indexOf(\"mp4a.40.2\") && (o >= 6 && 1 === d || /vivaldi/i.test(c)) || !a && 1 === d) && (l = 2, f = new Array(2)), u = o)), f[0] = l << 3, f[0] |= (14 & o) >> 1, f[1] |= (1 & o) << 7, f[1] |= d << 3, 5 === l && (f[1] |= (14 & u) >> 1, f[2] = (1 & u) << 7, f[2] |= 8, f[3] = 0), {\n      config: f,\n      samplerate: v[o],\n      channelCount: d,\n      codec: \"mp4a.40.\" + l,\n      manifestCodec: h\n    };\n    e.trigger(s.default.ERROR, {\n      type: n.ErrorTypes.MEDIA_ERROR,\n      details: n.ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: !0,\n      reason: \"invalid ADTS sampling index:\" + o\n    });\n  }\n\n  function u(e, t) {\n    return 255 === e[t] && 240 == (246 & e[t + 1]);\n  }\n\n  function d(e, t) {\n    return 1 & e[t + 1] ? 7 : 9;\n  }\n\n  function f(e, t) {\n    return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5;\n  }\n\n  function c(e) {\n    return 9216e4 / e;\n  }\n\n  function h(e, t, r, a, i) {\n    var n,\n        o = void 0,\n        s = e.length;\n    if (n = d(e, t), o = f(e, t), (o -= n) > 0 && t + n + o <= s) return {\n      headerLength: n,\n      frameLength: o,\n      stamp: r + a * i\n    };\n  }\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = {\n    BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n    SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],\n    SamplesCoefficients: [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]],\n    BytesInSlot: [0, 1, 1, 4],\n    appendFrame: function (e, t, r, a, i) {\n      if (!(r + 24 > t.length)) {\n        var n = this.parseHeader(t, r);\n\n        if (n && r + n.frameLength <= t.length) {\n          var o = a + i * (9e4 * n.samplesPerFrame / n.sampleRate),\n              s = {\n            unit: t.subarray(r, r + n.frameLength),\n            pts: o,\n            dts: o\n          };\n          return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(s), e.len += n.frameLength, {\n            sample: s,\n            length: n.frameLength\n          };\n        }\n      }\n    },\n    parseHeader: function (e, t) {\n      var r = e[t + 1] >> 3 & 3,\n          i = e[t + 1] >> 1 & 3,\n          n = e[t + 2] >> 4 & 15,\n          o = e[t + 2] >> 2 & 3,\n          s = e[t + 2] >> 1 & 1;\n\n      if (1 !== r && 0 !== n && 15 !== n && 3 !== o) {\n        var l = 3 === r ? 3 - i : 3 === i ? 3 : 4,\n            u = 1e3 * a.BitratesMap[14 * l + n - 1],\n            d = 3 === r ? 0 : 2 === r ? 1 : 2,\n            f = a.SamplingRateMap[3 * d + o],\n            c = e[t + 3] >> 6 == 3 ? 1 : 2,\n            h = a.SamplesCoefficients[r][i],\n            v = a.BytesInSlot[i],\n            g = 8 * h * v;\n        return {\n          sampleRate: f,\n          channelCount: c,\n          frameLength: parseInt(h * u / f + s, 10) * v,\n          samplesPerFrame: g\n        };\n      }\n    },\n    isHeaderPattern: function (e, t) {\n      return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1]);\n    },\n    isHeader: function (e, t) {\n      return !!(t + 1 < e.length && this.isHeaderPattern(e, t));\n    },\n    probe: function (e, t) {\n      if (t + 1 < e.length && this.isHeaderPattern(e, t)) {\n        var r = this.parseHeader(e, t),\n            a = 4;\n        r && r.frameLength && (a = r.frameLength);\n        var i = t + a;\n        if (i === e.length || i + 1 < e.length && this.isHeaderPattern(e, i)) return !0;\n      }\n\n      return !1;\n    }\n  };\n  t.default = a, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.Observer = void 0;\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = r(54);\n\n  function n(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function o(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  t.Observer = function (e) {\n    function t() {\n      return n(this, t), o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"trigger\",\n      value: function (e) {\n        for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) r[a - 1] = arguments[a];\n\n        this.emit.apply(this, [e, e].concat(r));\n      }\n    }]), t;\n  }(i.EventEmitter);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  t.default = {\n    toString: function (e) {\n      for (var t = \"\", r = e.length, a = 0; a < r; a++) t += \"[\" + e.start(a).toFixed(3) + \",\" + e.end(a).toFixed(3) + \"]\";\n\n      return t;\n    }\n  }, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.findFirstFragWithCC = s, t.findFragWithCC = function (e, t) {\n    return n.default.search(e, function (e) {\n      return e.cc < t ? 1 : e.cc > t ? -1 : 0;\n    });\n  }, t.shouldAlignOnDiscontinuities = l, t.findDiscontinuousReferenceFrag = u, t.adjustPts = d, t.alignStream = function (e, t, r) {\n    f(e, r, t), !r.PTSKnown && t && c(r, t.details);\n  }, t.alignDiscontinuities = f, t.alignPDT = c;\n  var a,\n      i = r(9),\n      n = (a = i) && a.__esModule ? a : {\n    default: a\n  },\n      o = r(0);\n\n  function s(e, t) {\n    for (var r = null, a = 0; a < e.length; a += 1) {\n      var i = e[a];\n\n      if (i && i.cc === t) {\n        r = i;\n        break;\n      }\n    }\n\n    return r;\n  }\n\n  function l(e, t, r) {\n    var a = !1;\n    return t && t.details && r && (r.endCC > r.startCC || e && e.cc < r.startCC) && (a = !0), a;\n  }\n\n  function u(e, t) {\n    var r = e.fragments,\n        a = t.fragments;\n\n    if (a.length && r.length) {\n      var i = s(r, a[0].cc);\n      if (i && (!i || i.startPTS)) return i;\n      o.logger.log(\"No frag in previous level to align on\");\n    } else o.logger.log(\"No fragments to align\");\n  }\n\n  function d(e, t) {\n    t.fragments.forEach(function (t) {\n      if (t) {\n        var r = t.start + e;\n        t.start = t.startPTS = r, t.endPTS = r + t.duration;\n      }\n    }), t.PTSKnown = !0;\n  }\n\n  function f(e, t, r) {\n    if (l(e, r, t)) {\n      var a = u(r.details, t);\n      a && (o.logger.log(\"Adjusting PTS using last level due to CC increase within current level\"), d(a.start, t));\n    }\n  }\n\n  function c(e, t) {\n    if (t && t.fragments.length) {\n      if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;\n      var r = t.fragments[0].programDateTime,\n          a = (e.fragments[0].programDateTime - r) / 1e3 + t.fragments[0].start;\n      Number.isFinite(a) && (o.logger.log(\"adjusting PTS using programDateTime delta, sliding:\" + a.toFixed(3)), d(a, e));\n    }\n  }\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.findFragmentByPDT = function (e, t, r) {\n    if (!Array.isArray(e) || !e.length || !Number.isFinite(t)) return null;\n    if (t < e[0].programDateTime) return null;\n    if (t >= e[e.length - 1].endProgramDateTime) return null;\n    r = r || 0;\n\n    for (var a = 0; a < e.length; ++a) {\n      var i = e[a];\n      if (s(t, r, i)) return i;\n    }\n\n    return null;\n  }, t.findFragmentByPTS = function (e, t) {\n    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,\n        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,\n        i = e ? t[e.sn - t[0].sn + 1] : null;\n    if (i && !o(r, a, i)) return i;\n    return n.default.search(t, o.bind(null, r, a));\n  }, t.fragmentWithinToleranceTest = o, t.pdtWithinToleranceTest = s;\n  var a,\n      i = r(9),\n      n = (a = i) && a.__esModule ? a : {\n    default: a\n  };\n\n  function o() {\n    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n        r = arguments[2],\n        a = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n    return r.start + r.duration - a <= e ? 1 : r.start - a > e && r.start ? -1 : 0;\n  }\n\n  function s(e, t, r) {\n    var a = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n    return r.endProgramDateTime - a > e;\n  }\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(3);\n\n  function o(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function s(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  var l = function (e) {\n    function t(e) {\n      var r;\n      o(this, t);\n\n      for (var a = arguments.length, i = Array(a > 1 ? a - 1 : 0), n = 1; n < a; n++) i[n - 1] = arguments[n];\n\n      var l = s(this, (r = t.__proto__ || Object.getPrototypeOf(t)).call.apply(r, [this, e].concat(i)));\n      return l._tickInterval = null, l._tickTimer = null, l._tickCallCount = 0, l._boundTick = l.tick.bind(l), l;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), i(t, [{\n      key: \"onHandlerDestroying\",\n      value: function () {\n        this.clearNextTick(), this.clearInterval();\n      }\n    }, {\n      key: \"hasInterval\",\n      value: function () {\n        return !!this._tickInterval;\n      }\n    }, {\n      key: \"hasNextTick\",\n      value: function () {\n        return !!this._tickTimer;\n      }\n    }, {\n      key: \"setInterval\",\n      value: function (e) {\n        function t(t) {\n          return e.apply(this, arguments);\n        }\n\n        return t.toString = function () {\n          return e.toString();\n        }, t;\n      }(function (e) {\n        return !this._tickInterval && (this._tickInterval = setInterval(this._boundTick, e), !0);\n      })\n    }, {\n      key: \"clearInterval\",\n      value: function (e) {\n        function t() {\n          return e.apply(this, arguments);\n        }\n\n        return t.toString = function () {\n          return e.toString();\n        }, t;\n      }(function () {\n        return !!this._tickInterval && (clearInterval(this._tickInterval), this._tickInterval = null, !0);\n      })\n    }, {\n      key: \"clearNextTick\",\n      value: function () {\n        return !!this._tickTimer && (clearTimeout(this._tickTimer), this._tickTimer = null, !0);\n      }\n    }, {\n      key: \"tick\",\n      value: function () {\n        this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && (this.clearNextTick(), this._tickTimer = setTimeout(this._boundTick, 0)), this._tickCallCount = 0);\n      }\n    }, {\n      key: \"doTick\",\n      value: function () {}\n    }]), t;\n  }(((a = n) && a.__esModule ? a : {\n    default: a\n  }).default);\n\n  t.default = l, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.sendAddTrackEvent = function (e, t) {\n    var r = null;\n\n    try {\n      r = new window.Event(\"addtrack\");\n    } catch (e) {\n      (r = document.createEvent(\"Event\")).initEvent(\"addtrack\", !1, !1);\n    }\n\n    r.track = e, t.dispatchEvent(r);\n  }, t.clearCurrentCues = function (e) {\n    if (e && e.cues) for (; e.cues.length > 0;) e.removeCue(e.cues[0]);\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.fixLineBreaks = void 0;\n  var a,\n      i = r(71),\n      n = (a = i) && a.__esModule ? a : {\n    default: a\n  };\n\n  var o = function () {\n    return {\n      decode: function (e) {\n        if (!e) return \"\";\n        if (\"string\" != typeof e) throw new Error(\"Error - expected string data.\");\n        return decodeURIComponent(encodeURIComponent(e));\n      }\n    };\n  };\n\n  function s() {\n    this.window = window, this.state = \"INITIAL\", this.buffer = \"\", this.decoder = new o(), this.regionList = [];\n  }\n\n  function l() {\n    this.values = Object.create(null);\n  }\n\n  function u(e, t, r, a) {\n    var i = a ? e.split(a) : [e];\n\n    for (var n in i) if (\"string\" == typeof i[n]) {\n      var o = i[n].split(r);\n      if (2 === o.length) t(o[0], o[1]);\n    }\n  }\n\n  l.prototype = {\n    set: function (e, t) {\n      this.get(e) || \"\" === t || (this.values[e] = t);\n    },\n    get: function (e, t, r) {\n      return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t;\n    },\n    has: function (e) {\n      return e in this.values;\n    },\n    alt: function (e, t, r) {\n      for (var a = 0; a < r.length; ++a) if (t === r[a]) {\n        this.set(e, t);\n        break;\n      }\n    },\n    integer: function (e, t) {\n      /^-?\\d+$/.test(t) && this.set(e, parseInt(t, 10));\n    },\n    percent: function (e, t) {\n      return !!(t.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/) && (t = parseFloat(t)) >= 0 && t <= 100) && (this.set(e, t), !0);\n    }\n  };\n  var d = new n.default(0, 0, 0),\n      f = \"middle\" === d.align ? \"middle\" : \"center\";\n\n  function c(e, t, r) {\n    var a = e;\n\n    function i() {\n      var t = function (e) {\n        function t(e, t, r, a) {\n          return 3600 * (0 | e) + 60 * (0 | t) + (0 | r) + (0 | a) / 1e3;\n        }\n\n        var r = e.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n        return r ? r[3] ? t(r[1], r[2], r[3].replace(\":\", \"\"), r[4]) : r[1] > 59 ? t(r[1], r[2], 0, r[4]) : t(0, r[1], r[2], r[4]) : null;\n      }(e);\n\n      if (null === t) throw new Error(\"Malformed timestamp: \" + a);\n      return e = e.replace(/^[^\\sa-zA-Z-]+/, \"\"), t;\n    }\n\n    function n() {\n      e = e.replace(/^\\s+/, \"\");\n    }\n\n    if (n(), t.startTime = i(), n(), \"--\\x3e\" !== e.substr(0, 3)) throw new Error(\"Malformed time stamp (time stamps must be separated by '--\\x3e'): \" + a);\n    e = e.substr(3), n(), t.endTime = i(), n(), function (e, t) {\n      var a = new l();\n      u(e, function (e, t) {\n        switch (e) {\n          case \"region\":\n            for (var i = r.length - 1; i >= 0; i--) if (r[i].id === t) {\n              a.set(e, r[i].region);\n              break;\n            }\n\n            break;\n\n          case \"vertical\":\n            a.alt(e, t, [\"rl\", \"lr\"]);\n            break;\n\n          case \"line\":\n            var n = t.split(\",\"),\n                o = n[0];\n            a.integer(e, o), a.percent(e, o) && a.set(\"snapToLines\", !1), a.alt(e, o, [\"auto\"]), 2 === n.length && a.alt(\"lineAlign\", n[1], [\"start\", f, \"end\"]);\n            break;\n\n          case \"position\":\n            n = t.split(\",\"), a.percent(e, n[0]), 2 === n.length && a.alt(\"positionAlign\", n[1], [\"start\", f, \"end\", \"line-left\", \"line-right\", \"auto\"]);\n            break;\n\n          case \"size\":\n            a.percent(e, t);\n            break;\n\n          case \"align\":\n            a.alt(e, t, [\"start\", f, \"end\", \"left\", \"right\"]);\n        }\n      }, /:/, /\\s/), t.region = a.get(\"region\", null), t.vertical = a.get(\"vertical\", \"\");\n      var i = a.get(\"line\", \"auto\");\n      \"auto\" === i && -1 === d.line && (i = -1), t.line = i, t.lineAlign = a.get(\"lineAlign\", \"start\"), t.snapToLines = a.get(\"snapToLines\", !0), t.size = a.get(\"size\", 100), t.align = a.get(\"align\", f);\n      var n = a.get(\"position\", \"auto\");\n      \"auto\" === n && 50 === d.position && (n = \"start\" === t.align || \"left\" === t.align ? 0 : \"end\" === t.align || \"right\" === t.align ? 100 : 50), t.position = n;\n    }(e, t);\n  }\n\n  function h(e) {\n    return e.replace(/<br(?: \\/)?>/gi, \"\\n\");\n  }\n\n  s.prototype = {\n    parse: function (e) {\n      var t = this;\n\n      function r() {\n        var e = t.buffer,\n            r = 0;\n\n        for (e = h(e); r < e.length && \"\\r\" !== e[r] && \"\\n\" !== e[r];) ++r;\n\n        var a = e.substr(0, r);\n        return \"\\r\" === e[r] && ++r, \"\\n\" === e[r] && ++r, t.buffer = e.substr(r), a;\n      }\n\n      e && (t.buffer += t.decoder.decode(e, {\n        stream: !0\n      }));\n\n      try {\n        var a = void 0;\n\n        if (\"INITIAL\" === t.state) {\n          if (!/\\r\\n|\\n/.test(t.buffer)) return this;\n          var i = (a = r()).match(/^()?WEBVTT([ \\t].*)?$/);\n          if (!i || !i[0]) throw new Error(\"Malformed WebVTT signature.\");\n          t.state = \"HEADER\";\n        }\n\n        for (var o = !1; t.buffer;) {\n          if (!/\\r\\n|\\n/.test(t.buffer)) return this;\n\n          switch (o ? o = !1 : a = r(), t.state) {\n            case \"HEADER\":\n              /:/.test(a) ? u(a, function (e, t) {}, /:/) : a || (t.state = \"ID\");\n              continue;\n\n            case \"NOTE\":\n              a || (t.state = \"ID\");\n              continue;\n\n            case \"ID\":\n              if (/^NOTE($|[ \\t])/.test(a)) {\n                t.state = \"NOTE\";\n                break;\n              }\n\n              if (!a) continue;\n\n              if (t.cue = new n.default(0, 0, \"\"), t.state = \"CUE\", -1 === a.indexOf(\"--\\x3e\")) {\n                t.cue.id = a;\n                continue;\n              }\n\n            case \"CUE\":\n              try {\n                c(a, t.cue, t.regionList);\n              } catch (e) {\n                t.cue = null, t.state = \"BADCUE\";\n                continue;\n              }\n\n              t.state = \"CUETEXT\";\n              continue;\n\n            case \"CUETEXT\":\n              var s = -1 !== a.indexOf(\"--\\x3e\");\n\n              if (!a || s && (o = !0)) {\n                t.oncue && t.oncue(t.cue), t.cue = null, t.state = \"ID\";\n                continue;\n              }\n\n              t.cue.text && (t.cue.text += \"\\n\"), t.cue.text += a;\n              continue;\n\n            case \"BADCUE\":\n              a || (t.state = \"ID\");\n              continue;\n          }\n        }\n      } catch (e) {\n        \"CUETEXT\" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = \"INITIAL\" === t.state ? \"BADWEBVTT\" : \"BADCUE\";\n      }\n\n      return this;\n    },\n    flush: function () {\n      try {\n        if (this.buffer += this.decoder.decode(), (this.cue || \"HEADER\" === this.state) && (this.buffer += \"\\n\\n\", this.parse()), \"INITIAL\" === this.state) throw new Error(\"Malformed WebVTT signature.\");\n      } catch (e) {\n        throw e;\n      }\n\n      return this.onflush && this.onflush(), this;\n    }\n  }, t.fixLineBreaks = h, t.default = s;\n}, function (e, t, r) {\n  e.exports = r(32);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = s(r(33)),\n      n = s(r(34)),\n      o = s(r(80));\n\n  function s(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  function l(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n      var r = l(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));\n      r.hlsOpts = e.hlsOpts || {};\n      var a = i.default.util,\n          s = r;\n\n      if (s.once(\"complete\", function () {\n        if (s.config.isLive && (a.addClass(s.root, \"xgplayer-is-live\"), !a.findDom(s.controls, \".xgplayer-live\"))) {\n          var e = a.createDom(\"xg-live\", \"\", {}, \"xgplayer-live\");\n          s.controls.appendChild(e);\n        }\n      }), r.browser = o.default.getBrowserVersion(), void 0 === s.config.useHls) {\n        if (\"mobile\" === i.default.sniffer.device && \"MacIntel\" !== navigator.platform && \"Win32\" !== navigator.platform || r.browser.indexOf(\"Safari\") > -1) return l(r);\n      } else if (!s.config.useHls) return l(r);\n\n      Number.isFinite = Number.isFinite || function (e) {\n        return \"number\" == typeof e && isFinite(e);\n      };\n\n      var u = void 0;\n      return u = new n.default(r.hlsOpts), r.hls = u, Object.defineProperty(s, \"src\", {\n        get: function () {\n          return s.currentSrc;\n        },\n        set: function (e) {\n          a.removeClass(s.root, \"xgplayer-is-live\");\n          var t = document.querySelector(\".xgplayer-live\");\n          t && t.parentNode.removeChild(t);\n          var r = s.paused;\n          s.hls.stopLoad(), s.hls.detachMedia(), s.hls.destroy(), s.hls = new n.default(s.hlsOpts), s.register(e), r ? s.hls.loadSource(e) : (s.pause(), s.once(\"pause\", function () {\n            s.hls.loadSource(e);\n          }), s.once(\"canplay\", function () {\n            s.play().catch(function (e) {});\n          })), s.hls.attachMedia(s.video), s.once(\"canplay\", function () {\n            s.currentTime = 0;\n          });\n        },\n        configurable: !0\n      }), r.register(r.config.url), r.once(\"complete\", function () {\n        u.attachMedia(s.video), s.once(\"canplay\", function () {\n          s.config.autoplay && s.play().catch(function (e) {});\n        });\n      }), r.once(\"destroy\", function () {\n        u.stopLoad();\n      }), r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"register\",\n      value: function (e) {\n        var t = this.hls,\n            r = i.default.util,\n            a = this;\n        t.on(n.default.Events.MEDIA_ATTACHED, function () {\n          t.loadSource(e);\n        }), t.on(n.default.Events.LEVEL_LOADED, function (e, i) {\n          if (!t.inited && (t.inited = !0, i && i.details && i.details.live && (r.addClass(a.root, \"xgplayer-is-live\"), !r.findDom(a.root, \".xgplayer-live\")))) {\n            var n = r.createDom(\"xg-live\", \"\", {}, \"xgplayer-live\");\n            a.controls.appendChild(n);\n          }\n        }), t.on(n.default.Events.ERROR, function (e, r) {\n          if (a.emit(\"HLS_ERROR\", {\n            errorType: r.type,\n            errorDetails: r.details,\n            errorFatal: r.fatal\n          }), r.fatal) switch (r.type) {\n            case n.default.ErrorTypes.NETWORK_ERROR:\n              t.startLoad();\n              break;\n\n            case n.default.ErrorTypes.MEDIA_ERROR:\n              t.recoverMediaError();\n              break;\n\n            default:\n              a.emit(\"error\", r);\n          }\n        }), this._statistics();\n      }\n    }, {\n      key: \"_statistics\",\n      value: function () {\n        var e = {\n          speed: 0,\n          playerType: \"HlsPlayer\"\n        },\n            t = {\n          videoDataRate: 0,\n          audioDataRate: 0\n        },\n            r = this.hls,\n            a = this;\n        r.on(n.default.Events.FRAG_LOAD_PROGRESS, function (t, r) {\n          e.speed = r.stats.loaded / 1e3;\n        }), r.on(n.default.Events.FRAG_PARSING_DATA, function (e, r) {\n          \"video\" === r.type && (t.fps = parseInt(r.nb / (r.endPTS - r.startPTS)));\n        }), r.on(n.default.Events.FRAG_PARSING_INIT_SEGMENT, function (e, r) {\n          if (t.hasAudio = !(!r.tracks || !r.tracks.audio), t.hasVideo = !(!r.tracks || !r.tracks.audio), t.hasAudio) {\n            var i = r.tracks.audio;\n            t.audioChannelCount = i.metadata && i.metadata.channelCount ? i.metadata.channelCount : 0, t.audioCodec = i.codec;\n          }\n\n          if (t.hasVideo) {\n            var n = r.tracks.video;\n            t.videoCodec = n.codec, t.width = n.metadata && n.metadata.width ? n.metadata.width : 0, t.height = n.metadata && n.metadata.height ? n.metadata.height : 0;\n          }\n\n          t.duration = r.frag && r.frag.duration ? r.frag.duration : 0, t.level = r.frag && r.frag.level ? r.frag.level : 0, (t.videoCodec || t.audioCodec) && (t.mimeType = 'video/hls; codecs=\"' + t.videoCodec + \";\" + t.audioCodec + '\"'), a.mediainfo = t, a.emit(\"media_info\", t);\n        }), this._statisticsTimmer = setInterval(function () {\n          a.emit(\"statistics_info\", e), e.speed = 0;\n        }, 1e3);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        (function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        })(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"destroy\", this).call(this), clearInterval(this._statisticsTimmer);\n      }\n    }]), t;\n  }(i.default);\n\n  u.isSupported = n.default.isSupported, t.default = u, e.exports = t.default;\n}, function (e, t) {\n  e.exports = window.Player;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(8)),\n      n = r(2),\n      o = y(r(15)),\n      s = y(r(38)),\n      l = y(r(39)),\n      u = r(6),\n      d = y(r(40)),\n      f = y(r(57)),\n      c = y(r(58)),\n      h = r(59),\n      v = r(0),\n      g = r(60),\n      p = y(r(1));\n\n  function y(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  function m(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function b(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  var E = function (e) {\n    function t() {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      m(this, t);\n      var r = b(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)),\n          a = t.DefaultConfig;\n      if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n\n      for (var i in a) i in e || (e[i] = a[i]);\n\n      if (void 0 !== e.liveMaxLatencyDurationCount && e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount) throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be gt \"liveSyncDurationCount\"');\n      if (void 0 !== e.liveMaxLatencyDuration && (e.liveMaxLatencyDuration <= e.liveSyncDuration || void 0 === e.liveSyncDuration)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be gt \"liveSyncDuration\"');\n      (0, v.enableLogs)(e.debug), r.config = e, r._autoLevelCapping = -1;\n\n      var n = r.abrController = new e.abrController(r),\n          h = new e.bufferController(r),\n          g = new e.capLevelController(r),\n          p = new e.fpsController(r),\n          y = new o.default(r),\n          E = new s.default(r),\n          _ = new l.default(r),\n          T = new c.default(r),\n          S = r.levelController = new f.default(r),\n          k = new u.FragmentTracker(r),\n          R = r.streamController = new d.default(r, k),\n          A = [S, R],\n          w = e.audioStreamController;\n\n      w && A.push(new w(r, k)), r.networkControllers = A;\n      var O = [y, E, _, n, h, g, p, T, k];\n\n      if (w = e.audioTrackController) {\n        var L = new w(r);\n        r.audioTrackController = L, O.push(L);\n      }\n\n      if (w = e.subtitleTrackController) {\n        var D = new w(r);\n        r.subtitleTrackController = D, A.push(D);\n      }\n\n      if (w = e.emeController) {\n        var P = new w(r);\n        r.emeController = P, O.push(P);\n      }\n\n      return (w = e.subtitleStreamController) && A.push(new w(r, k)), (w = e.timelineController) && O.push(new w(r)), r.coreComponents = O, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, null, [{\n      key: \"isSupported\",\n      value: function () {\n        return (0, h.isSupported)();\n      }\n    }, {\n      key: \"version\",\n      get: function () {\n        return __VERSION__;\n      }\n    }, {\n      key: \"Events\",\n      get: function () {\n        return p.default;\n      }\n    }, {\n      key: \"ErrorTypes\",\n      get: function () {\n        return n.ErrorTypes;\n      }\n    }, {\n      key: \"ErrorDetails\",\n      get: function () {\n        return n.ErrorDetails;\n      }\n    }, {\n      key: \"DefaultConfig\",\n      get: function () {\n        return t.defaultConfig ? t.defaultConfig : g.hlsDefaultConfig;\n      },\n      set: function (e) {\n        t.defaultConfig = e;\n      }\n    }]), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        v.logger.log(\"destroy\"), this.trigger(p.default.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function (e) {\n          e.destroy();\n        }), this.url = null, this.removeAllListeners(), this._autoLevelCapping = -1;\n      }\n    }, {\n      key: \"attachMedia\",\n      value: function (e) {\n        v.logger.log(\"attachMedia\"), this.media = e, this.trigger(p.default.MEDIA_ATTACHING, {\n          media: e\n        });\n      }\n    }, {\n      key: \"detachMedia\",\n      value: function () {\n        v.logger.log(\"detachMedia\"), this.trigger(p.default.MEDIA_DETACHING), this.media = null;\n      }\n    }, {\n      key: \"loadSource\",\n      value: function (e) {\n        e = i.buildAbsoluteURL(window.location.href, e, {\n          alwaysNormalize: !0\n        }), v.logger.log(\"loadSource:\" + e), this.url = e, this.trigger(p.default.MANIFEST_LOADING, {\n          url: e\n        });\n      }\n    }, {\n      key: \"startLoad\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;\n        v.logger.log(\"startLoad(\" + e + \")\"), this.networkControllers.forEach(function (t) {\n          t.startLoad(e);\n        });\n      }\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        v.logger.log(\"stopLoad\"), this.networkControllers.forEach(function (e) {\n          e.stopLoad();\n        });\n      }\n    }, {\n      key: \"swapAudioCodec\",\n      value: function () {\n        v.logger.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n      }\n    }, {\n      key: \"recoverMediaError\",\n      value: function () {\n        v.logger.log(\"recoverMediaError\");\n        var e = this.media;\n        this.detachMedia(), this.attachMedia(e);\n      }\n    }, {\n      key: \"levels\",\n      get: function () {\n        return this.levelController.levels;\n      }\n    }, {\n      key: \"currentLevel\",\n      get: function () {\n        return this.streamController.currentLevel;\n      },\n      set: function (e) {\n        v.logger.log(\"set currentLevel:\" + e), this.loadLevel = e, this.streamController.immediateLevelSwitch();\n      }\n    }, {\n      key: \"nextLevel\",\n      get: function () {\n        return this.streamController.nextLevel;\n      },\n      set: function (e) {\n        v.logger.log(\"set nextLevel:\" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();\n      }\n    }, {\n      key: \"loadLevel\",\n      get: function () {\n        return this.levelController.level;\n      },\n      set: function (e) {\n        v.logger.log(\"set loadLevel:\" + e), this.levelController.manualLevel = e;\n      }\n    }, {\n      key: \"nextLoadLevel\",\n      get: function () {\n        return this.levelController.nextLoadLevel;\n      },\n      set: function (e) {\n        this.levelController.nextLoadLevel = e;\n      }\n    }, {\n      key: \"firstLevel\",\n      get: function () {\n        return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n      },\n      set: function (e) {\n        v.logger.log(\"set firstLevel:\" + e), this.levelController.firstLevel = e;\n      }\n    }, {\n      key: \"startLevel\",\n      get: function () {\n        return this.levelController.startLevel;\n      },\n      set: function (e) {\n        v.logger.log(\"set startLevel:\" + e);\n        -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;\n      }\n    }, {\n      key: \"autoLevelCapping\",\n      get: function () {\n        return this._autoLevelCapping;\n      },\n      set: function (e) {\n        v.logger.log(\"set autoLevelCapping:\" + e), this._autoLevelCapping = e;\n      }\n    }, {\n      key: \"autoLevelEnabled\",\n      get: function () {\n        return -1 === this.levelController.manualLevel;\n      }\n    }, {\n      key: \"manualLevel\",\n      get: function () {\n        return this.levelController.manualLevel;\n      }\n    }, {\n      key: \"minAutoLevel\",\n      get: function () {\n        for (var e = this.levels, t = this.config.minAutoBitrate, r = e ? e.length : 0, a = 0; a < r; a++) {\n          if ((e[a].realBitrate ? Math.max(e[a].realBitrate, e[a].bitrate) : e[a].bitrate) > t) return a;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"maxAutoLevel\",\n      get: function () {\n        var e = this.levels,\n            t = this.autoLevelCapping;\n        return -1 === t && e && e.length ? e.length - 1 : t;\n      }\n    }, {\n      key: \"nextAutoLevel\",\n      get: function () {\n        return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n      },\n      set: function (e) {\n        this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e);\n      }\n    }, {\n      key: \"audioTracks\",\n      get: function () {\n        var e = this.audioTrackController;\n        return e ? e.audioTracks : [];\n      }\n    }, {\n      key: \"audioTrack\",\n      get: function () {\n        var e = this.audioTrackController;\n        return e ? e.audioTrack : -1;\n      },\n      set: function (e) {\n        var t = this.audioTrackController;\n        t && (t.audioTrack = e);\n      }\n    }, {\n      key: \"liveSyncPosition\",\n      get: function () {\n        return this.streamController.liveSyncPosition;\n      }\n    }, {\n      key: \"subtitleTracks\",\n      get: function () {\n        var e = this.subtitleTrackController;\n        return e ? e.subtitleTracks : [];\n      }\n    }, {\n      key: \"subtitleTrack\",\n      get: function () {\n        var e = this.subtitleTrackController;\n        return e ? e.subtitleTrack : -1;\n      },\n      set: function (e) {\n        var t = this.subtitleTrackController;\n        t && (t.subtitleTrack = e);\n      }\n    }, {\n      key: \"subtitleDisplay\",\n      get: function () {\n        var e = this.subtitleTrackController;\n        return !!e && e.subtitleDisplay;\n      },\n      set: function (e) {\n        var t = this.subtitleTrackController;\n        t && (t.subtitleDisplay = e);\n      }\n    }]), t;\n  }(r(24).Observer);\n\n  t.default = E, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(8)),\n      n = f(r(11)),\n      o = f(r(36)),\n      s = f(r(17)),\n      l = f(r(37)),\n      u = r(0),\n      d = r(18);\n\n  function f(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var c = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g,\n      h = /#EXT-X-MEDIA:(.*)/g,\n      v = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, /|(?!#)([\\S+ ?]+)/.source, /|#EXT-X-BYTERANGE:*(.+)/.source, /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /|#.*/.source].join(\"\"), \"g\"),\n      g = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\\r?\\n?/,\n      p = /\\.(mp4|m4s|m4v|m4a)$/i,\n      y = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n    }\n\n    return a(e, null, [{\n      key: \"findGroup\",\n      value: function (e, t) {\n        if (!e) return null;\n\n        for (var r = null, a = 0; a < e.length; a++) {\n          var i = e[a];\n          i.id === t && (r = i);\n        }\n\n        return r;\n      }\n    }, {\n      key: \"convertAVC1ToAVCOTI\",\n      value: function (e) {\n        var t = void 0,\n            r = e.split(\".\");\n        return r.length > 2 ? (t = r.shift() + \".\", t += parseInt(r.shift()).toString(16), t += (\"000\" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t;\n      }\n    }, {\n      key: \"resolve\",\n      value: function (e, t) {\n        return i.buildAbsoluteURL(t, e, {\n          alwaysNormalize: !0\n        });\n      }\n    }, {\n      key: \"parseMasterPlaylist\",\n      value: function (t, r) {\n        var a = [],\n            i = void 0;\n\n        function n(e, t) {\n          [\"video\", \"audio\"].forEach(function (r) {\n            var a = e.filter(function (e) {\n              return (0, d.isCodecType)(e, r);\n            });\n\n            if (a.length) {\n              var i = a.filter(function (e) {\n                return 0 === e.lastIndexOf(\"avc1\", 0) || 0 === e.lastIndexOf(\"mp4a\", 0);\n              });\n              t[r + \"Codec\"] = i.length > 0 ? i[0] : a[0], e = e.filter(function (e) {\n                return -1 === a.indexOf(e);\n              });\n            }\n          }), t.unknownCodecs = e;\n        }\n\n        for (c.lastIndex = 0; null != (i = c.exec(t));) {\n          var o = {},\n              s = o.attrs = new l.default(i[1]);\n          o.url = e.resolve(i[2], r);\n          var u = s.decimalResolution(\"RESOLUTION\");\n          u && (o.width = u.width, o.height = u.height), o.bitrate = s.decimalInteger(\"AVERAGE-BANDWIDTH\") || s.decimalInteger(\"BANDWIDTH\"), o.name = s.NAME, n([].concat((s.CODECS || \"\").split(/[ ,]+/)), o), o.videoCodec && -1 !== o.videoCodec.indexOf(\"avc1\") && (o.videoCodec = e.convertAVC1ToAVCOTI(o.videoCodec)), a.push(o);\n        }\n\n        return a;\n      }\n    }, {\n      key: \"parseMasterPlaylistMedia\",\n      value: function (t, r, a) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [],\n            n = void 0,\n            o = [],\n            s = 0;\n\n        for (h.lastIndex = 0; null !== (n = h.exec(t));) {\n          var u = {},\n              d = new l.default(n[1]);\n\n          if (d.TYPE === a) {\n            if (u.groupId = d[\"GROUP-ID\"], u.name = d.NAME, u.type = a, u.default = \"YES\" === d.DEFAULT, u.autoselect = \"YES\" === d.AUTOSELECT, u.forced = \"YES\" === d.FORCED, d.URI && (u.url = e.resolve(d.URI, r)), u.lang = d.LANGUAGE, u.name || (u.name = u.lang), i.length) {\n              var f = e.findGroup(i, u.groupId);\n              u.audioCodec = f ? f.codec : i[0].codec;\n            }\n\n            u.id = s++, o.push(u);\n          }\n        }\n\n        return o;\n      }\n    }, {\n      key: \"parseLevelPlaylist\",\n      value: function (e, t, r, a, i) {\n        var d = 0,\n            f = 0,\n            c = new o.default(t),\n            h = new s.default(),\n            y = 0,\n            b = null,\n            E = new n.default(),\n            _ = void 0,\n            T = void 0,\n            S = null;\n\n        for (v.lastIndex = 0; null !== (_ = v.exec(e));) {\n          var k = _[1];\n\n          if (k) {\n            E.duration = parseFloat(k);\n\n            var R = (\" \" + _[2]).slice(1);\n\n            E.title = R || null, E.tagList.push(R ? [\"INF\", k, R] : [\"INF\", k]);\n          } else if (_[3]) {\n            if (Number.isFinite(E.duration)) {\n              var A = d++;\n              E.type = a, E.start = f, E.levelkey = h, E.sn = A, E.level = r, E.cc = y, E.urlId = i, E.baseurl = t, E.relurl = (\" \" + _[3]).slice(1), m(E, b), c.fragments.push(E), b = E, f += E.duration, E = new n.default();\n            }\n          } else if (_[4]) {\n            if (E.rawByteRange = (\" \" + _[4]).slice(1), b) {\n              var w = b.byteRangeEndOffset;\n              w && (E.lastByteRangeEndOffset = w);\n            }\n          } else if (_[5]) E.rawProgramDateTime = (\" \" + _[5]).slice(1), E.tagList.push([\"PROGRAM-DATE-TIME\", E.rawProgramDateTime]), null === S && (S = c.fragments.length);else {\n            for (_ = _[0].match(g), T = 1; T < _.length && void 0 === _[T]; T++);\n\n            var O = (\" \" + _[T + 1]).slice(1),\n                L = (\" \" + _[T + 2]).slice(1);\n\n            switch (_[T]) {\n              case \"#\":\n                E.tagList.push(L ? [O, L] : [O]);\n                break;\n\n              case \"PLAYLIST-TYPE\":\n                c.type = O.toUpperCase();\n                break;\n\n              case \"MEDIA-SEQUENCE\":\n                d = c.startSN = parseInt(O);\n                break;\n\n              case \"TARGETDURATION\":\n                c.targetduration = parseFloat(O);\n                break;\n\n              case \"VERSION\":\n                c.version = parseInt(O);\n                break;\n\n              case \"EXTM3U\":\n                break;\n\n              case \"ENDLIST\":\n                c.live = !1;\n                break;\n\n              case \"DIS\":\n                y++, E.tagList.push([\"DIS\"]);\n                break;\n\n              case \"DISCONTINUITY-SEQ\":\n                y = parseInt(O);\n                break;\n\n              case \"KEY\":\n                var D = O,\n                    P = new l.default(D),\n                    I = P.enumeratedString(\"METHOD\"),\n                    C = P.URI,\n                    x = P.hexadecimalInteger(\"IV\");\n                I && (h = new s.default(), C && [\"AES-128\", \"SAMPLE-AES\", \"SAMPLE-AES-CENC\"].indexOf(I) >= 0 && (h.method = I, h.baseuri = t, h.reluri = C, h.key = null, h.iv = x));\n                break;\n\n              case \"START\":\n                var M = O,\n                    F = new l.default(M).decimalFloatingPoint(\"TIME-OFFSET\");\n                Number.isFinite(F) && (c.startTimeOffset = F);\n                break;\n\n              case \"MAP\":\n                var N = new l.default(O);\n                E.relurl = N.URI, E.rawByteRange = N.BYTERANGE, E.baseurl = t, E.level = r, E.type = a, E.sn = \"initSegment\", c.initSegment = E, (E = new n.default()).rawProgramDateTime = c.initSegment.rawProgramDateTime;\n                break;\n\n              default:\n                u.logger.warn(\"line parsed but not handled: \" + _);\n            }\n          }\n        }\n\n        return (E = b) && !E.relurl && (c.fragments.pop(), f -= E.duration), c.totalduration = f, c.averagetargetduration = f / c.fragments.length, c.endSN = d - 1, c.startCC = c.fragments[0] ? c.fragments[0].cc : 0, c.endCC = y, !c.initSegment && c.fragments.length && c.fragments.every(function (e) {\n          return p.test(e.relurl);\n        }) && (u.logger.warn(\"MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX\"), (E = new n.default()).relurl = c.fragments[0].relurl, E.baseurl = t, E.level = r, E.type = a, E.sn = \"initSegment\", c.initSegment = E, c.needSidxRanges = !0), S && function (e, t) {\n          for (var r = e[t], a = t - 1; a >= 0; a--) {\n            var i = e[a];\n            i.programDateTime = r.programDateTime - 1e3 * i.duration, r = i;\n          }\n        }(c.fragments, S), c;\n      }\n    }]), e;\n  }();\n\n  function m(e, t) {\n    e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), Number.isFinite(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null);\n  }\n\n  t.default = y, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e(t) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.endCC = 0, this.endSN = 0, this.fragments = [], this.initSegment = null, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = t, this.version = null;\n    }\n\n    return a(e, [{\n      key: \"hasProgramDateTime\",\n      get: function () {\n        return !(!this.fragments[0] || !Number.isFinite(this.fragments[0].programDateTime));\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = /^(\\d+)x(\\d+)$/,\n      n = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n      o = function () {\n    function e(t) {\n      for (var r in function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), \"string\" == typeof t && (t = e.parseAttrList(t)), t) t.hasOwnProperty(r) && (this[r] = t[r]);\n    }\n\n    return a(e, [{\n      key: \"decimalInteger\",\n      value: function (e) {\n        var t = parseInt(this[e], 10);\n        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n      }\n    }, {\n      key: \"hexadecimalInteger\",\n      value: function (e) {\n        if (this[e]) {\n          var t = (this[e] || \"0x\").slice(2);\n          t = (1 & t.length ? \"0\" : \"\") + t;\n\n          for (var r = new Uint8Array(t.length / 2), a = 0; a < t.length / 2; a++) r[a] = parseInt(t.slice(2 * a, 2 * a + 2), 16);\n\n          return r;\n        }\n\n        return null;\n      }\n    }, {\n      key: \"hexadecimalIntegerAsNumber\",\n      value: function (e) {\n        var t = parseInt(this[e], 16);\n        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n      }\n    }, {\n      key: \"decimalFloatingPoint\",\n      value: function (e) {\n        return parseFloat(this[e]);\n      }\n    }, {\n      key: \"enumeratedString\",\n      value: function (e) {\n        return this[e];\n      }\n    }, {\n      key: \"decimalResolution\",\n      value: function (e) {\n        var t = i.exec(this[e]);\n        if (null !== t) return {\n          width: parseInt(t[1], 10),\n          height: parseInt(t[2], 10)\n        };\n      }\n    }], [{\n      key: \"parseAttrList\",\n      value: function (e) {\n        var t = void 0,\n            r = {};\n\n        for (n.lastIndex = 0; null !== (t = n.exec(e));) {\n          var a = t[2];\n          0 === a.indexOf('\"') && a.lastIndexOf('\"') === a.length - 1 && (a = a.slice(1, -1)), r[t[1]] = a;\n        }\n\n        return r;\n      }\n    }]), e;\n  }();\n\n  t.default = o, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(3)),\n      o = r(2),\n      s = r(0);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.FRAG_LOADING));\n\n      return r.loaders = {}, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        var e = this.loaders;\n\n        for (var r in e) {\n          var a = e[r];\n          a && a.destroy();\n        }\n\n        this.loaders = {}, function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"destroy\", this).call(this);\n      }\n    }, {\n      key: \"onFragLoading\",\n      value: function (e) {\n        var t = e.frag,\n            r = t.type,\n            a = this.loaders,\n            i = this.hls.config,\n            n = i.fLoader,\n            o = i.loader;\n        t.loaded = 0;\n        var l = a[r];\n        l && (s.logger.warn(\"abort previous fragment loader for type: \" + r), l.abort()), l = a[r] = t.loader = i.fLoader ? new n(i) : new o(i);\n        var u,\n            d,\n            f = void 0;\n        f = {\n          url: t.url,\n          frag: t,\n          responseType: \"arraybuffer\",\n          progressData: !1\n        };\n        var c = t.byteRangeStartOffset,\n            h = t.byteRangeEndOffset;\n        Number.isFinite(c) && Number.isFinite(h) && (f.rangeStart = c, f.rangeEnd = h), u = {\n          timeout: i.fragLoadingTimeOut,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: i.fragLoadingMaxRetryTimeout\n        }, d = {\n          onSuccess: this.loadsuccess.bind(this),\n          onError: this.loaderror.bind(this),\n          onTimeout: this.loadtimeout.bind(this),\n          onProgress: this.loadprogress.bind(this)\n        }, l.load(f, u, d);\n      }\n    }, {\n      key: \"loadsuccess\",\n      value: function (e, t, r) {\n        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,\n            n = e.data,\n            o = r.frag;\n        o.loader = void 0, this.loaders[o.type] = void 0, this.hls.trigger(i.default.FRAG_LOADED, {\n          payload: n,\n          frag: o,\n          stats: t,\n          networkDetails: a\n        });\n      }\n    }, {\n      key: \"loaderror\",\n      value: function (e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\n            a = t.frag,\n            n = a.loader;\n        n && n.abort(), this.loaders[a.type] = void 0, this.hls.trigger(i.default.ERROR, {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: o.ErrorDetails.FRAG_LOAD_ERROR,\n          fatal: !1,\n          frag: t.frag,\n          response: e,\n          networkDetails: r\n        });\n      }\n    }, {\n      key: \"loadtimeout\",\n      value: function (e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\n            a = t.frag,\n            n = a.loader;\n        n && n.abort(), this.loaders[a.type] = void 0, this.hls.trigger(i.default.ERROR, {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: o.ErrorDetails.FRAG_LOAD_TIMEOUT,\n          fatal: !1,\n          frag: t.frag,\n          networkDetails: r\n        });\n      }\n    }, {\n      key: \"loadprogress\",\n      value: function (e, t, r) {\n        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,\n            n = t.frag;\n        n.loaded = e.loaded, this.hls.trigger(i.default.FRAG_LOAD_PROGRESS, {\n          frag: n,\n          stats: e,\n          networkDetails: a\n        });\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(3)),\n      o = r(2),\n      s = r(0);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.KEY_LOADING));\n\n      return r.loaders = {}, r.decryptkey = null, r.decrypturl = null, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        for (var e in this.loaders) {\n          var t = this.loaders[e];\n          t && t.destroy();\n        }\n\n        this.loaders = {}, n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onKeyLoading\",\n      value: function (e) {\n        var t = e.frag,\n            r = t.type,\n            a = this.loaders[r],\n            n = t.decryptdata,\n            o = n.uri;\n\n        if (o !== this.decrypturl || null === this.decryptkey) {\n          var l = this.hls.config;\n          a && (s.logger.warn(\"abort previous key loader for type:\" + r), a.abort()), t.loader = this.loaders[r] = new l.loader(l), this.decrypturl = o, this.decryptkey = null;\n          var u, d, f;\n          u = {\n            url: o,\n            frag: t,\n            responseType: \"arraybuffer\"\n          }, d = {\n            timeout: l.fragLoadingTimeOut,\n            maxRetry: 0,\n            retryDelay: l.fragLoadingRetryDelay,\n            maxRetryDelay: l.fragLoadingMaxRetryTimeout\n          }, f = {\n            onSuccess: this.loadsuccess.bind(this),\n            onError: this.loaderror.bind(this),\n            onTimeout: this.loadtimeout.bind(this)\n          }, t.loader.load(u, d, f);\n        } else this.decryptkey && (n.key = this.decryptkey, this.hls.trigger(i.default.KEY_LOADED, {\n          frag: t\n        }));\n      }\n    }, {\n      key: \"loadsuccess\",\n      value: function (e, t, r) {\n        var a = r.frag;\n        this.decryptkey = a.decryptdata.key = new Uint8Array(e.data), a.loader = void 0, this.loaders[a.type] = void 0, this.hls.trigger(i.default.KEY_LOADED, {\n          frag: a\n        });\n      }\n    }, {\n      key: \"loaderror\",\n      value: function (e, t) {\n        var r = t.frag,\n            a = r.loader;\n        a && a.abort(), this.loaders[t.type] = void 0, this.hls.trigger(i.default.ERROR, {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: o.ErrorDetails.KEY_LOAD_ERROR,\n          fatal: !1,\n          frag: r,\n          response: e\n        });\n      }\n    }, {\n      key: \"loadtimeout\",\n      value: function (e, t) {\n        var r = t.frag,\n            a = r.loader;\n        a && a.abort(), this.loaders[t.type] = void 0, this.hls.trigger(i.default.ERROR, {\n          type: o.ErrorTypes.NETWORK_ERROR,\n          details: o.ErrorDetails.KEY_LOAD_TIMEOUT,\n          fatal: !1,\n          frag: r\n        });\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = E(r(9)),\n      n = r(4),\n      o = E(r(19)),\n      s = E(r(1)),\n      l = r(6),\n      u = E(r(11)),\n      d = E(r(15)),\n      f = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(7)),\n      c = E(r(25)),\n      h = r(2),\n      v = r(0),\n      g = r(26),\n      p = r(27),\n      y = E(r(56)),\n      m = r(14),\n      b = E(m);\n\n  function E(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var _ = function (e) {\n    function t(e, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var a = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, s.default.MEDIA_ATTACHED, s.default.MEDIA_DETACHING, s.default.MANIFEST_LOADING, s.default.MANIFEST_PARSED, s.default.LEVEL_LOADED, s.default.KEY_LOADED, s.default.FRAG_LOADED, s.default.FRAG_LOAD_EMERGENCY_ABORTED, s.default.FRAG_PARSING_INIT_SEGMENT, s.default.FRAG_PARSING_DATA, s.default.FRAG_PARSED, s.default.ERROR, s.default.AUDIO_TRACK_SWITCHING, s.default.AUDIO_TRACK_SWITCHED, s.default.BUFFER_CREATED, s.default.BUFFER_APPENDED, s.default.BUFFER_FLUSHED));\n\n      return a.fragmentTracker = r, a.config = e.config, a.audioCodecSwap = !1, a._state = m.State.STOPPED, a.stallReported = !1, a.gapController = null, a;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"startLoad\",\n      value: function (e) {\n        if (this.levels) {\n          var t = this.lastCurrentTime,\n              r = this.hls;\n\n          if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {\n            var a = r.startLevel;\n            -1 === a && (a = 0, this.bitrateTest = !0), this.level = r.nextLoadLevel = a, this.loadedmetadata = !1;\n          }\n\n          t > 0 && -1 === e && (v.logger.log(\"override startPosition with lastCurrentTime @\" + t.toFixed(3)), e = t), this.state = m.State.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();\n        } else this.forceStartLoad = !0, this.state = m.State.STOPPED;\n      }\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        this.forceStartLoad = !1, function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"stopLoad\", this).call(this);\n      }\n    }, {\n      key: \"doTick\",\n      value: function () {\n        switch (this.state) {\n          case m.State.BUFFER_FLUSHING:\n            this.fragLoadError = 0;\n            break;\n\n          case m.State.IDLE:\n            this._doTickIdle();\n\n            break;\n\n          case m.State.WAITING_LEVEL:\n            var e = this.levels[this.level];\n            e && e.details && (this.state = m.State.IDLE);\n            break;\n\n          case m.State.FRAG_LOADING_WAITING_RETRY:\n            var t = window.performance.now(),\n                r = this.retryDate;\n            (!r || t >= r || this.media && this.media.seeking) && (v.logger.log(\"mediaController: retryDate reached, switch back to IDLE state\"), this.state = m.State.IDLE);\n            break;\n\n          case m.State.ERROR:\n          case m.State.STOPPED:\n          case m.State.FRAG_LOADING:\n          case m.State.PARSING:\n          case m.State.PARSED:\n          case m.State.ENDED:\n        }\n\n        this._checkBuffer(), this._checkFragmentChanged();\n      }\n    }, {\n      key: \"_doTickIdle\",\n      value: function () {\n        var e = this.hls,\n            t = e.config,\n            r = this.media;\n\n        if (void 0 !== this.levelLastLoaded && (r || !this.startFragRequested && t.startFragPrefetch)) {\n          var a = void 0;\n          a = this.loadedmetadata ? r.currentTime : this.nextLoadPosition;\n          var i = e.nextLoadLevel,\n              o = this.levels[i];\n\n          if (o) {\n            var l = o.bitrate,\n                u = void 0;\n            u = l ? Math.max(8 * t.maxBufferSize / l, t.maxBufferLength) : t.maxBufferLength, u = Math.min(u, t.maxMaxBufferLength);\n            var d = n.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, a, t.maxBufferHole),\n                f = d.len;\n\n            if (!(f >= u)) {\n              v.logger.trace(\"buffer length of \" + f.toFixed(3) + \" is below max of \" + u.toFixed(3) + \". checking for more payload ...\"), this.level = e.nextLoadLevel = i;\n              var c = o.details;\n              if (!c || c.live && this.levelLastLoaded !== i) this.state = m.State.WAITING_LEVEL;else {\n                if (this._streamEnded(d, c)) {\n                  var h = {};\n                  return this.altAudio && (h.type = \"video\"), this.hls.trigger(s.default.BUFFER_EOS, h), void (this.state = m.State.ENDED);\n                }\n\n                this._fetchPayloadOrEos(a, d, c);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_fetchPayloadOrEos\",\n      value: function (e, t, r) {\n        var a = this.fragPrevious,\n            i = this.level,\n            n = r.fragments,\n            o = n.length;\n\n        if (0 !== o) {\n          var s = n[0].start,\n              l = n[o - 1].start + n[o - 1].duration,\n              u = t.end,\n              d = void 0;\n          if (r.initSegment && !r.initSegment.data) d = r.initSegment;else if (r.live) {\n            var f = this.config.initialLiveManifestSize;\n            if (o < f) return void v.logger.warn(\"Can not start playback of a level, reason: not enough fragments \" + o + \" < \" + f);\n            if (null === (d = this._ensureFragmentAtLivePoint(r, u, s, l, a, n, o))) return;\n          } else u < s && (d = n[0]);\n          d || (d = this._findFragment(s, a, o, n, u, l, r)), d && (d.encrypted ? (v.logger.log(\"Loading key for \" + d.sn + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],level \" + i), this._loadKey(d)) : (v.logger.log(\"Loading \" + d.sn + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],level \" + i + \", currentTime:\" + e.toFixed(3) + \",bufferEnd:\" + u.toFixed(3)), this._loadFragment(d)));\n        }\n      }\n    }, {\n      key: \"_ensureFragmentAtLivePoint\",\n      value: function (e, t, r, a, n, o, s) {\n        var l = this.hls.config,\n            u = this.media,\n            d = void 0,\n            f = void 0 !== l.liveMaxLatencyDuration ? l.liveMaxLatencyDuration : l.liveMaxLatencyDurationCount * e.targetduration;\n\n        if (t < Math.max(r - l.maxFragLookUpTolerance, a - f)) {\n          var c = this.liveSyncPosition = this.computeLivePosition(r, e);\n          v.logger.log(\"buffer end: \" + t.toFixed(3) + \" is located too far from the end of live sliding playlist, reset currentTime to : \" + c.toFixed(3)), t = c, u && u.readyState && u.duration > c && (u.currentTime = c), this.nextLoadPosition = c;\n        }\n\n        if (e.PTSKnown && t > a && u && u.readyState) return null;\n\n        if (this.startFragRequested && !e.PTSKnown) {\n          if (n) if (e.hasProgramDateTime) v.logger.log(\"live playlist, switching playlist, load frag with same PDT: \" + n.programDateTime), d = (0, p.findFragmentByPDT)(o, n.endProgramDateTime, l.maxFragLookUpTolerance);else {\n            var h = n.sn + 1;\n\n            if (h >= e.startSN && h <= e.endSN) {\n              var g = o[h - e.startSN];\n              n.cc === g.cc && (d = g, v.logger.log(\"live playlist, switching playlist, load frag with next SN: \" + d.sn));\n            }\n\n            d || (d = i.default.search(o, function (e) {\n              return n.cc - e.cc;\n            })) && v.logger.log(\"live playlist, switching playlist, load frag with same CC: \" + d.sn);\n          }\n          d || (d = o[Math.min(s - 1, Math.round(s / 2))], v.logger.log(\"live playlist, switching playlist, unknown, load middle frag : \" + d.sn));\n        }\n\n        return d;\n      }\n    }, {\n      key: \"_findFragment\",\n      value: function (e, t, r, a, i, n, o) {\n        var s = this.hls.config,\n            l = void 0;\n\n        if (i < n) {\n          var u = i > n - s.maxFragLookUpTolerance ? 0 : s.maxFragLookUpTolerance;\n          l = (0, p.findFragmentByPTS)(t, a, i, u);\n        } else l = a[r - 1];\n\n        if (l) {\n          var d = l.sn - o.startSN,\n              f = t && l.level === t.level,\n              c = a[d - 1],\n              h = a[d + 1];\n          if (t && l.sn === t.sn) if (f && !l.backtracked) {\n            if (l.sn < o.endSN) {\n              var g = t.deltaPTS;\n              g && g > s.maxBufferHole && t.dropped && d ? (l = c, v.logger.warn(\"SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this\")) : (l = h, v.logger.log(\"SN just loaded, load next one: \" + l.sn, l));\n            } else l = null;\n          } else l.backtracked && (h && h.backtracked ? (v.logger.warn(\"Already backtracked from fragment \" + h.sn + \", will not backtrack to fragment \" + l.sn + \". Loading fragment \" + h.sn), l = h) : (v.logger.warn(\"Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe\"), l.dropped = 0, c ? (l = c).backtracked = !0 : d && (l = null)));\n        }\n\n        return l;\n      }\n    }, {\n      key: \"_loadKey\",\n      value: function (e) {\n        this.state = m.State.KEY_LOADING, this.hls.trigger(s.default.KEY_LOADING, {\n          frag: e\n        });\n      }\n    }, {\n      key: \"_loadFragment\",\n      value: function (e) {\n        var t = this.fragmentTracker.getState(e);\n        this.fragCurrent = e, this.startFragRequested = !0, Number.isFinite(e.sn) && !e.bitrateTest && (this.nextLoadPosition = e.start + e.duration), e.backtracked || t === l.FragmentState.NOT_LOADED || t === l.FragmentState.PARTIAL ? (e.autoLevel = this.hls.autoLevelEnabled, e.bitrateTest = this.bitrateTest, this.hls.trigger(s.default.FRAG_LOADING, {\n          frag: e\n        }), this.demuxer || (this.demuxer = new o.default(this.hls, \"main\")), this.state = m.State.FRAG_LOADING) : t === l.FragmentState.APPENDING && this._reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e);\n      }\n    }, {\n      key: \"getBufferedFrag\",\n      value: function (e) {\n        return this.fragmentTracker.getBufferedFrag(e, d.default.LevelType.MAIN);\n      }\n    }, {\n      key: \"followingBufferedFrag\",\n      value: function (e) {\n        return e ? this.getBufferedFrag(e.endPTS + .5) : null;\n      }\n    }, {\n      key: \"_checkFragmentChanged\",\n      value: function () {\n        var e = void 0,\n            t = void 0,\n            r = this.media;\n\n        if (r && r.readyState && !1 === r.seeking && ((t = r.currentTime) > this.lastCurrentTime && (this.lastCurrentTime = t), n.BufferHelper.isBuffered(r, t) ? e = this.getBufferedFrag(t) : n.BufferHelper.isBuffered(r, t + .1) && (e = this.getBufferedFrag(t + .1)), e)) {\n          var a = e;\n\n          if (a !== this.fragPlaying) {\n            this.hls.trigger(s.default.FRAG_CHANGED, {\n              frag: a\n            });\n            var i = a.level;\n            this.fragPlaying && this.fragPlaying.level === i || this.hls.trigger(s.default.LEVEL_SWITCHED, {\n              level: i\n            }), this.fragPlaying = a;\n          }\n        }\n      }\n    }, {\n      key: \"immediateLevelSwitch\",\n      value: function () {\n        if (v.logger.log(\"immediateLevelSwitch\"), !this.immediateSwitch) {\n          this.immediateSwitch = !0;\n          var e = this.media,\n              t = void 0;\n          e ? (t = e.paused, e.pause()) : t = !0, this.previouslyPaused = t;\n        }\n\n        var r = this.fragCurrent;\n        r && r.loader && r.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n      }\n    }, {\n      key: \"immediateLevelSwitchEnd\",\n      value: function () {\n        var e = this.media;\n        e && e.buffered.length && (this.immediateSwitch = !1, n.BufferHelper.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play());\n      }\n    }, {\n      key: \"nextLevelSwitch\",\n      value: function () {\n        var e = this.media;\n\n        if (e && e.readyState) {\n          var t,\n              r = void 0,\n              a = void 0;\n          if ((t = this.getBufferedFrag(e.currentTime)) && t.startPTS > 1 && this.flushMainBuffer(0, t.startPTS - 1), e.paused) r = 0;else {\n            var i = this.hls.nextLoadLevel,\n                n = this.levels[i],\n                o = this.fragLastKbps;\n            r = o && this.fragCurrent ? this.fragCurrent.duration * n.bitrate / (1e3 * o) + 1 : 0;\n          }\n\n          if ((a = this.getBufferedFrag(e.currentTime + r)) && (a = this.followingBufferedFrag(a))) {\n            var s = this.fragCurrent;\n            s && s.loader && s.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(a.maxStartPTS, Number.POSITIVE_INFINITY);\n          }\n        }\n      }\n    }, {\n      key: \"flushMainBuffer\",\n      value: function (e, t) {\n        this.state = m.State.BUFFER_FLUSHING;\n        var r = {\n          startOffset: e,\n          endOffset: t\n        };\n        this.altAudio && (r.type = \"video\"), this.hls.trigger(s.default.BUFFER_FLUSHING, r);\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        var t = this.media = this.mediaBuffer = e.media;\n        this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener(\"seeking\", this.onvseeking), t.addEventListener(\"seeked\", this.onvseeked), t.addEventListener(\"ended\", this.onvended);\n        var r = this.config;\n        this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition), this.gapController = new y.default(r, t, this.fragmentTracker, this.hls);\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        var e = this.media;\n        e && e.ended && (v.logger.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0);\n        var t = this.levels;\n        t && t.forEach(function (e) {\n          e.details && e.details.fragments.forEach(function (e) {\n            e.backtracked = void 0;\n          });\n        }), e && (e.removeEventListener(\"seeking\", this.onvseeking), e.removeEventListener(\"seeked\", this.onvseeked), e.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();\n      }\n    }, {\n      key: \"onMediaSeeked\",\n      value: function () {\n        var e = this.media,\n            t = e ? e.currentTime : void 0;\n        Number.isFinite(t) && v.logger.log(\"media seeked to \" + t.toFixed(3)), this.tick();\n      }\n    }, {\n      key: \"onManifestLoading\",\n      value: function () {\n        v.logger.log(\"trigger BUFFER_RESET\"), this.hls.trigger(s.default.BUFFER_RESET), this.fragmentTracker.removeAllFragments(), this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;\n      }\n    }, {\n      key: \"onManifestParsed\",\n      value: function (e) {\n        var t = !1,\n            r = !1,\n            a = void 0;\n        e.levels.forEach(function (e) {\n          (a = e.audioCodec) && (-1 !== a.indexOf(\"mp4a.40.2\") && (t = !0), -1 !== a.indexOf(\"mp4a.40.5\") && (r = !0));\n        }), this.audioCodecSwitch = t && r, this.audioCodecSwitch && v.logger.log(\"both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = e.levels, this.startFragRequested = !1;\n        var i = this.config;\n        (i.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(i.startPosition);\n      }\n    }, {\n      key: \"onLevelLoaded\",\n      value: function (e) {\n        var t = e.details,\n            r = e.level,\n            a = this.levels[this.levelLastLoaded],\n            i = this.levels[r],\n            n = t.totalduration,\n            o = 0;\n\n        if (v.logger.log(\"level \" + r + \" loaded [\" + t.startSN + \",\" + t.endSN + \"],duration:\" + n), t.live) {\n          var l = i.details;\n          l && t.fragments.length > 0 ? (f.mergeDetails(l, t), o = t.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(o, l), t.PTSKnown && Number.isFinite(o) ? v.logger.log(\"live playlist sliding:\" + o.toFixed(3)) : (v.logger.log(\"live playlist - outdated PTS, unknown sliding\"), (0, g.alignStream)(this.fragPrevious, a, t))) : (v.logger.log(\"live playlist - first load, unknown sliding\"), t.PTSKnown = !1, (0, g.alignStream)(this.fragPrevious, a, t));\n        } else t.PTSKnown = !1;\n\n        if (i.details = t, this.levelLastLoaded = r, this.hls.trigger(s.default.LEVEL_UPDATED, {\n          details: t,\n          level: r\n        }), !1 === this.startFragRequested) {\n          if (-1 === this.startPosition || -1 === this.lastCurrentTime) {\n            var u = t.startTimeOffset;\n            Number.isFinite(u) ? (u < 0 && (v.logger.log(\"negative start time offset \" + u + \", count from end of last fragment\"), u = o + n + u), v.logger.log(\"start time offset found in playlist, adjust startPosition to \" + u), this.startPosition = u) : t.live ? (this.startPosition = this.computeLivePosition(o, t), v.logger.log(\"configure startPosition to \" + this.startPosition)) : this.startPosition = 0, this.lastCurrentTime = this.startPosition;\n          }\n\n          this.nextLoadPosition = this.startPosition;\n        }\n\n        this.state === m.State.WAITING_LEVEL && (this.state = m.State.IDLE), this.tick();\n      }\n    }, {\n      key: \"onKeyLoaded\",\n      value: function () {\n        this.state === m.State.KEY_LOADING && (this.state = m.State.IDLE, this.tick());\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = this.hls,\n            a = this.levels,\n            i = this.media,\n            n = e.frag;\n\n        if (this.state === m.State.FRAG_LOADING && t && \"main\" === n.type && n.level === t.level && n.sn === t.sn) {\n          var l = e.stats,\n              u = a[t.level],\n              d = u.details;\n          if (this.bitrateTest = !1, this.stats = l, v.logger.log(\"Loaded \" + t.sn + \" of [\" + d.startSN + \" ,\" + d.endSN + \"],level \" + t.level), n.bitrateTest && r.nextLoadLevel) this.state = m.State.IDLE, this.startFragRequested = !1, l.tparsed = l.tbuffered = window.performance.now(), r.trigger(s.default.FRAG_BUFFERED, {\n            stats: l,\n            frag: t,\n            id: \"main\"\n          }), this.tick();else if (\"initSegment\" === n.sn) this.state = m.State.IDLE, l.tparsed = l.tbuffered = window.performance.now(), d.initSegment.data = e.payload, r.trigger(s.default.FRAG_BUFFERED, {\n            stats: l,\n            frag: t,\n            id: \"main\"\n          }), this.tick();else {\n            v.logger.log(\"Parsing \" + t.sn + \" of [\" + d.startSN + \" ,\" + d.endSN + \"],level \" + t.level + \", cc \" + t.cc), this.state = m.State.PARSING, this.pendingBuffering = !0, this.appended = !1, n.bitrateTest && (n.bitrateTest = !1, this.fragmentTracker.onFragLoaded({\n              frag: n\n            }));\n\n            var f = !(i && i.seeking) && (d.PTSKnown || !d.live),\n                c = d.initSegment ? d.initSegment.data : [],\n                h = this._getAudioCodec(u);\n\n            (this.demuxer = this.demuxer || new o.default(this.hls, \"main\")).push(e.payload, c, h, u.videoCodec, t, d.totalduration, f);\n          }\n        }\n\n        this.fragLoadError = 0;\n      }\n    }, {\n      key: \"onFragParsingInitSegment\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag;\n\n        if (t && \"main\" === e.id && r.sn === t.sn && r.level === t.level && this.state === m.State.PARSING) {\n          var a = e.tracks,\n              i = void 0,\n              n = void 0;\n\n          if (a.audio && this.altAudio && delete a.audio, n = a.audio) {\n            var o = this.levels[this.level].audioCodec,\n                l = navigator.userAgent.toLowerCase();\n            o && this.audioCodecSwap && (v.logger.log(\"swapping playlist audio codec\"), o = -1 !== o.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), this.audioCodecSwitch && 1 !== n.metadata.channelCount && -1 === l.indexOf(\"firefox\") && (o = \"mp4a.40.5\"), -1 !== l.indexOf(\"android\") && \"audio/mpeg\" !== n.container && (o = \"mp4a.40.2\", v.logger.log(\"Android: force audio codec to \" + o)), n.levelCodec = o, n.id = e.id;\n          }\n\n          for (i in (n = a.video) && (n.levelCodec = this.levels[this.level].videoCodec, n.id = e.id), this.hls.trigger(s.default.BUFFER_CODECS, a), a) {\n            n = a[i], v.logger.log(\"main track:\" + i + \",container:\" + n.container + \",codecs[level/parsed]=[\" + n.levelCodec + \"/\" + n.codec + \"]\");\n            var u = n.initSegment;\n            u && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(s.default.BUFFER_APPENDING, {\n              type: i,\n              data: u,\n              parent: \"main\",\n              content: \"initSegment\"\n            }));\n          }\n\n          this.tick();\n        }\n      }\n    }, {\n      key: \"onFragParsingData\",\n      value: function (e) {\n        var t = this,\n            r = this.fragCurrent,\n            a = e.frag;\n\n        if (r && \"main\" === e.id && a.sn === r.sn && a.level === r.level && (\"audio\" !== e.type || !this.altAudio) && this.state === m.State.PARSING) {\n          var i = this.levels[this.level],\n              n = r;\n          if (Number.isFinite(e.endPTS) || (e.endPTS = e.startPTS + r.duration, e.endDTS = e.startDTS + r.duration), !0 === e.hasAudio && n.addElementaryStream(u.default.ElementaryStreamTypes.AUDIO), !0 === e.hasVideo && n.addElementaryStream(u.default.ElementaryStreamTypes.VIDEO), v.logger.log(\"Parsed \" + e.type + \",PTS:[\" + e.startPTS.toFixed(3) + \",\" + e.endPTS.toFixed(3) + \"],DTS:[\" + e.startDTS.toFixed(3) + \"/\" + e.endDTS.toFixed(3) + \"],nb:\" + e.nb + \",dropped:\" + (e.dropped || 0)), \"video\" === e.type) if (n.dropped = e.dropped, n.dropped) {\n            if (n.backtracked) v.logger.warn(\"Already backtracked on this fragment, appending with the gap\", n.sn);else {\n              var o = i.details;\n              if (!o || n.sn !== o.startSN) return v.logger.warn(\"missing video frame(s), backtracking fragment\", n.sn), this.fragmentTracker.removeFragment(n), n.backtracked = !0, this.nextLoadPosition = e.startPTS, this.state = m.State.IDLE, this.fragPrevious = n, void this.tick();\n              v.logger.warn(\"missing video frame(s) on first frag, appending with gap\", n.sn);\n            }\n          } else n.backtracked = !1;\n          var l = f.updateFragPTSDTS(i.details, n, e.startPTS, e.endPTS, e.startDTS, e.endDTS),\n              d = this.hls;\n          d.trigger(s.default.LEVEL_PTS_UPDATED, {\n            details: i.details,\n            level: this.level,\n            drift: l,\n            type: e.type,\n            start: e.startPTS,\n            end: e.endPTS\n          }), [e.data1, e.data2].forEach(function (r) {\n            r && r.length && t.state === m.State.PARSING && (t.appended = !0, t.pendingBuffering = !0, d.trigger(s.default.BUFFER_APPENDING, {\n              type: e.type,\n              data: r,\n              parent: \"main\",\n              content: \"data\"\n            }));\n          }), this.tick();\n        }\n      }\n    }, {\n      key: \"onFragParsed\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag;\n        t && \"main\" === e.id && r.sn === t.sn && r.level === t.level && this.state === m.State.PARSING && (this.stats.tparsed = window.performance.now(), this.state = m.State.PARSED, this._checkAppendedParsed());\n      }\n    }, {\n      key: \"onAudioTrackSwitching\",\n      value: function (e) {\n        var t = !!e.url,\n            r = e.id;\n\n        if (!t) {\n          if (this.mediaBuffer !== this.media) {\n            v.logger.log(\"switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n            var a = this.fragCurrent;\n            a.loader && (v.logger.log(\"switching to main audio track, cancel main fragment load\"), a.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = m.State.IDLE;\n          }\n\n          var i = this.hls;\n          i.trigger(s.default.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: Number.POSITIVE_INFINITY,\n            type: \"audio\"\n          }), i.trigger(s.default.AUDIO_TRACK_SWITCHED, {\n            id: r\n          }), this.altAudio = !1;\n        }\n      }\n    }, {\n      key: \"onAudioTrackSwitched\",\n      value: function (e) {\n        var t = e.id,\n            r = !!this.hls.audioTracks[t].url;\n\n        if (r) {\n          var a = this.videoBuffer;\n          a && this.mediaBuffer !== a && (v.logger.log(\"switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = a);\n        }\n\n        this.altAudio = r, this.tick();\n      }\n    }, {\n      key: \"onBufferCreated\",\n      value: function (e) {\n        var t = e.tracks,\n            r = void 0,\n            a = void 0,\n            i = !1;\n\n        for (var n in t) {\n          var o = t[n];\n          \"main\" === o.id ? (a = n, r = o, \"video\" === n && (this.videoBuffer = t[n].buffer)) : i = !0;\n        }\n\n        i && r ? (v.logger.log(\"alternate track found, use \" + a + \".buffered to schedule main fragment loading\"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media;\n      }\n    }, {\n      key: \"onBufferAppended\",\n      value: function (e) {\n        if (\"main\" === e.parent) {\n          var t = this.state;\n          t !== m.State.PARSING && t !== m.State.PARSED || (this.pendingBuffering = e.pending > 0, this._checkAppendedParsed());\n        }\n      }\n    }, {\n      key: \"_checkAppendedParsed\",\n      value: function () {\n        if (!(this.state !== m.State.PARSED || this.appended && this.pendingBuffering)) {\n          var e = this.fragCurrent;\n\n          if (e) {\n            var t = this.mediaBuffer ? this.mediaBuffer : this.media;\n            v.logger.log(\"main buffered : \" + c.default.toString(t.buffered)), this.fragPrevious = e;\n            var r = this.stats;\n            r.tbuffered = window.performance.now(), this.fragLastKbps = Math.round(8 * r.total / (r.tbuffered - r.tfirst)), this.hls.trigger(s.default.FRAG_BUFFERED, {\n              stats: r,\n              frag: e,\n              id: \"main\"\n            }), this.state = m.State.IDLE;\n          }\n\n          this.tick();\n        }\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        var t = e.frag || this.fragCurrent;\n\n        if (!t || \"main\" === t.type) {\n          var r = !!this.media && n.BufferHelper.isBuffered(this.media, this.media.currentTime) && n.BufferHelper.isBuffered(this.media, this.media.currentTime + .5);\n\n          switch (e.details) {\n            case h.ErrorDetails.FRAG_LOAD_ERROR:\n            case h.ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case h.ErrorDetails.KEY_LOAD_ERROR:\n            case h.ErrorDetails.KEY_LOAD_TIMEOUT:\n              if (!e.fatal) if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {\n                var a = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);\n                v.logger.warn(\"mediaController: frag loading failed, retry in \" + a + \" ms\"), this.retryDate = window.performance.now() + a, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = m.State.FRAG_LOADING_WAITING_RETRY;\n              } else v.logger.error(\"mediaController: \" + e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.state = m.State.ERROR;\n              break;\n\n            case h.ErrorDetails.LEVEL_LOAD_ERROR:\n            case h.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n              this.state !== m.State.ERROR && (e.fatal ? (this.state = m.State.ERROR, v.logger.warn(\"streamController: \" + e.details + \",switch to \" + this.state + \" state ...\")) : e.levelRetry || this.state !== m.State.WAITING_LEVEL || (this.state = m.State.IDLE));\n              break;\n\n            case h.ErrorDetails.BUFFER_FULL_ERROR:\n              \"main\" !== e.parent || this.state !== m.State.PARSING && this.state !== m.State.PARSED || (r ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = m.State.IDLE) : (v.logger.warn(\"buffer full error also media.currentTime is not buffered, flush everything\"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)));\n          }\n        }\n      }\n    }, {\n      key: \"_reduceMaxBufferLength\",\n      value: function (e) {\n        var t = this.config;\n        return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, v.logger.warn(\"main:reduce max buffer length to \" + t.maxMaxBufferLength + \"s\"), !0);\n      }\n    }, {\n      key: \"_checkBuffer\",\n      value: function () {\n        var e = this.media;\n\n        if (e && 0 !== e.readyState) {\n          var t = (this.mediaBuffer ? this.mediaBuffer : e).buffered;\n          !this.loadedmetadata && t.length ? (this.loadedmetadata = !0, this._seekToStartPos()) : this.immediateSwitch ? this.immediateLevelSwitchEnd() : this.gapController.poll(this.lastCurrentTime, t);\n        }\n      }\n    }, {\n      key: \"onFragLoadEmergencyAborted\",\n      value: function () {\n        this.state = m.State.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick();\n      }\n    }, {\n      key: \"onBufferFlushed\",\n      value: function () {\n        var e = this.mediaBuffer ? this.mediaBuffer : this.media;\n        e && this.fragmentTracker.detectEvictedFragments(u.default.ElementaryStreamTypes.VIDEO, e.buffered), this.state = m.State.IDLE, this.fragPrevious = null;\n      }\n    }, {\n      key: \"swapAudioCodec\",\n      value: function () {\n        this.audioCodecSwap = !this.audioCodecSwap;\n      }\n    }, {\n      key: \"computeLivePosition\",\n      value: function (e, t) {\n        var r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration;\n        return e + Math.max(0, t.totalduration - r);\n      }\n    }, {\n      key: \"_seekToStartPos\",\n      value: function () {\n        var e = this.media,\n            t = e.currentTime,\n            r = e.seeking ? t : this.startPosition;\n        t !== r && (v.logger.log(\"target start position not buffered, seek to buffered.start(0) \" + r + \" from current time \" + t + \" \"), e.currentTime = r);\n      }\n    }, {\n      key: \"_getAudioCodec\",\n      value: function (e) {\n        var t = this.config.defaultAudioCodec || e.audioCodec;\n        return this.audioCodecSwap && (v.logger.log(\"swapping playlist audio codec\"), t && (t = -1 !== t.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\")), t;\n      }\n    }, {\n      key: \"state\",\n      set: function (e) {\n        if (this.state !== e) {\n          var t = this.state;\n          this._state = e, v.logger.log(\"main stream:\" + t + \"->\" + e), this.hls.trigger(s.default.STREAM_STATE_TRANSITION, {\n            previousState: t,\n            nextState: e\n          });\n        }\n      },\n      get: function () {\n        return this._state;\n      }\n    }, {\n      key: \"currentLevel\",\n      get: function () {\n        var e = this.media;\n\n        if (e) {\n          var t = this.getBufferedFrag(e.currentTime);\n          if (t) return t.level;\n        }\n\n        return -1;\n      }\n    }, {\n      key: \"nextBufferedFrag\",\n      get: function () {\n        var e = this.media;\n        return e ? this.followingBufferedFrag(this.getBufferedFrag(e.currentTime)) : null;\n      }\n    }, {\n      key: \"nextLevel\",\n      get: function () {\n        var e = this.nextBufferedFrag;\n        return e ? e.level : -1;\n      }\n    }, {\n      key: \"liveSyncPosition\",\n      get: function () {\n        return this._liveSyncPosition;\n      },\n      set: function (e) {\n        this._liveSyncPosition = e;\n      }\n    }]), t;\n  }(b.default);\n\n  t.default = _, e.exports = t.default;\n}, function (e, t, r) {\n  function a(e) {\n    var t = {};\n\n    function r(a) {\n      if (t[a]) return t[a].exports;\n      var i = t[a] = {\n        i: a,\n        l: !1,\n        exports: {}\n      };\n      return e[a].call(i.exports, i, i.exports, r), i.l = !0, i.exports;\n    }\n\n    r.m = e, r.c = t, r.i = function (e) {\n      return e;\n    }, r.d = function (e, t, a) {\n      r.o(e, t) || Object.defineProperty(e, t, {\n        configurable: !1,\n        enumerable: !0,\n        get: a\n      });\n    }, r.r = function (e) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, r.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return r.d(t, \"a\", t), t;\n    }, r.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, r.p = \"/\", r.oe = function (e) {\n      throw console.error(e), e;\n    };\n    var a = r(r.s = ENTRY_MODULE);\n    return a.default || a;\n  }\n\n  function i(e) {\n    return (e + \"\").replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n  }\n\n  function n(e, t, a) {\n    var n = {};\n    n[a] = [];\n    var o = t.toString(),\n        s = o.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n    if (!s) return n;\n\n    for (var l, u = s[1], d = new RegExp(\"(\\\\\\\\n|\\\\W)\" + i(u) + \"\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)\", \"g\"); l = d.exec(o);) \"dll-reference\" !== l[3] && n[a].push(l[3]);\n\n    for (d = new RegExp(\"\\\\(\" + i(u) + '\\\\(\"(dll-reference\\\\s([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+))\"\\\\)\\\\)\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)', \"g\"); l = d.exec(o);) e[l[2]] || (n[a].push(l[1]), e[l[2]] = r(l[1]).m), n[l[2]] = n[l[2]] || [], n[l[2]].push(l[4]);\n\n    for (var f, c = Object.keys(n), h = 0; h < c.length; h++) for (var v = 0; v < n[c[h]].length; v++) f = n[c[h]][v], isNaN(1 * f) || (n[c[h]][v] = 1 * n[c[h]][v]);\n\n    return n;\n  }\n\n  function o(e) {\n    return Object.keys(e).reduce(function (t, r) {\n      return t || e[r].length > 0;\n    }, !1);\n  }\n\n  e.exports = function (e, t) {\n    t = t || {};\n    var i = {\n      main: r.m\n    },\n        s = t.all ? {\n      main: Object.keys(i.main)\n    } : function (e, t) {\n      for (var r = {\n        main: [t]\n      }, a = {\n        main: []\n      }, i = {\n        main: {}\n      }; o(r);) for (var s = Object.keys(r), l = 0; l < s.length; l++) {\n        var u = s[l],\n            d = r[u].pop();\n\n        if (i[u] = i[u] || {}, !i[u][d] && e[u][d]) {\n          i[u][d] = !0, a[u] = a[u] || [], a[u].push(d);\n\n          for (var f = n(e, e[u][d], u), c = Object.keys(f), h = 0; h < c.length; h++) r[c[h]] = r[c[h]] || [], r[c[h]] = r[c[h]].concat(f[c[h]]);\n        }\n      }\n\n      return a;\n    }(i, e),\n        l = \"\";\n    Object.keys(s).filter(function (e) {\n      return \"main\" !== e;\n    }).forEach(function (e) {\n      for (var t = 0; s[e][t];) t++;\n\n      s[e].push(t), i[e][t] = \"(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })\", l = l + \"var \" + e + \" = (\" + a.toString().replace(\"ENTRY_MODULE\", JSON.stringify(t)) + \")({\" + s[e].map(function (t) {\n        return JSON.stringify(t) + \": \" + i[e][t].toString();\n      }).join(\",\") + \"});\\n\";\n    }), l = l + \"new ((\" + a.toString().replace(\"ENTRY_MODULE\", JSON.stringify(e)) + \")({\" + s.main.map(function (e) {\n      return JSON.stringify(e) + \": \" + i.main[e].toString();\n    }).join(\",\") + \"}))(self);\";\n    var u = new window.Blob([l], {\n      type: \"text/javascript\"\n    });\n    if (t.bare) return u;\n    var d = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(u),\n        f = new window.Worker(d);\n    return f.objectURL = d, f;\n  };\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e(t, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.subtle = t, this.aesIV = r;\n    }\n\n    return a(e, [{\n      key: \"decrypt\",\n      value: function (e, t) {\n        return this.subtle.decrypt({\n          name: \"AES-CBC\",\n          iv: this.aesIV\n        }, t, e);\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e(t, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.subtle = t, this.key = r;\n    }\n\n    return a(e, [{\n      key: \"expandKey\",\n      value: function () {\n        return this.subtle.importKey(\"raw\", this.key, {\n          name: \"AES-CBC\"\n        }, !1, [\"encrypt\", \"decrypt\"]);\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  function i(e) {\n    var t = e.byteLength,\n        r = t && new DataView(e).getUint8(t - 1);\n    return r ? e.slice(0, t - r) : e;\n  }\n\n  t.removePadding = i;\n\n  var n = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();\n    }\n\n    return a(e, [{\n      key: \"uint8ArrayToUint32Array_\",\n      value: function (e) {\n        for (var t = new DataView(e), r = new Uint32Array(4), a = 0; a < 4; a++) r[a] = t.getUint32(4 * a);\n\n        return r;\n      }\n    }, {\n      key: \"initTable\",\n      value: function () {\n        var e = this.sBox,\n            t = this.invSBox,\n            r = this.subMix,\n            a = r[0],\n            i = r[1],\n            n = r[2],\n            o = r[3],\n            s = this.invSubMix,\n            l = s[0],\n            u = s[1],\n            d = s[2],\n            f = s[3],\n            c = new Uint32Array(256),\n            h = 0,\n            v = 0,\n            g = 0;\n\n        for (g = 0; g < 256; g++) c[g] = g < 128 ? g << 1 : g << 1 ^ 283;\n\n        for (g = 0; g < 256; g++) {\n          var p = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4;\n          p = p >>> 8 ^ 255 & p ^ 99, e[h] = p, t[p] = h;\n          var y = c[h],\n              m = c[y],\n              b = c[m],\n              E = 257 * c[p] ^ 16843008 * p;\n          a[h] = E << 24 | E >>> 8, i[h] = E << 16 | E >>> 16, n[h] = E << 8 | E >>> 24, o[h] = E, E = 16843009 * b ^ 65537 * m ^ 257 * y ^ 16843008 * h, l[p] = E << 24 | E >>> 8, u[p] = E << 16 | E >>> 16, d[p] = E << 8 | E >>> 24, f[p] = E, h ? (h = y ^ c[c[c[b ^ y]]], v ^= c[c[v]]) : h = v = 1;\n        }\n      }\n    }, {\n      key: \"expandKey\",\n      value: function (e) {\n        for (var t = this.uint8ArrayToUint32Array_(e), r = !0, a = 0; a < t.length && r;) r = t[a] === this.key[a], a++;\n\n        if (!r) {\n          this.key = t;\n          var i = this.keySize = t.length;\n          if (4 !== i && 6 !== i && 8 !== i) throw new Error(\"Invalid aes key size=\" + i);\n          var n = this.ksRows = 4 * (i + 6 + 1),\n              o = void 0,\n              s = void 0,\n              l = this.keySchedule = new Uint32Array(n),\n              u = this.invKeySchedule = new Uint32Array(n),\n              d = this.sBox,\n              f = this.rcon,\n              c = this.invSubMix,\n              h = c[0],\n              v = c[1],\n              g = c[2],\n              p = c[3],\n              y = void 0,\n              m = void 0;\n\n          for (o = 0; o < n; o++) o < i ? y = l[o] = t[o] : (m = y, o % i == 0 ? (m = d[(m = m << 8 | m >>> 24) >>> 24] << 24 | d[m >>> 16 & 255] << 16 | d[m >>> 8 & 255] << 8 | d[255 & m], m ^= f[o / i | 0] << 24) : i > 6 && o % i == 4 && (m = d[m >>> 24] << 24 | d[m >>> 16 & 255] << 16 | d[m >>> 8 & 255] << 8 | d[255 & m]), l[o] = y = (l[o - i] ^ m) >>> 0);\n\n          for (s = 0; s < n; s++) o = n - s, m = 3 & s ? l[o] : l[o - 4], u[s] = s < 4 || o <= 4 ? m : h[d[m >>> 24]] ^ v[d[m >>> 16 & 255]] ^ g[d[m >>> 8 & 255]] ^ p[d[255 & m]], u[s] = u[s] >>> 0;\n        }\n      }\n    }, {\n      key: \"networkToHostOrderSwap\",\n      value: function (e) {\n        return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24;\n      }\n    }, {\n      key: \"decrypt\",\n      value: function (e, t, r, a) {\n        for (var n = this.keySize + 6, o = this.invKeySchedule, s = this.invSBox, l = this.invSubMix, u = l[0], d = l[1], f = l[2], c = l[3], h = this.uint8ArrayToUint32Array_(r), v = h[0], g = h[1], p = h[2], y = h[3], m = new Int32Array(e), b = new Int32Array(m.length), E = void 0, _ = void 0, T = void 0, S = void 0, k = void 0, R = void 0, A = void 0, w = void 0, O = void 0, L = void 0, D = void 0, P = void 0, I = void 0, C = void 0, x = this.networkToHostOrderSwap; t < m.length;) {\n          for (O = x(m[t]), L = x(m[t + 1]), D = x(m[t + 2]), P = x(m[t + 3]), k = O ^ o[0], R = P ^ o[1], A = D ^ o[2], w = L ^ o[3], I = 4, C = 1; C < n; C++) E = u[k >>> 24] ^ d[R >> 16 & 255] ^ f[A >> 8 & 255] ^ c[255 & w] ^ o[I], _ = u[R >>> 24] ^ d[A >> 16 & 255] ^ f[w >> 8 & 255] ^ c[255 & k] ^ o[I + 1], T = u[A >>> 24] ^ d[w >> 16 & 255] ^ f[k >> 8 & 255] ^ c[255 & R] ^ o[I + 2], S = u[w >>> 24] ^ d[k >> 16 & 255] ^ f[R >> 8 & 255] ^ c[255 & A] ^ o[I + 3], k = E, R = _, A = T, w = S, I += 4;\n\n          E = s[k >>> 24] << 24 ^ s[R >> 16 & 255] << 16 ^ s[A >> 8 & 255] << 8 ^ s[255 & w] ^ o[I], _ = s[R >>> 24] << 24 ^ s[A >> 16 & 255] << 16 ^ s[w >> 8 & 255] << 8 ^ s[255 & k] ^ o[I + 1], T = s[A >>> 24] << 24 ^ s[w >> 16 & 255] << 16 ^ s[k >> 8 & 255] << 8 ^ s[255 & R] ^ o[I + 2], S = s[w >>> 24] << 24 ^ s[k >> 16 & 255] << 16 ^ s[R >> 8 & 255] << 8 ^ s[255 & A] ^ o[I + 3], I += 3, b[t] = x(E ^ v), b[t + 1] = x(S ^ g), b[t + 2] = x(T ^ p), b[t + 3] = x(_ ^ y), v = O, g = L, p = D, y = P, t += 4;\n        }\n\n        return a ? i(b.buffer) : b.buffer;\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;\n      }\n    }]), e;\n  }();\n\n  t.default = n;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(22)),\n      o = r(0),\n      s = r(10),\n      l = (a = s) && a.__esModule ? a : {\n    default: a\n  };\n\n  var u = function () {\n    function e(t, r, a) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.config = a, this.remuxer = r;\n    }\n\n    return i(e, [{\n      key: \"resetInitSegment\",\n      value: function (e, t, r, a) {\n        this._audioTrack = {\n          container: \"audio/adts\",\n          type: \"audio\",\n          id: 0,\n          sequenceNumber: 0,\n          isAAC: !0,\n          samples: [],\n          len: 0,\n          manifestCodec: t,\n          duration: a,\n          inputTimeScale: 9e4\n        };\n      }\n    }, {\n      key: \"resetTimeStamp\",\n      value: function () {}\n    }, {\n      key: \"append\",\n      value: function (e, t, r, a) {\n        for (var i = this._audioTrack, s = l.default.getID3Data(e, 0) || [], u = l.default.getTimeStamp(s), d = Number.isFinite(u) ? 90 * u : 9e4 * t, f = 0, c = d, h = e.length, v = s.length, g = [{\n          pts: c,\n          dts: c,\n          data: s\n        }]; v < h - 1;) if (n.isHeader(e, v) && v + 5 < h) {\n          n.initTrackConfig(i, this.observer, e, v, i.manifestCodec);\n          var p = n.appendFrame(i, e, v, d, f);\n\n          if (!p) {\n            o.logger.log(\"Unable to parse AAC frame\");\n            break;\n          }\n\n          v += p.length, c = p.sample.pts, f++;\n        } else l.default.isHeader(e, v) ? (s = l.default.getID3Data(e, v), g.push({\n          pts: c,\n          dts: c,\n          data: s\n        }), v += s.length) : v++;\n\n        this.remuxer.remux(i, {\n          samples: []\n        }, {\n          samples: g,\n          inputTimeScale: 9e4\n        }, {\n          samples: []\n        }, t, r, a);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {}\n    }], [{\n      key: \"probe\",\n      value: function (e) {\n        if (!e) return !1;\n\n        for (var t = (l.default.getID3Data(e, 0) || []).length, r = e.length; t < r; t++) if (n.probe(e, t)) return o.logger.log(\"ADTS sync word found !\"), !0;\n\n        return !1;\n      }\n    }]), e;\n  }();\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(22)),\n      n = f(r(23)),\n      o = f(r(1)),\n      s = f(r(47)),\n      l = f(r(48)),\n      u = r(0),\n      d = r(2);\n\n  function f(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var c = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n  },\n      h = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.config = a, this.typeSupported = i, this.remuxer = r, this.sampleAes = null;\n    }\n\n    return a(e, [{\n      key: \"setDecryptData\",\n      value: function (e) {\n        null != e && null != e.key && \"SAMPLE-AES\" === e.method ? this.sampleAes = new l.default(this.observer, this.config, e, this.discardEPB) : this.sampleAes = null;\n      }\n    }, {\n      key: \"resetInitSegment\",\n      value: function (t, r, a, i) {\n        this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = e.createTrack(\"video\", i), this._audioTrack = e.createTrack(\"audio\", i), this._id3Track = e.createTrack(\"id3\", i), this._txtTrack = e.createTrack(\"text\", i), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = r, this.videoCodec = a, this._duration = i;\n      }\n    }, {\n      key: \"resetTimeStamp\",\n      value: function () {}\n    }, {\n      key: \"append\",\n      value: function (t, r, a, i) {\n        var n = void 0,\n            s = t.length,\n            l = void 0,\n            f = void 0,\n            c = void 0,\n            h = void 0,\n            v = !1;\n        this.contiguous = a;\n\n        var g = this.pmtParsed,\n            p = this._avcTrack,\n            y = this._audioTrack,\n            m = this._id3Track,\n            b = p.pid,\n            E = y.pid,\n            _ = m.pid,\n            T = this._pmtId,\n            S = p.pesData,\n            k = y.pesData,\n            R = m.pesData,\n            A = this._parsePAT,\n            w = this._parsePMT,\n            O = this._parsePES,\n            L = this._parseAVCPES.bind(this),\n            D = this._parseAACPES.bind(this),\n            P = this._parseMPEGPES.bind(this),\n            I = this._parseID3PES.bind(this),\n            C = e._syncOffset(t);\n\n        for (s -= (s + C) % 188, n = C; n < s; n += 188) if (71 === t[n]) {\n          if (l = !!(64 & t[n + 1]), f = ((31 & t[n + 1]) << 8) + t[n + 2], (48 & t[n + 3]) >> 4 > 1) {\n            if ((c = n + 5 + t[n + 4]) === n + 188) continue;\n          } else c = n + 4;\n\n          switch (f) {\n            case b:\n              l && (S && (h = O(S)) && void 0 !== h.pts && L(h, !1), S = {\n                data: [],\n                size: 0\n              }), S && (S.data.push(t.subarray(c, n + 188)), S.size += n + 188 - c);\n              break;\n\n            case E:\n              l && (k && (h = O(k)) && void 0 !== h.pts && (y.isAAC ? D(h) : P(h)), k = {\n                data: [],\n                size: 0\n              }), k && (k.data.push(t.subarray(c, n + 188)), k.size += n + 188 - c);\n              break;\n\n            case _:\n              l && (R && (h = O(R)) && void 0 !== h.pts && I(h), R = {\n                data: [],\n                size: 0\n              }), R && (R.data.push(t.subarray(c, n + 188)), R.size += n + 188 - c);\n              break;\n\n            case 0:\n              l && (c += t[c] + 1), T = this._pmtId = A(t, c);\n              break;\n\n            case T:\n              l && (c += t[c] + 1);\n              var x = w(t, c, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, null != this.sampleAes);\n              (b = x.avc) > 0 && (p.pid = b), (E = x.audio) > 0 && (y.pid = E, y.isAAC = x.isAAC), (_ = x.id3) > 0 && (m.pid = _), v && !g && (u.logger.log(\"reparse from beginning\"), v = !1, n = C - 188), g = this.pmtParsed = !0;\n              break;\n\n            case 17:\n            case 8191:\n              break;\n\n            default:\n              v = !0;\n          }\n        } else this.observer.trigger(o.default.ERROR, {\n          type: d.ErrorTypes.MEDIA_ERROR,\n          details: d.ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: !1,\n          reason: \"TS packet did not start with 0x47\"\n        });\n\n        S && (h = O(S)) && void 0 !== h.pts ? (L(h, !0), p.pesData = null) : p.pesData = S, k && (h = O(k)) && void 0 !== h.pts ? (y.isAAC ? D(h) : P(h), y.pesData = null) : (k && k.size && u.logger.log(\"last AAC PES packet truncated,might overlap between fragments\"), y.pesData = k), R && (h = O(R)) && void 0 !== h.pts ? (I(h), m.pesData = null) : m.pesData = R, null == this.sampleAes ? this.remuxer.remux(y, p, m, this._txtTrack, r, a, i) : this.decryptAndRemux(y, p, m, this._txtTrack, r, a, i);\n      }\n    }, {\n      key: \"decryptAndRemux\",\n      value: function (e, t, r, a, i, n, o) {\n        if (e.samples && e.isAAC) {\n          var s = this;\n          this.sampleAes.decryptAacSamples(e.samples, 0, function () {\n            s.decryptAndRemuxAvc(e, t, r, a, i, n, o);\n          });\n        } else this.decryptAndRemuxAvc(e, t, r, a, i, n, o);\n      }\n    }, {\n      key: \"decryptAndRemuxAvc\",\n      value: function (e, t, r, a, i, n, o) {\n        if (t.samples) {\n          var s = this;\n          this.sampleAes.decryptAvcSamples(t.samples, 0, 0, function () {\n            s.remuxer.remux(e, t, r, a, i, n, o);\n          });\n        } else this.remuxer.remux(e, t, r, a, i, n, o);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        this._initPTS = this._initDTS = void 0, this._duration = 0;\n      }\n    }, {\n      key: \"_parsePAT\",\n      value: function (e, t) {\n        return (31 & e[t + 10]) << 8 | e[t + 11];\n      }\n    }, {\n      key: \"_parsePMT\",\n      value: function (e, t, r, a) {\n        var i,\n            n = void 0,\n            o = {\n          audio: -1,\n          avc: -1,\n          id3: -1,\n          isAAC: !0\n        };\n\n        for (i = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4, t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < i;) {\n          switch (n = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) {\n            case 207:\n              if (!a) {\n                u.logger.log(\"unkown stream type:\" + e[t]);\n                break;\n              }\n\n            case 15:\n              -1 === o.audio && (o.audio = n);\n              break;\n\n            case 21:\n              -1 === o.id3 && (o.id3 = n);\n              break;\n\n            case 219:\n              if (!a) {\n                u.logger.log(\"unkown stream type:\" + e[t]);\n                break;\n              }\n\n            case 27:\n              -1 === o.avc && (o.avc = n);\n              break;\n\n            case 3:\n            case 4:\n              r ? -1 === o.audio && (o.audio = n, o.isAAC = !1) : u.logger.log(\"MPEG audio found, not supported in this browser for now\");\n              break;\n\n            case 36:\n              u.logger.warn(\"HEVC stream type found, not supported for now\");\n              break;\n\n            default:\n              u.logger.log(\"unkown stream type:\" + e[t]);\n          }\n\n          t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4]);\n        }\n\n        return o;\n      }\n    }, {\n      key: \"_parsePES\",\n      value: function (e) {\n        var t = 0,\n            r = void 0,\n            a = void 0,\n            i = void 0,\n            n = void 0,\n            o = void 0,\n            s = void 0,\n            l = void 0,\n            d = void 0,\n            f = e.data;\n        if (!e || 0 === e.size) return null;\n\n        for (; f[0].length < 19 && f.length > 1;) {\n          var c = new Uint8Array(f[0].length + f[1].length);\n          c.set(f[0]), c.set(f[1], f[0].length), f[0] = c, f.splice(1, 1);\n        }\n\n        if (1 === ((r = f[0])[0] << 16) + (r[1] << 8) + r[2]) {\n          if ((i = (r[4] << 8) + r[5]) && i > e.size - 6) return null;\n          192 & (a = r[7]) && ((s = 536870912 * (14 & r[9]) + 4194304 * (255 & r[10]) + 16384 * (254 & r[11]) + 128 * (255 & r[12]) + (254 & r[13]) / 2) > 4294967295 && (s -= 8589934592), 64 & a ? ((l = 536870912 * (14 & r[14]) + 4194304 * (255 & r[15]) + 16384 * (254 & r[16]) + 128 * (255 & r[17]) + (254 & r[18]) / 2) > 4294967295 && (l -= 8589934592), s - l > 54e5 && (u.logger.warn(Math.round((s - l) / 9e4) + \"s delta between PTS and DTS, align them\"), s = l)) : l = s), d = (n = r[8]) + 9, e.size -= d, o = new Uint8Array(e.size);\n\n          for (var h = 0, v = f.length; h < v; h++) {\n            var g = (r = f[h]).byteLength;\n\n            if (d) {\n              if (d > g) {\n                d -= g;\n                continue;\n              }\n\n              r = r.subarray(d), g -= d, d = 0;\n            }\n\n            o.set(r, t), t += g;\n          }\n\n          return i && (i -= n + 3), {\n            data: o,\n            pts: s,\n            dts: l,\n            len: i\n          };\n        }\n\n        return null;\n      }\n    }, {\n      key: \"pushAccesUnit\",\n      value: function (e, t) {\n        if (e.units.length && e.frame) {\n          var r = t.samples,\n              a = r.length;\n          !this.config.forceKeyFrameOnDiscontinuity || !0 === e.key || t.sps && (a || this.contiguous) ? (e.id = a, r.push(e)) : t.dropped++;\n        }\n\n        e.debug.length && u.logger.log(e.pts + \"/\" + e.dts + \":\" + e.debug);\n      }\n    }, {\n      key: \"_parseAVCPES\",\n      value: function (e, t) {\n        var r = this,\n            a = this._avcTrack,\n            i = this._parseAVCNALu(e.data),\n            n = void 0,\n            o = this.avcSample,\n            l = void 0,\n            u = !1,\n            d = void 0,\n            f = this.pushAccesUnit.bind(this),\n            c = function (e, t, r, a) {\n          return {\n            key: e,\n            pts: t,\n            dts: r,\n            units: [],\n            debug: a\n          };\n        };\n\n        e.data = null, o && i.length && !a.audFound && (f(o, a), o = this.avcSample = c(!1, e.pts, e.dts, \"\")), i.forEach(function (t) {\n          switch (t.type) {\n            case 1:\n              l = !0, o || (o = r.avcSample = c(!0, e.pts, e.dts, \"\")), o.frame = !0;\n              var i = t.data;\n\n              if (u && i.length > 4) {\n                var h = new s.default(i).readSliceType();\n                2 !== h && 4 !== h && 7 !== h && 9 !== h || (o.key = !0);\n              }\n\n              break;\n\n            case 5:\n              l = !0, o || (o = r.avcSample = c(!0, e.pts, e.dts, \"\")), o.key = !0, o.frame = !0;\n              break;\n\n            case 6:\n              l = !0, (n = new s.default(r.discardEPB(t.data))).readUByte();\n\n              for (var v = 0, g = 0, p = !1, y = 0; !p && n.bytesAvailable > 1;) {\n                v = 0;\n\n                do {\n                  v += y = n.readUByte();\n                } while (255 === y);\n\n                g = 0;\n\n                do {\n                  g += y = n.readUByte();\n                } while (255 === y);\n\n                if (4 === v && 0 !== n.bytesAvailable) {\n                  if (p = !0, 181 === n.readUByte()) if (49 === n.readUShort()) if (1195456820 === n.readUInt()) if (3 === n.readUByte()) {\n                    var m = n.readUByte(),\n                        b = 31 & m,\n                        E = [m, n.readUByte()];\n\n                    for (d = 0; d < b; d++) E.push(n.readUByte()), E.push(n.readUByte()), E.push(n.readUByte());\n\n                    r._insertSampleInOrder(r._txtTrack.samples, {\n                      type: 3,\n                      pts: e.pts,\n                      bytes: E\n                    });\n                  }\n                } else if (g < n.bytesAvailable) for (d = 0; d < g; d++) n.readUByte();\n              }\n\n              break;\n\n            case 7:\n              if (l = !0, u = !0, !a.sps) {\n                var _ = (n = new s.default(t.data)).readSPS();\n\n                a.width = _.width, a.height = _.height, a.pixelRatio = _.pixelRatio, a.sps = [t.data], a.duration = r._duration;\n                var T = t.data.subarray(1, 4),\n                    S = \"avc1.\";\n\n                for (d = 0; d < 3; d++) {\n                  var k = T[d].toString(16);\n                  k.length < 2 && (k = \"0\" + k), S += k;\n                }\n\n                a.codec = S;\n              }\n\n              break;\n\n            case 8:\n              l = !0, a.pps || (a.pps = [t.data]);\n              break;\n\n            case 9:\n              l = !1, a.audFound = !0, o && f(o, a), o = r.avcSample = c(!1, e.pts, e.dts, \"\");\n              break;\n\n            case 12:\n              l = !1;\n              break;\n\n            default:\n              l = !1, o && (o.debug += \"unknown NAL \" + t.type + \" \");\n          }\n\n          o && l && o.units.push(t);\n        }), t && o && (f(o, a), this.avcSample = null);\n      }\n    }, {\n      key: \"_insertSampleInOrder\",\n      value: function (e, t) {\n        var r = e.length;\n\n        if (r > 0) {\n          if (t.pts >= e[r - 1].pts) e.push(t);else for (var a = r - 1; a >= 0; a--) if (t.pts < e[a].pts) {\n            e.splice(a, 0, t);\n            break;\n          }\n        } else e.push(t);\n      }\n    }, {\n      key: \"_getLastNalUnit\",\n      value: function () {\n        var e = this.avcSample,\n            t = void 0;\n\n        if (!e || 0 === e.units.length) {\n          var r = this._avcTrack.samples;\n          e = r[r.length - 1];\n        }\n\n        if (e) {\n          var a = e.units;\n          t = a[a.length - 1];\n        }\n\n        return t;\n      }\n    }, {\n      key: \"_parseAVCNALu\",\n      value: function (e) {\n        var t = 0,\n            r = e.byteLength,\n            a = void 0,\n            i = void 0,\n            n = this._avcTrack,\n            o = n.naluState || 0,\n            s = o,\n            l = [],\n            u = void 0,\n            d = -1,\n            f = void 0;\n\n        for (-1 === o && (d = 0, f = 31 & e[0], o = 0, t = 1); t < r;) if (a = e[t++], o) {\n          if (1 !== o) {\n            if (a) {\n              if (1 === a) {\n                if (d >= 0) u = {\n                  data: e.subarray(d, t - o - 1),\n                  type: f\n                }, l.push(u);else {\n                  var c = this._getLastNalUnit();\n\n                  if (c && (s && t <= 4 - s && c.state && (c.data = c.data.subarray(0, c.data.byteLength - s)), (i = t - o - 1) > 0)) {\n                    var h = new Uint8Array(c.data.byteLength + i);\n                    h.set(c.data, 0), h.set(e.subarray(0, i), c.data.byteLength), c.data = h;\n                  }\n                }\n                t < r ? (d = t, f = 31 & e[t], o = 0) : o = -1;\n              } else o = 0;\n            } else o = 3;\n          } else o = a ? 0 : 2;\n        } else o = a ? 0 : 1;\n\n        if (d >= 0 && o >= 0 && (u = {\n          data: e.subarray(d, r),\n          type: f,\n          state: o\n        }, l.push(u)), 0 === l.length) {\n          var v = this._getLastNalUnit();\n\n          if (v) {\n            var g = new Uint8Array(v.data.byteLength + e.byteLength);\n            g.set(v.data, 0), g.set(e, v.data.byteLength), v.data = g;\n          }\n        }\n\n        return n.naluState = o, l;\n      }\n    }, {\n      key: \"discardEPB\",\n      value: function (e) {\n        for (var t, r = e.byteLength, a = [], i = 1, n = void 0; i < r - 2;) 0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2] ? (a.push(i + 2), i += 2) : i++;\n\n        if (0 === a.length) return e;\n        t = r - a.length, n = new Uint8Array(t);\n        var o = 0;\n\n        for (i = 0; i < t; o++, i++) o === a[0] && (o++, a.shift()), n[i] = e[o];\n\n        return n;\n      }\n    }, {\n      key: \"_parseAACPES\",\n      value: function (e) {\n        var t,\n            r,\n            a = this._audioTrack,\n            n = e.data,\n            s = e.pts,\n            l = this.aacOverFlow,\n            f = this.aacLastPTS,\n            c = void 0,\n            h = void 0,\n            v = void 0;\n\n        if (l) {\n          var g = new Uint8Array(l.byteLength + n.byteLength);\n          g.set(l, 0), g.set(n, l.byteLength), n = g;\n        }\n\n        for (h = 0, r = n.length; h < r - 1 && !i.isHeader(n, h); h++);\n\n        if (h) {\n          var p = void 0,\n              y = void 0;\n          if (h < r - 1 ? (p = \"AAC PES did not start with ADTS header,offset:\" + h, y = !1) : (p = \"no ADTS header found in AAC PES\", y = !0), u.logger.warn(\"parsing error:\" + p), this.observer.trigger(o.default.ERROR, {\n            type: d.ErrorTypes.MEDIA_ERROR,\n            details: d.ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: y,\n            reason: p\n          }), y) return;\n        }\n\n        if (i.initTrackConfig(a, this.observer, n, h, this.audioCodec), c = 0, t = i.getFrameDuration(a.samplerate), l && f) {\n          var m = f + t;\n          Math.abs(m - s) > 1 && (u.logger.log(\"AAC: align PTS for overlapping frames by \" + Math.round((m - s) / 90)), s = m);\n        }\n\n        for (; h < r;) if (i.isHeader(n, h) && h + 5 < r) {\n          var b = i.appendFrame(a, n, h, s, c);\n          if (!b) break;\n          h += b.length, v = b.sample.pts, c++;\n        } else h++;\n\n        l = h < r ? n.subarray(h, r) : null, this.aacOverFlow = l, this.aacLastPTS = v;\n      }\n    }, {\n      key: \"_parseMPEGPES\",\n      value: function (e) {\n        for (var t = e.data, r = t.length, a = 0, i = 0, o = e.pts; i < r;) if (n.default.isHeader(t, i)) {\n          var s = n.default.appendFrame(this._audioTrack, t, i, o, a);\n          if (!s) break;\n          i += s.length, a++;\n        } else i++;\n      }\n    }, {\n      key: \"_parseID3PES\",\n      value: function (e) {\n        this._id3Track.samples.push(e);\n      }\n    }], [{\n      key: \"probe\",\n      value: function (t) {\n        var r = e._syncOffset(t);\n\n        return !(r < 0) && (r && u.logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + r + \", junk ahead ?\"), !0);\n      }\n    }, {\n      key: \"_syncOffset\",\n      value: function (e) {\n        for (var t = Math.min(1e3, e.length - 564), r = 0; r < t;) {\n          if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376]) return r;\n          r++;\n        }\n\n        return -1;\n      }\n    }, {\n      key: \"createTrack\",\n      value: function (e, t) {\n        return {\n          container: \"video\" === e || \"audio\" === e ? \"video/mp2t\" : void 0,\n          type: e,\n          id: c[e],\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: 0,\n          samples: [],\n          len: 0,\n          dropped: \"video\" === e ? 0 : void 0,\n          isAAC: \"audio\" === e || void 0,\n          duration: \"audio\" === e ? t : void 0\n        };\n      }\n    }]), e;\n  }();\n\n  t.default = h, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = r(0);\n\n  var n = function () {\n    function e(t) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0;\n    }\n\n    return a(e, [{\n      key: \"loadWord\",\n      value: function () {\n        var e = this.data,\n            t = this.bytesAvailable,\n            r = e.byteLength - t,\n            a = new Uint8Array(4),\n            i = Math.min(4, t);\n        if (0 === i) throw new Error(\"no bytes available\");\n        a.set(e.subarray(r, r + i)), this.word = new DataView(a.buffer).getUint32(0), this.bitsAvailable = 8 * i, this.bytesAvailable -= i;\n      }\n    }, {\n      key: \"skipBits\",\n      value: function (e) {\n        var t = void 0;\n        this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, e -= (t = e >> 3) >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);\n      }\n    }, {\n      key: \"readBits\",\n      value: function (e) {\n        var t = Math.min(this.bitsAvailable, e),\n            r = this.word >>> 32 - t;\n        return e > 32 && i.logger.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r;\n      }\n    }, {\n      key: \"skipLZ\",\n      value: function () {\n        var e = void 0;\n\n        for (e = 0; e < this.bitsAvailable; ++e) if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;\n\n        return this.loadWord(), e + this.skipLZ();\n      }\n    }, {\n      key: \"skipUEG\",\n      value: function () {\n        this.skipBits(1 + this.skipLZ());\n      }\n    }, {\n      key: \"skipEG\",\n      value: function () {\n        this.skipBits(1 + this.skipLZ());\n      }\n    }, {\n      key: \"readUEG\",\n      value: function () {\n        var e = this.skipLZ();\n        return this.readBits(e + 1) - 1;\n      }\n    }, {\n      key: \"readEG\",\n      value: function () {\n        var e = this.readUEG();\n        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);\n      }\n    }, {\n      key: \"readBoolean\",\n      value: function () {\n        return 1 === this.readBits(1);\n      }\n    }, {\n      key: \"readUByte\",\n      value: function () {\n        return this.readBits(8);\n      }\n    }, {\n      key: \"readUShort\",\n      value: function () {\n        return this.readBits(16);\n      }\n    }, {\n      key: \"readUInt\",\n      value: function () {\n        return this.readBits(32);\n      }\n    }, {\n      key: \"skipScalingList\",\n      value: function (e) {\n        var t = 8,\n            r = 8,\n            a = void 0;\n\n        for (a = 0; a < e; a++) 0 !== r && (r = (t + this.readEG() + 256) % 256), t = 0 === r ? t : r;\n      }\n    }, {\n      key: \"readSPS\",\n      value: function () {\n        var e,\n            t,\n            r,\n            a,\n            i = 0,\n            n = 0,\n            o = 0,\n            s = 0,\n            l = void 0,\n            u = void 0,\n            d = void 0,\n            f = this.readUByte.bind(this),\n            c = this.readBits.bind(this),\n            h = this.readUEG.bind(this),\n            v = this.readBoolean.bind(this),\n            g = this.skipBits.bind(this),\n            p = this.skipEG.bind(this),\n            y = this.skipUEG.bind(this),\n            m = this.skipScalingList.bind(this);\n\n        if (f(), e = f(), c(5), g(3), f(), y(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) {\n          var b = h();\n          if (3 === b && g(1), y(), y(), g(1), v()) for (u = 3 !== b ? 8 : 12, d = 0; d < u; d++) v() && m(d < 6 ? 16 : 64);\n        }\n\n        y();\n        var E = h();\n        if (0 === E) h();else if (1 === E) for (g(1), p(), p(), l = h(), d = 0; d < l; d++) p();\n        y(), g(1), t = h(), r = h(), 0 === (a = c(1)) && g(1), g(1), v() && (i = h(), n = h(), o = h(), s = h());\n        var _ = [1, 1];\n        if (v() && v()) switch (f()) {\n          case 1:\n            _ = [1, 1];\n            break;\n\n          case 2:\n            _ = [12, 11];\n            break;\n\n          case 3:\n            _ = [10, 11];\n            break;\n\n          case 4:\n            _ = [16, 11];\n            break;\n\n          case 5:\n            _ = [40, 33];\n            break;\n\n          case 6:\n            _ = [24, 11];\n            break;\n\n          case 7:\n            _ = [20, 11];\n            break;\n\n          case 8:\n            _ = [32, 11];\n            break;\n\n          case 9:\n            _ = [80, 33];\n            break;\n\n          case 10:\n            _ = [18, 11];\n            break;\n\n          case 11:\n            _ = [15, 11];\n            break;\n\n          case 12:\n            _ = [64, 33];\n            break;\n\n          case 13:\n            _ = [160, 99];\n            break;\n\n          case 14:\n            _ = [4, 3];\n            break;\n\n          case 15:\n            _ = [3, 2];\n            break;\n\n          case 16:\n            _ = [2, 1];\n            break;\n\n          case 255:\n            _ = [f() << 8 | f(), f() << 8 | f()];\n        }\n        return {\n          width: Math.ceil(16 * (t + 1) - 2 * i - 2 * n),\n          height: (2 - a) * (r + 1) * 16 - (a ? 2 : 4) * (o + s),\n          pixelRatio: _\n        };\n      }\n    }, {\n      key: \"readSliceType\",\n      value: function () {\n        return this.readUByte(), this.readUEG(), this.readUEG();\n      }\n    }]), e;\n  }();\n\n  t.default = n, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(12),\n      o = (a = n) && a.__esModule ? a : {\n    default: a\n  };\n\n  var s = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.decryptdata = a, this.discardEPB = i, this.decrypter = new o.default(t, r, {\n        removePKCS7Padding: !1\n      });\n    }\n\n    return i(e, [{\n      key: \"decryptBuffer\",\n      value: function (e, t) {\n        this.decrypter.decrypt(e, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, t);\n      }\n    }, {\n      key: \"decryptAacSample\",\n      value: function (e, t, r, a) {\n        var i = e[t].unit,\n            n = i.subarray(16, i.length - i.length % 16),\n            o = n.buffer.slice(n.byteOffset, n.byteOffset + n.length),\n            s = this;\n        this.decryptBuffer(o, function (n) {\n          n = new Uint8Array(n), i.set(n, 16), a || s.decryptAacSamples(e, t + 1, r);\n        });\n      }\n    }, {\n      key: \"decryptAacSamples\",\n      value: function (e, t, r) {\n        for (;; t++) {\n          if (t >= e.length) return void r();\n\n          if (!(e[t].unit.length < 32)) {\n            var a = this.decrypter.isSync();\n            if (this.decryptAacSample(e, t, r, a), !a) return;\n          }\n        }\n      }\n    }, {\n      key: \"getAvcEncryptedData\",\n      value: function (e) {\n        for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), a = 0, i = 32; i <= e.length - 16; i += 160, a += 16) r.set(e.subarray(i, i + 16), a);\n\n        return r;\n      }\n    }, {\n      key: \"getAvcDecryptedUnit\",\n      value: function (e, t) {\n        t = new Uint8Array(t);\n\n        for (var r = 0, a = 32; a <= e.length - 16; a += 160, r += 16) e.set(t.subarray(r, r + 16), a);\n\n        return e;\n      }\n    }, {\n      key: \"decryptAvcSample\",\n      value: function (e, t, r, a, i, n) {\n        var o = this.discardEPB(i.data),\n            s = this.getAvcEncryptedData(o),\n            l = this;\n        this.decryptBuffer(s.buffer, function (s) {\n          i.data = l.getAvcDecryptedUnit(o, s), n || l.decryptAvcSamples(e, t, r + 1, a);\n        });\n      }\n    }, {\n      key: \"decryptAvcSamples\",\n      value: function (e, t, r, a) {\n        for (;; t++, r = 0) {\n          if (t >= e.length) return void a();\n\n          for (var i = e[t].units; !(r >= i.length); r++) {\n            var n = i[r];\n\n            if (!(n.length <= 48 || 1 !== n.type && 5 !== n.type)) {\n              var o = this.decrypter.isSync();\n              if (this.decryptAvcSample(e, t, r, a, n, o), !o) return;\n            }\n          }\n        }\n      }\n    }]), e;\n  }();\n\n  t.default = s, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = s(r(10)),\n      n = r(0),\n      o = s(r(23));\n\n  function s(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var l = function () {\n    function e(t, r, a) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.config = a, this.remuxer = r;\n    }\n\n    return a(e, [{\n      key: \"resetInitSegment\",\n      value: function (e, t, r, a) {\n        this._audioTrack = {\n          container: \"audio/mpeg\",\n          type: \"audio\",\n          id: -1,\n          sequenceNumber: 0,\n          isAAC: !1,\n          samples: [],\n          len: 0,\n          manifestCodec: t,\n          duration: a,\n          inputTimeScale: 9e4\n        };\n      }\n    }, {\n      key: \"resetTimeStamp\",\n      value: function () {}\n    }, {\n      key: \"append\",\n      value: function (e, t, r, a) {\n        for (var n = i.default.getID3Data(e, 0), s = i.default.getTimeStamp(n), l = s ? 90 * s : 9e4 * t, u = n.length, d = e.length, f = 0, c = 0, h = this._audioTrack, v = [{\n          pts: l,\n          dts: l,\n          data: n\n        }]; u < d;) if (o.default.isHeader(e, u)) {\n          var g = o.default.appendFrame(h, e, u, l, f);\n          if (!g) break;\n          u += g.length, c = g.sample.pts, f++;\n        } else i.default.isHeader(e, u) ? (n = i.default.getID3Data(e, u), v.push({\n          pts: c,\n          dts: c,\n          data: n\n        }), u += n.length) : u++;\n\n        this.remuxer.remux(h, {\n          samples: []\n        }, {\n          samples: v,\n          inputTimeScale: 9e4\n        }, {\n          samples: []\n        }, t, r, a);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {}\n    }], [{\n      key: \"probe\",\n      value: function (e) {\n        var t = void 0,\n            r = void 0,\n            a = i.default.getID3Data(e, 0);\n        if (a && void 0 !== i.default.getTimeStamp(a)) for (t = a.length, r = Math.min(e.length - 1, t + 100); t < r; t++) if (o.default.probe(e, t)) return n.logger.log(\"MPEG Audio sync word found !\"), !0;\n        return !1;\n      }\n    }]), e;\n  }();\n\n  t.default = l, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = u(r(51)),\n      n = u(r(52)),\n      o = u(r(1)),\n      s = r(2),\n      l = r(0);\n\n  function u(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var d = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t, this.config = r, this.typeSupported = a;\n      var n = navigator.userAgent;\n      this.isSafari = i && i.indexOf(\"Apple\") > -1 && n && !n.match(\"CriOS\"), this.ISGenerated = !1;\n    }\n\n    return a(e, [{\n      key: \"destroy\",\n      value: function () {}\n    }, {\n      key: \"resetTimeStamp\",\n      value: function (e) {\n        this._initPTS = this._initDTS = e;\n      }\n    }, {\n      key: \"resetInitSegment\",\n      value: function () {\n        this.ISGenerated = !1;\n      }\n    }, {\n      key: \"remux\",\n      value: function (e, t, r, a, i, n, s) {\n        if (this.ISGenerated || this.generateIS(e, t, i), this.ISGenerated) {\n          var u = e.samples.length,\n              d = t.samples.length,\n              f = i,\n              c = i;\n\n          if (u && d) {\n            var h = (e.samples[0].pts - t.samples[0].pts) / t.inputTimeScale;\n            f += Math.max(0, h), c += Math.max(0, -h);\n          }\n\n          if (u) {\n            e.timescale || (l.logger.warn(\"regenerate InitSegment as audio detected\"), this.generateIS(e, t, i));\n            var v = this.remuxAudio(e, f, n, s);\n\n            if (d) {\n              var g = void 0;\n              v && (g = v.endPTS - v.startPTS), t.timescale || (l.logger.warn(\"regenerate InitSegment as video detected\"), this.generateIS(e, t, i)), this.remuxVideo(t, c, n, g, s);\n            }\n          } else if (d) {\n            var p = this.remuxVideo(t, c, n, 0, s);\n            p && e.codec && this.remuxEmptyAudio(e, f, n, p);\n          }\n        }\n\n        r.samples.length && this.remuxID3(r, i), a.samples.length && this.remuxText(a, i), this.observer.trigger(o.default.FRAG_PARSED);\n      }\n    }, {\n      key: \"generateIS\",\n      value: function (e, t, r) {\n        var a = this.observer,\n            i = e.samples,\n            u = t.samples,\n            d = this.typeSupported,\n            f = \"audio/mp4\",\n            c = {},\n            h = {\n          tracks: c\n        },\n            v = void 0 === this._initPTS,\n            g = void 0,\n            p = void 0;\n\n        if (v && (g = p = 1 / 0), e.config && i.length && (e.timescale = e.samplerate, l.logger.log(\"audio sampling rate : \" + e.samplerate), e.isAAC || (d.mpeg ? (f = \"audio/mpeg\", e.codec = \"\") : d.mp3 && (e.codec = \"mp3\")), c.audio = {\n          container: f,\n          codec: e.codec,\n          initSegment: !e.isAAC && d.mpeg ? new Uint8Array() : n.default.initSegment([e]),\n          metadata: {\n            channelCount: e.channelCount\n          }\n        }, v && (g = p = i[0].pts - e.inputTimeScale * r)), t.sps && t.pps && u.length) {\n          var y = t.inputTimeScale;\n          t.timescale = y, c.video = {\n            container: \"video/mp4\",\n            codec: t.codec,\n            initSegment: n.default.initSegment([t]),\n            metadata: {\n              width: t.width,\n              height: t.height\n            }\n          }, v && (g = Math.min(g, u[0].pts - y * r), p = Math.min(p, u[0].dts - y * r), this.observer.trigger(o.default.INIT_PTS_FOUND, {\n            initPTS: g\n          }));\n        }\n\n        Object.keys(c).length ? (a.trigger(o.default.FRAG_PARSING_INIT_SEGMENT, h), this.ISGenerated = !0, v && (this._initPTS = g, this._initDTS = p)) : a.trigger(o.default.ERROR, {\n          type: s.ErrorTypes.MEDIA_ERROR,\n          details: s.ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: !1,\n          reason: \"no audio/video samples found\"\n        });\n      }\n    }, {\n      key: \"remuxVideo\",\n      value: function (e, t, r, a, i) {\n        var u,\n            d,\n            f,\n            c = 8,\n            h = void 0,\n            v = void 0,\n            g = void 0,\n            p = void 0,\n            y = e.timescale,\n            m = e.samples,\n            b = [],\n            E = m.length,\n            _ = this._PTSNormalize,\n            T = this._initPTS,\n            S = this.nextAvcDts,\n            k = this.isSafari;\n\n        if (0 !== E) {\n          k && (r |= m.length && S && (i && Math.abs(t - S / y) < .1 || Math.abs(m[0].pts - S - T) < y / 5)), r || (S = t * y), m.forEach(function (e) {\n            e.pts = _(e.pts - T, S), e.dts = _(e.dts - T, S);\n          }), m.sort(function (e, t) {\n            var r = e.dts - t.dts,\n                a = e.pts - t.pts;\n            return r || a || e.id - t.id;\n          });\n          var R = m.reduce(function (e, t) {\n            return Math.max(Math.min(e, t.pts - t.dts), -18e3);\n          }, 0);\n\n          if (R < 0) {\n            l.logger.warn(\"PTS < DTS detected in video samples, shifting DTS by \" + Math.round(R / 90) + \" ms to overcome this issue\");\n\n            for (var A = 0; A < m.length; A++) m[A].dts += R;\n          }\n\n          var w = m[0];\n          p = Math.max(w.dts, 0), g = Math.max(w.pts, 0);\n          var O = Math.round((p - S) / 90);\n          r && O && (O > 1 ? l.logger.log(\"AVC:\" + O + \" ms hole between fragments detected,filling it\") : O < -1 && l.logger.log(\"AVC:\" + -O + \" ms overlapping between fragments detected\"), p = S, m[0].dts = p, g = Math.max(g - O, S), m[0].pts = g, l.logger.log(\"Video/PTS/DTS adjusted: \" + Math.round(g / 90) + \"/\" + Math.round(p / 90) + \",delta:\" + O + \" ms\")), w = m[m.length - 1], f = Math.max(w.dts, 0), d = Math.max(w.pts, 0, f), k && (h = Math.round((f - p) / (m.length - 1)));\n\n          for (var L = 0, D = 0, P = 0; P < E; P++) {\n            for (var I = m[P], C = I.units, x = C.length, M = 0, F = 0; F < x; F++) M += C[F].data.length;\n\n            D += M, L += x, I.length = M, I.dts = k ? p + P * h : Math.max(I.dts, p), I.pts = Math.max(I.pts, I.dts);\n          }\n\n          var N = D + 4 * L + 8;\n\n          try {\n            v = new Uint8Array(N);\n          } catch (e) {\n            return void this.observer.trigger(o.default.ERROR, {\n              type: s.ErrorTypes.MUX_ERROR,\n              details: s.ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: !1,\n              bytes: N,\n              reason: \"fail allocating video mdat \" + N\n            });\n          }\n\n          var U = new DataView(v.buffer);\n          U.setUint32(0, N), v.set(n.default.types.mdat, 4);\n\n          for (var B = 0; B < E; B++) {\n            for (var G = m[B], j = G.units, K = 0, H = void 0, V = 0, W = j.length; V < W; V++) {\n              var Y = j[V],\n                  q = Y.data,\n                  X = Y.data.byteLength;\n              U.setUint32(c, X), c += 4, v.set(q, c), c += X, K += 4 + X;\n            }\n\n            if (k) H = Math.max(0, h * Math.round((G.pts - G.dts) / h));else {\n              if (B < E - 1) h = m[B + 1].dts - G.dts;else {\n                var z = this.config,\n                    Q = G.dts - m[B > 0 ? B - 1 : B].dts;\n\n                if (z.stretchShortVideoTrack) {\n                  var J = z.maxBufferHole,\n                      $ = Math.floor(J * y),\n                      Z = (a ? g + a * y : this.nextAudioPts) - G.pts;\n                  Z > $ ? ((h = Z - Q) < 0 && (h = Q), l.logger.log(\"It is approximately \" + Z / 90 + \" ms to the next segment; using duration \" + h / 90 + \" ms for the last video frame.\")) : h = Q;\n                } else h = Q;\n              }\n              H = Math.round(G.pts - G.dts);\n            }\n            b.push({\n              size: K,\n              duration: h,\n              cts: H,\n              flags: {\n                isLeading: 0,\n                isDependedOn: 0,\n                hasRedundancy: 0,\n                degradPrio: 0,\n                dependsOn: G.key ? 2 : 1,\n                isNonSync: G.key ? 0 : 1\n              }\n            });\n          }\n\n          this.nextAvcDts = f + h;\n          var ee = e.dropped;\n\n          if (e.len = 0, e.nbNalu = 0, e.dropped = 0, b.length && navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n            var te = b[0].flags;\n            te.dependsOn = 2, te.isNonSync = 0;\n          }\n\n          e.samples = b, u = n.default.moof(e.sequenceNumber++, p, e), e.samples = [];\n          var re = {\n            data1: u,\n            data2: v,\n            startPTS: g / y,\n            endPTS: (d + h) / y,\n            startDTS: p / y,\n            endDTS: this.nextAvcDts / y,\n            type: \"video\",\n            hasAudio: !1,\n            hasVideo: !0,\n            nb: b.length,\n            dropped: ee\n          };\n          return this.observer.trigger(o.default.FRAG_PARSING_DATA, re), re;\n        }\n      }\n    }, {\n      key: \"remuxAudio\",\n      value: function (e, t, r, a) {\n        var u = e.inputTimeScale,\n            d = e.timescale,\n            f = u / d,\n            c = (e.isAAC ? 1024 : 1152) * f,\n            h = this._PTSNormalize,\n            v = this._initPTS,\n            g = !e.isAAC && this.typeSupported.mpeg,\n            p = void 0,\n            y = void 0,\n            m = void 0,\n            b = void 0,\n            E = void 0,\n            _ = void 0,\n            T = void 0,\n            S = e.samples,\n            k = [],\n            R = this.nextAudioPts;\n\n        if (r |= S.length && R && (a && Math.abs(t - R / u) < .1 || Math.abs(S[0].pts - R - v) < 20 * c), S.forEach(function (e) {\n          e.pts = e.dts = h(e.pts - v, t * u);\n        }), 0 !== (S = S.filter(function (e) {\n          return e.pts >= 0;\n        })).length) {\n          if (r || (R = a ? t * u : S[0].pts), e.isAAC) for (var A = this.config.maxAudioFramesDrift, w = 0, O = R; w < S.length;) {\n            var L,\n                D = S[w];\n            L = D.pts - O;\n            var P = Math.abs(1e3 * L / u);\n            if (L <= -A * c) l.logger.warn(\"Dropping 1 audio frame @ \" + (O / u).toFixed(3) + \"s due to \" + Math.round(P) + \" ms overlap.\"), S.splice(w, 1), e.len -= D.unit.length;else if (L >= A * c && P < 1e4 && O) {\n              var I = Math.round(L / c);\n              l.logger.warn(\"Injecting \" + I + \" audio frame @ \" + (O / u).toFixed(3) + \"s due to \" + Math.round(1e3 * L / u) + \" ms gap.\");\n\n              for (var C = 0; C < I; C++) {\n                var x = Math.max(O, 0);\n                (m = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (l.logger.log(\"Unable to get silent frame for given audio codec; duplicating last frame instead.\"), m = D.unit.subarray()), S.splice(w, 0, {\n                  unit: m,\n                  pts: x,\n                  dts: x\n                }), e.len += m.length, O += c, w++;\n              }\n\n              D.pts = D.dts = O, O += c, w++;\n            } else Math.abs(L), D.pts = D.dts = O, O += c, w++;\n          }\n\n          for (var M = 0, F = S.length; M < F; M++) {\n            var N = S[M],\n                U = N.unit,\n                B = N.pts;\n            if (void 0 !== T) y.duration = Math.round((B - T) / f);else {\n              var G = Math.round(1e3 * (B - R) / u),\n                  j = 0;\n\n              if (r && e.isAAC && G) {\n                if (G > 0 && G < 1e4) j = Math.round((B - R) / c), l.logger.log(G + \" ms hole between AAC samples detected,filling it\"), j > 0 && ((m = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (m = U.subarray()), e.len += j * m.length);else if (G < -12) {\n                  l.logger.log(\"drop overlapping AAC sample, expected/parsed/delta:\" + (R / u).toFixed(3) + \"s/\" + (B / u).toFixed(3) + \"s/\" + -G + \"ms\"), e.len -= U.byteLength;\n                  continue;\n                }\n                B = R;\n              }\n\n              if (_ = B, !(e.len > 0)) return;\n              var K = g ? e.len : e.len + 8;\n              p = g ? 0 : 8;\n\n              try {\n                b = new Uint8Array(K);\n              } catch (e) {\n                return void this.observer.trigger(o.default.ERROR, {\n                  type: s.ErrorTypes.MUX_ERROR,\n                  details: s.ErrorDetails.REMUX_ALLOC_ERROR,\n                  fatal: !1,\n                  bytes: K,\n                  reason: \"fail allocating audio mdat \" + K\n                });\n              }\n\n              g || (new DataView(b.buffer).setUint32(0, K), b.set(n.default.types.mdat, 4));\n\n              for (var H = 0; H < j; H++) (m = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (l.logger.log(\"Unable to get silent frame for given audio codec; duplicating this frame instead.\"), m = U.subarray()), b.set(m, p), p += m.byteLength, y = {\n                size: m.byteLength,\n                cts: 0,\n                duration: 1024,\n                flags: {\n                  isLeading: 0,\n                  isDependedOn: 0,\n                  hasRedundancy: 0,\n                  degradPrio: 0,\n                  dependsOn: 1\n                }\n              }, k.push(y);\n            }\n            b.set(U, p);\n            var V = U.byteLength;\n            p += V, y = {\n              size: V,\n              cts: 0,\n              duration: 0,\n              flags: {\n                isLeading: 0,\n                isDependedOn: 0,\n                hasRedundancy: 0,\n                degradPrio: 0,\n                dependsOn: 1\n              }\n            }, k.push(y), T = B;\n          }\n\n          var W = 0,\n              Y = k.length;\n\n          if (Y >= 2 && (W = k[Y - 2].duration, y.duration = W), Y) {\n            this.nextAudioPts = R = T + f * W, e.len = 0, e.samples = k, E = g ? new Uint8Array() : n.default.moof(e.sequenceNumber++, _ / f, e), e.samples = [];\n            var q = _ / u,\n                X = R / u,\n                z = {\n              data1: E,\n              data2: b,\n              startPTS: q,\n              endPTS: X,\n              startDTS: q,\n              endDTS: X,\n              type: \"audio\",\n              hasAudio: !0,\n              hasVideo: !1,\n              nb: Y\n            };\n            return this.observer.trigger(o.default.FRAG_PARSING_DATA, z), z;\n          }\n\n          return null;\n        }\n      }\n    }, {\n      key: \"remuxEmptyAudio\",\n      value: function (e, t, r, a) {\n        var n = e.inputTimeScale,\n            o = n / (e.samplerate ? e.samplerate : n),\n            s = this.nextAudioPts,\n            u = (void 0 !== s ? s : a.startDTS * n) + this._initDTS,\n            d = a.endDTS * n + this._initDTS,\n            f = 1024 * o,\n            c = Math.ceil((d - u) / f),\n            h = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);\n\n        if (l.logger.warn(\"remux empty Audio\"), h) {\n          for (var v = [], g = 0; g < c; g++) {\n            var p = u + g * f;\n            v.push({\n              unit: h,\n              pts: p,\n              dts: p\n            }), e.len += h.length;\n          }\n\n          e.samples = v, this.remuxAudio(e, t, r);\n        } else l.logger.trace(\"Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!\");\n      }\n    }, {\n      key: \"remuxID3\",\n      value: function (e) {\n        var t = e.samples.length,\n            r = void 0,\n            a = e.inputTimeScale,\n            i = this._initPTS,\n            n = this._initDTS;\n\n        if (t) {\n          for (var s = 0; s < t; s++) (r = e.samples[s]).pts = (r.pts - i) / a, r.dts = (r.dts - n) / a;\n\n          this.observer.trigger(o.default.FRAG_PARSING_METADATA, {\n            samples: e.samples\n          });\n        }\n\n        e.samples = [];\n      }\n    }, {\n      key: \"remuxText\",\n      value: function (e) {\n        e.samples.sort(function (e, t) {\n          return e.pts - t.pts;\n        });\n        var t = e.samples.length,\n            r = void 0,\n            a = e.inputTimeScale,\n            i = this._initPTS;\n\n        if (t) {\n          for (var n = 0; n < t; n++) (r = e.samples[n]).pts = (r.pts - i) / a;\n\n          this.observer.trigger(o.default.FRAG_PARSING_USERDATA, {\n            samples: e.samples\n          });\n        }\n\n        e.samples = [];\n      }\n    }, {\n      key: \"_PTSNormalize\",\n      value: function (e, t) {\n        var r = void 0;\n        if (void 0 === t) return e;\n\n        for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += r;\n\n        return e;\n      }\n    }]), e;\n  }();\n\n  t.default = d, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n    }\n\n    return a(e, null, [{\n      key: \"getSilentFrame\",\n      value: function (e, t) {\n        switch (e) {\n          case \"mp4a.40.2\":\n            if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);\n            if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);\n            if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);\n            if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);\n            if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);\n            if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);\n            break;\n\n          default:\n            if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        }\n\n        return null;\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = Math.pow(2, 32) - 1,\n      n = function () {\n    function e() {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n    }\n\n    return a(e, null, [{\n      key: \"init\",\n      value: function () {\n        e.types = {\n          avc1: [],\n          avcC: [],\n          btrt: [],\n          dinf: [],\n          dref: [],\n          esds: [],\n          ftyp: [],\n          hdlr: [],\n          mdat: [],\n          mdhd: [],\n          mdia: [],\n          mfhd: [],\n          minf: [],\n          moof: [],\n          moov: [],\n          mp4a: [],\n          \".mp3\": [],\n          mvex: [],\n          mvhd: [],\n          pasp: [],\n          sdtp: [],\n          stbl: [],\n          stco: [],\n          stsc: [],\n          stsd: [],\n          stsz: [],\n          stts: [],\n          tfdt: [],\n          tfhd: [],\n          traf: [],\n          trak: [],\n          trun: [],\n          trex: [],\n          tkhd: [],\n          vmhd: [],\n          smhd: []\n        };\n        var t = void 0;\n\n        for (t in e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);\n\n        var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),\n            a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);\n        e.HDLR_TYPES = {\n          video: r,\n          audio: a\n        };\n        var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),\n            n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);\n        e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);\n        var o = new Uint8Array([105, 115, 111, 109]),\n            s = new Uint8Array([97, 118, 99, 49]),\n            l = new Uint8Array([0, 0, 0, 1]);\n        e.FTYP = e.box(e.types.ftyp, o, l, o, s), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, i));\n      }\n    }, {\n      key: \"box\",\n      value: function (e) {\n        for (var t = Array.prototype.slice.call(arguments, 1), r = 8, a = t.length, i = a, n = void 0; a--;) r += t[a].byteLength;\n\n        for ((n = new Uint8Array(r))[0] = r >> 24 & 255, n[1] = r >> 16 & 255, n[2] = r >> 8 & 255, n[3] = 255 & r, n.set(e, 4), a = 0, r = 8; a < i; a++) n.set(t[a], r), r += t[a].byteLength;\n\n        return n;\n      }\n    }, {\n      key: \"hdlr\",\n      value: function (t) {\n        return e.box(e.types.hdlr, e.HDLR_TYPES[t]);\n      }\n    }, {\n      key: \"mdat\",\n      value: function (t) {\n        return e.box(e.types.mdat, t);\n      }\n    }, {\n      key: \"mdhd\",\n      value: function (t, r) {\n        r *= t;\n        var a = Math.floor(r / (i + 1)),\n            n = Math.floor(r % (i + 1));\n        return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 85, 196, 0, 0]));\n      }\n    }, {\n      key: \"mdia\",\n      value: function (t) {\n        return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t));\n      }\n    }, {\n      key: \"mfhd\",\n      value: function (t) {\n        return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]));\n      }\n    }, {\n      key: \"minf\",\n      value: function (t) {\n        return \"audio\" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t));\n      }\n    }, {\n      key: \"moof\",\n      value: function (t, r, a) {\n        return e.box(e.types.moof, e.mfhd(t), e.traf(a, r));\n      }\n    }, {\n      key: \"moov\",\n      value: function (t) {\n        for (var r = t.length, a = []; r--;) a[r] = e.trak(t[r]);\n\n        return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(a).concat(e.mvex(t)));\n      }\n    }, {\n      key: \"mvex\",\n      value: function (t) {\n        for (var r = t.length, a = []; r--;) a[r] = e.trex(t[r]);\n\n        return e.box.apply(null, [e.types.mvex].concat(a));\n      }\n    }, {\n      key: \"mvhd\",\n      value: function (t, r) {\n        r *= t;\n        var a = Math.floor(r / (i + 1)),\n            n = Math.floor(r % (i + 1)),\n            o = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);\n        return e.box(e.types.mvhd, o);\n      }\n    }, {\n      key: \"sdtp\",\n      value: function (t) {\n        var r = t.samples || [],\n            a = new Uint8Array(4 + r.length),\n            i = void 0,\n            n = void 0;\n\n        for (n = 0; n < r.length; n++) i = r[n].flags, a[n + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;\n\n        return e.box(e.types.sdtp, a);\n      }\n    }, {\n      key: \"stbl\",\n      value: function (t) {\n        return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO));\n      }\n    }, {\n      key: \"avc1\",\n      value: function (t) {\n        var r = [],\n            a = [],\n            i = void 0,\n            n = void 0,\n            o = void 0;\n\n        for (i = 0; i < t.sps.length; i++) o = (n = t.sps[i]).byteLength, r.push(o >>> 8 & 255), r.push(255 & o), r = r.concat(Array.prototype.slice.call(n));\n\n        for (i = 0; i < t.pps.length; i++) o = (n = t.pps[i]).byteLength, a.push(o >>> 8 & 255), a.push(255 & o), a = a.concat(Array.prototype.slice.call(n));\n\n        var s = e.box(e.types.avcC, new Uint8Array([1, r[3], r[4], r[5], 255, 224 | t.sps.length].concat(r).concat([t.pps.length]).concat(a))),\n            l = t.width,\n            u = t.height,\n            d = t.pixelRatio[0],\n            f = t.pixelRatio[1];\n        return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), s, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, f >> 24, f >> 16 & 255, f >> 8 & 255, 255 & f])));\n      }\n    }, {\n      key: \"esds\",\n      value: function (e) {\n        var t = e.config.length;\n        return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]));\n      }\n    }, {\n      key: \"mp4a\",\n      value: function (t) {\n        var r = t.samplerate;\n        return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)));\n      }\n    }, {\n      key: \"mp3\",\n      value: function (t) {\n        var r = t.samplerate;\n        return e.box(e.types[\".mp3\"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]));\n      }\n    }, {\n      key: \"stsd\",\n      value: function (t) {\n        return \"audio\" === t.type ? t.isAAC || \"mp3\" !== t.codec ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t));\n      }\n    }, {\n      key: \"tkhd\",\n      value: function (t) {\n        var r = t.id,\n            a = t.duration * t.timescale,\n            n = t.width,\n            o = t.height,\n            s = Math.floor(a / (i + 1)),\n            l = Math.floor(a % (i + 1));\n        return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, l >> 24, l >> 16 & 255, l >> 8 & 255, 255 & l, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, n >> 8 & 255, 255 & n, 0, 0, o >> 8 & 255, 255 & o, 0, 0]));\n      }\n    }, {\n      key: \"traf\",\n      value: function (t, r) {\n        var a = e.sdtp(t),\n            n = t.id,\n            o = Math.floor(r / (i + 1)),\n            s = Math.floor(r % (i + 1));\n        return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.trun(t, a.length + 16 + 20 + 8 + 16 + 8 + 8), a);\n      }\n    }, {\n      key: \"trak\",\n      value: function (t) {\n        return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t));\n      }\n    }, {\n      key: \"trex\",\n      value: function (t) {\n        var r = t.id;\n        return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));\n      }\n    }, {\n      key: \"trun\",\n      value: function (t, r) {\n        var a = t.samples || [],\n            i = a.length,\n            n = 12 + 16 * i,\n            o = new Uint8Array(n),\n            s = void 0,\n            l = void 0,\n            u = void 0,\n            d = void 0,\n            f = void 0,\n            c = void 0;\n\n        for (r += 8 + n, o.set([0, 0, 15, 1, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), s = 0; s < i; s++) u = (l = a[s]).duration, d = l.size, f = l.flags, c = l.cts, o.set([u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, f.isLeading << 2 | f.dependsOn, f.isDependedOn << 6 | f.hasRedundancy << 4 | f.paddingValue << 1 | f.isNonSync, 61440 & f.degradPrio, 15 & f.degradPrio, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c], 12 + 16 * s);\n\n        return e.box(e.types.trun, o);\n      }\n    }, {\n      key: \"initSegment\",\n      value: function (t) {\n        e.types || e.init();\n        var r = e.moov(t),\n            a = void 0;\n        return (a = new Uint8Array(e.FTYP.byteLength + r.byteLength)).set(e.FTYP), a.set(r, e.FTYP.byteLength), a;\n      }\n    }]), e;\n  }();\n\n  t.default = n, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(1),\n      o = (a = n) && a.__esModule ? a : {\n    default: a\n  };\n\n  var s = function () {\n    function e(t) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.observer = t;\n    }\n\n    return i(e, [{\n      key: \"destroy\",\n      value: function () {}\n    }, {\n      key: \"resetTimeStamp\",\n      value: function () {}\n    }, {\n      key: \"resetInitSegment\",\n      value: function () {}\n    }, {\n      key: \"remux\",\n      value: function (e, t, r, a, i, n, s, l) {\n        var u = this.observer,\n            d = \"\";\n        e && (d += \"audio\"), t && (d += \"video\"), u.trigger(o.default.FRAG_PARSING_DATA, {\n          data1: l,\n          startPTS: i,\n          startDTS: i,\n          type: d,\n          hasAudio: !!e,\n          hasVideo: !!t,\n          nb: 1,\n          dropped: 0\n        }), u.trigger(o.default.FRAG_PARSED);\n      }\n    }]), e;\n  }();\n\n  t.default = s, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  var a = Object.prototype.hasOwnProperty,\n      i = \"~\";\n\n  function n() {}\n\n  function o(e, t, r) {\n    this.fn = e, this.context = t, this.once = r || !1;\n  }\n\n  function s(e, t, r, a, n) {\n    if (\"function\" != typeof r) throw new TypeError(\"The listener must be a function\");\n    var s = new o(r, a || e, n),\n        l = i ? i + t : t;\n    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], s] : e._events[l].push(s) : (e._events[l] = s, e._eventsCount++), e;\n  }\n\n  function l(e, t) {\n    0 == --e._eventsCount ? e._events = new n() : delete e._events[t];\n  }\n\n  function u() {\n    this._events = new n(), this._eventsCount = 0;\n  }\n\n  Object.create && (n.prototype = Object.create(null), new n().__proto__ || (i = !1)), u.prototype.eventNames = function () {\n    var e,\n        t,\n        r = [];\n    if (0 === this._eventsCount) return r;\n\n    for (t in e = this._events) a.call(e, t) && r.push(i ? t.slice(1) : t);\n\n    return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r;\n  }, u.prototype.listeners = function (e) {\n    var t = i ? i + e : e,\n        r = this._events[t];\n    if (!r) return [];\n    if (r.fn) return [r.fn];\n\n    for (var a = 0, n = r.length, o = new Array(n); a < n; a++) o[a] = r[a].fn;\n\n    return o;\n  }, u.prototype.listenerCount = function (e) {\n    var t = i ? i + e : e,\n        r = this._events[t];\n    return r ? r.fn ? 1 : r.length : 0;\n  }, u.prototype.emit = function (e, t, r, a, n, o) {\n    var s = i ? i + e : e;\n    if (!this._events[s]) return !1;\n    var l,\n        u,\n        d = this._events[s],\n        f = arguments.length;\n\n    if (d.fn) {\n      switch (d.once && this.removeListener(e, d.fn, void 0, !0), f) {\n        case 1:\n          return d.fn.call(d.context), !0;\n\n        case 2:\n          return d.fn.call(d.context, t), !0;\n\n        case 3:\n          return d.fn.call(d.context, t, r), !0;\n\n        case 4:\n          return d.fn.call(d.context, t, r, a), !0;\n\n        case 5:\n          return d.fn.call(d.context, t, r, a, n), !0;\n\n        case 6:\n          return d.fn.call(d.context, t, r, a, n, o), !0;\n      }\n\n      for (u = 1, l = new Array(f - 1); u < f; u++) l[u - 1] = arguments[u];\n\n      d.fn.apply(d.context, l);\n    } else {\n      var c,\n          h = d.length;\n\n      for (u = 0; u < h; u++) switch (d[u].once && this.removeListener(e, d[u].fn, void 0, !0), f) {\n        case 1:\n          d[u].fn.call(d[u].context);\n          break;\n\n        case 2:\n          d[u].fn.call(d[u].context, t);\n          break;\n\n        case 3:\n          d[u].fn.call(d[u].context, t, r);\n          break;\n\n        case 4:\n          d[u].fn.call(d[u].context, t, r, a);\n          break;\n\n        default:\n          if (!l) for (c = 1, l = new Array(f - 1); c < f; c++) l[c - 1] = arguments[c];\n          d[u].fn.apply(d[u].context, l);\n      }\n    }\n\n    return !0;\n  }, u.prototype.on = function (e, t, r) {\n    return s(this, e, t, r, !1);\n  }, u.prototype.once = function (e, t, r) {\n    return s(this, e, t, r, !0);\n  }, u.prototype.removeListener = function (e, t, r, a) {\n    var n = i ? i + e : e;\n    if (!this._events[n]) return this;\n    if (!t) return l(this, n), this;\n    var o = this._events[n];\n    if (o.fn) o.fn !== t || a && !o.once || r && o.context !== r || l(this, n);else {\n      for (var s = 0, u = [], d = o.length; s < d; s++) (o[s].fn !== t || a && !o[s].once || r && o[s].context !== r) && u.push(o[s]);\n\n      u.length ? this._events[n] = 1 === u.length ? u[0] : u : l(this, n);\n    }\n    return this;\n  }, u.prototype.removeAllListeners = function (e) {\n    var t;\n    return e ? (t = i ? i + e : e, this._events[t] && l(this, t)) : (this._events = new n(), this._eventsCount = 0), this;\n  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = i, u.EventEmitter = u, e.exports = u;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = s(r(21)),\n      i = s(r(1)),\n      n = r(0),\n      o = r(20);\n\n  function s(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  t.default = function (e) {\n    var t = new o.EventEmitter();\n    t.trigger = function (e) {\n      for (var r = arguments.length, a = Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) a[i - 1] = arguments[i];\n\n      t.emit.apply(t, [e, e].concat(a));\n    }, t.off = function (e) {\n      for (var r = arguments.length, a = Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) a[i - 1] = arguments[i];\n\n      t.removeListener.apply(t, [e].concat(a));\n    };\n\n    var r = function (t, r) {\n      e.postMessage({\n        event: t,\n        data: r\n      });\n    };\n\n    e.addEventListener(\"message\", function (i) {\n      var o = i.data;\n\n      switch (o.cmd) {\n        case \"init\":\n          var s = JSON.parse(o.config);\n          e.demuxer = new a.default(t, o.typeSupported, s, o.vendor), (0, n.enableLogs)(s.debug), r(\"init\", null);\n          break;\n\n        case \"demux\":\n          e.demuxer.push(o.data, o.decryptdata, o.initSegment, o.audioCodec, o.videoCodec, o.timeOffset, o.discontinuity, o.trackSwitch, o.contiguous, o.duration, o.accurateTimeOffset, o.defaultInitPTS);\n      }\n    }), t.on(i.default.FRAG_DECRYPTED, r), t.on(i.default.FRAG_PARSING_INIT_SEGMENT, r), t.on(i.default.FRAG_PARSED, r), t.on(i.default.ERROR, r), t.on(i.default.FRAG_PARSING_METADATA, r), t.on(i.default.FRAG_PARSING_USERDATA, r), t.on(i.default.INIT_PTS_FOUND, r), t.on(i.default.FRAG_PARSING_DATA, function (t, r) {\n      var a = [],\n          i = {\n        event: t,\n        data: r\n      };\n      r.data1 && (i.data1 = r.data1.buffer, a.push(r.data1.buffer), delete r.data1), r.data2 && (i.data2 = r.data2.buffer, a.push(r.data2.buffer), delete r.data2), e.postMessage(i, a);\n    });\n  }, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(4),\n      o = r(2),\n      s = r(1),\n      l = (a = s) && a.__esModule ? a : {\n    default: a\n  },\n      u = r(0);\n\n  var d = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.config = t, this.media = r, this.fragmentTracker = a, this.hls = i, this.stallReported = !1;\n    }\n\n    return i(e, [{\n      key: \"poll\",\n      value: function (e, t) {\n        var r = this.config,\n            a = this.media,\n            i = a.currentTime,\n            o = window.performance.now();\n        if (i !== e) return this.stallReported && (u.logger.warn(\"playback not stuck anymore @\" + i + \", after \" + Math.round(o - this.stalled) + \"ms\"), this.stallReported = !1), this.stalled = null, void (this.nudgeRetry = 0);\n\n        if (!(a.ended || !a.buffered.length || a.readyState > 2 || a.seeking && n.BufferHelper.isBuffered(a, i))) {\n          var s = o - this.stalled,\n              l = n.BufferHelper.bufferInfo(a, i, r.maxBufferHole);\n          this.stalled ? (s >= 1e3 && this._reportStall(l.len), this._tryFixBufferStall(l, s)) : this.stalled = o;\n        }\n      }\n    }, {\n      key: \"_tryFixBufferStall\",\n      value: function (e, t) {\n        var r = this.config,\n            a = this.fragmentTracker,\n            i = this.media.currentTime,\n            n = a.getPartialFragment(i);\n        n && this._trySkipBufferHole(n), e.len > .5 && t > 1e3 * r.highBufferWatchdogPeriod && (this.stalled = null, this._tryNudgeBuffer());\n      }\n    }, {\n      key: \"_reportStall\",\n      value: function (e) {\n        var t = this.hls,\n            r = this.media;\n        this.stallReported || (this.stallReported = !0, u.logger.warn(\"Playback stalling at @\" + r.currentTime + \" due to low buffer\"), t.trigger(l.default.ERROR, {\n          type: o.ErrorTypes.MEDIA_ERROR,\n          details: o.ErrorDetails.BUFFER_STALLED_ERROR,\n          fatal: !1,\n          buffer: e\n        }));\n      }\n    }, {\n      key: \"_trySkipBufferHole\",\n      value: function (e) {\n        for (var t = this.hls, r = this.media, a = r.currentTime, i = 0, n = 0; n < r.buffered.length; n++) {\n          var s = r.buffered.start(n);\n          if (a >= i && a < s) return r.currentTime = Math.max(s, r.currentTime + .1), u.logger.warn(\"skipping hole, adjusting currentTime from \" + a + \" to \" + r.currentTime), this.stalled = null, void t.trigger(l.default.ERROR, {\n            type: o.ErrorTypes.MEDIA_ERROR,\n            details: o.ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: !1,\n            reason: \"fragment loaded with buffer holes, seeking from \" + a + \" to \" + r.currentTime,\n            frag: e\n          });\n          i = r.buffered.end(n);\n        }\n      }\n    }, {\n      key: \"_tryNudgeBuffer\",\n      value: function () {\n        var e = this.config,\n            t = this.hls,\n            r = this.media,\n            a = r.currentTime,\n            i = (this.nudgeRetry || 0) + 1;\n\n        if (this.nudgeRetry = i, i < e.nudgeMaxRetry) {\n          var n = a + i * e.nudgeOffset;\n          u.logger.log(\"adjust currentTime from \" + a + \" to \" + n), r.currentTime = n, t.trigger(l.default.ERROR, {\n            type: o.ErrorTypes.MEDIA_ERROR,\n            details: o.ErrorDetails.BUFFER_NUDGE_ON_STALL,\n            fatal: !1\n          });\n        } else u.logger.error(\"still stuck in high buffer @\" + a + \" after \" + e.nudgeMaxRetry + \", raise fatal error\"), t.trigger(l.default.ERROR, {\n          type: o.ErrorTypes.MEDIA_ERROR,\n          details: o.ErrorDetails.BUFFER_STALLED_ERROR,\n          fatal: !0\n        });\n      }\n    }]), e;\n  }();\n\n  t.default = d, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  },\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = f(r(1)),\n      o = f(r(3)),\n      s = r(0),\n      l = r(2),\n      u = r(18),\n      d = r(7);\n\n  function f(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  window.performance;\n\n  var c = void 0,\n      h = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n.default.MANIFEST_LOADED, n.default.LEVEL_LOADED, n.default.AUDIO_TRACK_SWITCHED, n.default.FRAG_LOADED, n.default.ERROR));\n\n      return r.canload = !1, r.currentLevelIndex = null, r.manualLevelIndex = -1, r.timer = null, c = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), i(t, [{\n      key: \"onHandlerDestroying\",\n      value: function () {\n        this.clearTimer(), this.manualLevelIndex = -1;\n      }\n    }, {\n      key: \"clearTimer\",\n      value: function () {\n        null !== this.timer && (clearTimeout(this.timer), this.timer = null);\n      }\n    }, {\n      key: \"startLoad\",\n      value: function () {\n        var e = this._levels;\n        this.canload = !0, this.levelRetryCount = 0, e && e.forEach(function (e) {\n          e.loadError = 0;\n          var t = e.details;\n          t && t.live && (e.details = void 0);\n        }), null !== this.timer && this.loadLevel();\n      }\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        this.canload = !1;\n      }\n    }, {\n      key: \"onManifestLoaded\",\n      value: function (e) {\n        var t = [],\n            r = [],\n            a = void 0,\n            i = {},\n            o = null,\n            f = !1,\n            h = !1;\n\n        if (e.levels.forEach(function (e) {\n          var r = e.attrs;\n          e.loadError = 0, e.fragmentError = !1, f = f || !!e.videoCodec, h = h || !!e.audioCodec, c && e.audioCodec && -1 !== e.audioCodec.indexOf(\"mp4a.40.34\") && (e.audioCodec = void 0), (o = i[e.bitrate]) ? o.url.push(e.url) : (e.url = [e.url], e.urlId = 0, i[e.bitrate] = e, t.push(e)), r && (r.AUDIO && (h = !0, (0, d.addGroupId)(o || e, \"audio\", r.AUDIO)), r.SUBTITLES && (0, d.addGroupId)(o || e, \"text\", r.SUBTITLES));\n        }), f && h && (t = t.filter(function (e) {\n          return !!e.videoCodec;\n        })), t = t.filter(function (e) {\n          var t = e.audioCodec,\n              r = e.videoCodec;\n          return (!t || (0, u.isCodecSupportedInMp4)(t, \"audio\")) && (!r || (0, u.isCodecSupportedInMp4)(r, \"video\"));\n        }), e.audioTracks && (r = e.audioTracks.filter(function (e) {\n          return !e.audioCodec || (0, u.isCodecSupportedInMp4)(e.audioCodec, \"audio\");\n        })).forEach(function (e, t) {\n          e.id = t;\n        }), t.length > 0) {\n          a = t[0].bitrate, t.sort(function (e, t) {\n            return e.bitrate - t.bitrate;\n          }), this._levels = t;\n\n          for (var v = 0; v < t.length; v++) if (t[v].bitrate === a) {\n            this._firstLevel = v, s.logger.log(\"manifest loaded,\" + t.length + \" level(s) found, first bitrate:\" + a);\n            break;\n          }\n\n          this.hls.trigger(n.default.MANIFEST_PARSED, {\n            levels: t,\n            audioTracks: r,\n            firstLevel: this._firstLevel,\n            stats: e.stats,\n            audio: h,\n            video: f,\n            altAudio: r.some(function (e) {\n              return !!e.url;\n            })\n          });\n        } else this.hls.trigger(n.default.ERROR, {\n          type: l.ErrorTypes.MEDIA_ERROR,\n          details: l.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n          fatal: !0,\n          url: this.hls.url,\n          reason: \"no level with compatible codecs found in manifest\"\n        });\n      }\n    }, {\n      key: \"setLevelInternal\",\n      value: function (e) {\n        var t = this._levels,\n            r = this.hls;\n\n        if (e >= 0 && e < t.length) {\n          if (this.clearTimer(), this.currentLevelIndex !== e) {\n            s.logger.log(\"switching to level \" + e), this.currentLevelIndex = e;\n            var a = t[e];\n            a.level = e, r.trigger(n.default.LEVEL_SWITCHING, a);\n          }\n\n          var i = t[e],\n              o = i.details;\n\n          if (!o || o.live) {\n            var u = i.urlId;\n            r.trigger(n.default.LEVEL_LOADING, {\n              url: i.url[u],\n              level: e,\n              id: u\n            });\n          }\n        } else r.trigger(n.default.ERROR, {\n          type: l.ErrorTypes.OTHER_ERROR,\n          details: l.ErrorDetails.LEVEL_SWITCH_ERROR,\n          level: e,\n          fatal: !1,\n          reason: \"invalid level idx\"\n        });\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        if (e.fatal) e.type === l.ErrorTypes.NETWORK_ERROR && this.clearTimer();else {\n          var t = !1,\n              r = !1,\n              a = void 0;\n\n          switch (e.details) {\n            case l.ErrorDetails.FRAG_LOAD_ERROR:\n            case l.ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case l.ErrorDetails.KEY_LOAD_ERROR:\n            case l.ErrorDetails.KEY_LOAD_TIMEOUT:\n              a = e.frag.level, r = !0;\n              break;\n\n            case l.ErrorDetails.LEVEL_LOAD_ERROR:\n            case l.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n              a = e.context.level, t = !0;\n              break;\n\n            case l.ErrorDetails.REMUX_ALLOC_ERROR:\n              a = e.level, t = !0;\n          }\n\n          void 0 !== a && this.recoverLevel(e, a, t, r);\n        }\n      }\n    }, {\n      key: \"recoverLevel\",\n      value: function (e, t, r, a) {\n        var i = this,\n            n = this.hls.config,\n            o = e.details,\n            l = this._levels[t],\n            u = void 0,\n            d = void 0,\n            f = void 0;\n\n        if (l.loadError++, l.fragmentError = a, r) {\n          if (!(this.levelRetryCount + 1 <= n.levelLoadingMaxRetry)) return s.logger.error(\"level controller, cannot recover from \" + o + \" error\"), this.currentLevelIndex = null, this.clearTimer(), void (e.fatal = !0);\n          d = Math.min(Math.pow(2, this.levelRetryCount) * n.levelLoadingRetryDelay, n.levelLoadingMaxRetryTimeout), this.timer = setTimeout(function () {\n            return i.loadLevel();\n          }, d), e.levelRetry = !0, this.levelRetryCount++, s.logger.warn(\"level controller, \" + o + \", retry in \" + d + \" ms, current retry count is \" + this.levelRetryCount);\n        }\n\n        (r || a) && ((u = l.url.length) > 1 && l.loadError < u ? (l.urlId = (l.urlId + 1) % u, l.details = void 0, s.logger.warn(\"level controller, \" + o + \" for level \" + t + \": switching to redundant URL-id \" + l.urlId)) : -1 === this.manualLevelIndex ? (f = 0 === t ? this._levels.length - 1 : t - 1, s.logger.warn(\"level controller, \" + o + \": switch to \" + f), this.hls.nextAutoLevel = this.currentLevelIndex = f) : a && (s.logger.warn(\"level controller, \" + o + \": reload a fragment\"), this.currentLevelIndex = null));\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = e.frag;\n\n        if (void 0 !== t && \"main\" === t.type) {\n          var r = this._levels[t.level];\n          void 0 !== r && (r.fragmentError = !1, r.loadError = 0, this.levelRetryCount = 0);\n        }\n      }\n    }, {\n      key: \"onLevelLoaded\",\n      value: function (e) {\n        var t = this,\n            r = e.level,\n            a = e.details;\n\n        if (r === this.currentLevelIndex) {\n          var i = this._levels[r];\n\n          if (i.fragmentError || (i.loadError = 0, this.levelRetryCount = 0), a.live) {\n            var n = (0, d.computeReloadInterval)(i.details, a, e.stats.trequest);\n            s.logger.log(\"live playlist, reload in \" + Math.round(n) + \" ms\"), this.timer = setTimeout(function () {\n              return t.loadLevel();\n            }, n);\n          } else this.clearTimer();\n        }\n      }\n    }, {\n      key: \"onAudioTrackSwitched\",\n      value: function (e) {\n        var t = this.hls.audioTracks[e.id].groupId,\n            r = this.hls.levels[this.currentLevelIndex];\n\n        if (r && r.audioGroupIds) {\n          for (var a = -1, i = 0; i < r.audioGroupIds.length; i++) if (r.audioGroupIds[i] === t) {\n            a = i;\n            break;\n          }\n\n          a !== r.urlId && (r.urlId = a, this.startLoad());\n        }\n      }\n    }, {\n      key: \"loadLevel\",\n      value: function () {\n        if (s.logger.debug(\"call to loadLevel\"), null !== this.currentLevelIndex && this.canload) {\n          var e = this._levels[this.currentLevelIndex];\n\n          if (\"object\" === (void 0 === e ? \"undefined\" : a(e)) && e.url.length > 0) {\n            var t = this.currentLevelIndex,\n                r = e.urlId,\n                i = e.url[r];\n            s.logger.log(\"Attempt loading level index \" + t + \" with URL-id \" + r), this.hls.trigger(n.default.LEVEL_LOADING, {\n              url: i,\n              level: t,\n              id: r\n            });\n          }\n        }\n      }\n    }, {\n      key: \"levels\",\n      get: function () {\n        return this._levels;\n      }\n    }, {\n      key: \"level\",\n      get: function () {\n        return this.currentLevelIndex;\n      },\n      set: function (e) {\n        var t = this._levels;\n        t && (e = Math.min(e, t.length - 1), this.currentLevelIndex === e && t[e].details || this.setLevelInternal(e));\n      }\n    }, {\n      key: \"manualLevel\",\n      get: function () {\n        return this.manualLevelIndex;\n      },\n      set: function (e) {\n        this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e);\n      }\n    }, {\n      key: \"firstLevel\",\n      get: function () {\n        return this._firstLevel;\n      },\n      set: function (e) {\n        this._firstLevel = e;\n      }\n    }, {\n      key: \"startLevel\",\n      get: function () {\n        if (void 0 === this._startLevel) {\n          var e = this.hls.config.startLevel;\n          return void 0 !== e ? e : this._firstLevel;\n        }\n\n        return this._startLevel;\n      },\n      set: function (e) {\n        this._startLevel = e;\n      }\n    }, {\n      key: \"nextLoadLevel\",\n      get: function () {\n        return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel;\n      },\n      set: function (e) {\n        this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e);\n      }\n    }]), t;\n  }(o.default);\n\n  t.default = h, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(3)),\n      o = l(r(10)),\n      s = r(29);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHED, i.default.MEDIA_DETACHING, i.default.FRAG_PARSING_METADATA));\n\n      return r.id3Track = void 0, r.media = void 0, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        this.media = e.media, this.media;\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        (0, s.clearCurrentCues)(this.id3Track), this.id3Track = void 0, this.media = void 0;\n      }\n    }, {\n      key: \"getID3Track\",\n      value: function (e) {\n        for (var t = 0; t < e.length; t++) {\n          var r = e[t];\n          if (\"metadata\" === r.kind && \"id3\" === r.label) return (0, s.sendAddTrackEvent)(r, this.media), r;\n        }\n\n        return this.media.addTextTrack(\"metadata\", \"id3\");\n      }\n    }, {\n      key: \"onFragParsingMetadata\",\n      value: function (e) {\n        var t = e.frag,\n            r = e.samples;\n        this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = \"hidden\");\n\n        for (var a = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, i = 0; i < r.length; i++) {\n          var n = o.default.getID3Frames(r[i].data);\n\n          if (n) {\n            var s = r[i].pts,\n                l = i < r.length - 1 ? r[i + 1].pts : t.endPTS;\n            s === l && (l += 1e-4);\n\n            for (var u = 0; u < n.length; u++) {\n              var d = n[u];\n\n              if (!o.default.isTimeStampFrame(d)) {\n                var f = new a(s, l, \"\");\n                f.value = d, this.id3Track.addCue(f);\n              }\n            }\n          }\n        }\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.isSupported = function () {\n    var e = (0, a.getMediaSource)(),\n        t = window.SourceBuffer || window.WebKitSourceBuffer,\n        r = e && \"function\" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"'),\n        i = !t || t.prototype && \"function\" == typeof t.prototype.appendBuffer && \"function\" == typeof t.prototype.remove;\n    return !!r && !!i;\n  };\n  var a = r(13);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.hlsDefaultConfig = void 0;\n\n  var a = p(r(61)),\n      i = p(r(64)),\n      n = p(r(65)),\n      o = p(r(66)),\n      s = p(r(67)),\n      l = p(r(68)),\n      u = p(r(69)),\n      d = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(70)),\n      f = p(r(72)),\n      c = p(r(76)),\n      h = r(77),\n      v = p(r(78)),\n      g = r(79);\n\n  function p(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var y = t.hlsDefaultConfig = {\n    autoStartLoad: !0,\n    startPosition: -1,\n    defaultAudioCodec: void 0,\n    debug: !1,\n    capLevelOnFPSDrop: !1,\n    capLevelToPlayerSize: !1,\n    initialLiveManifestSize: 1,\n    maxBufferLength: 30,\n    maxBufferSize: 6e7,\n    maxBufferHole: .5,\n    lowBufferWatchdogPeriod: .5,\n    highBufferWatchdogPeriod: 3,\n    nudgeOffset: .1,\n    nudgeMaxRetry: 3,\n    maxFragLookUpTolerance: .25,\n    liveSyncDurationCount: 3,\n    liveMaxLatencyDurationCount: 1 / 0,\n    liveSyncDuration: void 0,\n    liveMaxLatencyDuration: void 0,\n    liveDurationInfinity: !1,\n    liveBackBufferLength: 1 / 0,\n    maxMaxBufferLength: 600,\n    enableWorker: !0,\n    enableSoftwareAES: !0,\n    manifestLoadingTimeOut: 1e4,\n    manifestLoadingMaxRetry: 1,\n    manifestLoadingRetryDelay: 1e3,\n    manifestLoadingMaxRetryTimeout: 64e3,\n    startLevel: void 0,\n    levelLoadingTimeOut: 1e4,\n    levelLoadingMaxRetry: 4,\n    levelLoadingRetryDelay: 1e3,\n    levelLoadingMaxRetryTimeout: 64e3,\n    fragLoadingTimeOut: 2e4,\n    fragLoadingMaxRetry: 6,\n    fragLoadingRetryDelay: 1e3,\n    fragLoadingMaxRetryTimeout: 64e3,\n    startFragPrefetch: !1,\n    fpsDroppedMonitoringPeriod: 5e3,\n    fpsDroppedMonitoringThreshold: .2,\n    appendErrorMaxRetry: 3,\n    loader: s.default,\n    fLoader: void 0,\n    pLoader: void 0,\n    xhrSetup: void 0,\n    licenseXhrSetup: void 0,\n    abrController: a.default,\n    bufferController: i.default,\n    capLevelController: n.default,\n    fpsController: o.default,\n    stretchShortVideoTrack: !1,\n    maxAudioFramesDrift: 1,\n    forceKeyFrameOnDiscontinuity: !0,\n    abrEwmaFastLive: 3,\n    abrEwmaSlowLive: 9,\n    abrEwmaFastVoD: 3,\n    abrEwmaSlowVoD: 9,\n    abrEwmaDefaultEstimate: 5e5,\n    abrBandWidthFactor: .95,\n    abrBandWidthUpFactor: .7,\n    abrMaxWithRealBitrate: !1,\n    maxStarvationDelay: 4,\n    maxLoadingDelay: 4,\n    minAutoBitrate: 0,\n    emeEnabled: !1,\n    widevineLicenseUrl: void 0,\n    requestMediaKeySystemAccessFunc: g.requestMediaKeySystemAccess\n  };\n  y.subtitleStreamController = h.SubtitleStreamController, y.subtitleTrackController = c.default, y.timelineController = f.default, y.cueHandler = d, y.enableCEA708Captions = !0, y.enableWebVTT = !0, y.captionsTextTrack1Label = \"English\", y.captionsTextTrack1LanguageCode = \"en\", y.captionsTextTrack2Label = \"Spanish\", y.captionsTextTrack2LanguageCode = \"es\", y.audioStreamController = u.default, y.audioTrackController = l.default, y.emeController = v.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = d(r(1)),\n      n = d(r(3)),\n      o = r(4),\n      s = r(2),\n      l = r(0),\n      u = d(r(62));\n\n  function d(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var f = window.performance,\n      c = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.FRAG_LOADING, i.default.FRAG_LOADED, i.default.FRAG_BUFFERED, i.default.ERROR));\n\n      return r.lastLoadedFragLevel = 0, r._nextAutoLevel = -1, r.hls = e, r.timer = null, r._bwEstimator = null, r.onCheck = r._abandonRulesCheck.bind(r), r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        this.clearTimer(), n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onFragLoading\",\n      value: function (e) {\n        var t = e.frag;\n\n        if (\"main\" === t.type && (this.timer || (this.fragCurrent = t, this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator)) {\n          var r = this.hls,\n              a = r.config,\n              i = t.level,\n              n = void 0,\n              o = void 0;\n          r.levels[i].details.live ? (n = a.abrEwmaFastLive, o = a.abrEwmaSlowLive) : (n = a.abrEwmaFastVoD, o = a.abrEwmaSlowVoD), this._bwEstimator = new u.default(r, o, n, a.abrEwmaDefaultEstimate);\n        }\n      }\n    }, {\n      key: \"_abandonRulesCheck\",\n      value: function () {\n        var e = this.hls,\n            t = e.media,\n            r = this.fragCurrent;\n\n        if (r) {\n          var a = r.loader,\n              n = e.minAutoLevel;\n          if (!a || a.stats && a.stats.aborted) return l.logger.warn(\"frag loader destroy or aborted, disarm abandonRules\"), this.clearTimer(), void (this._nextAutoLevel = -1);\n          var s = a.stats;\n\n          if (t && s && (!t.paused && 0 !== t.playbackRate || !t.readyState) && r.autoLevel && r.level) {\n            var u = f.now() - s.trequest,\n                d = Math.abs(t.playbackRate);\n\n            if (u > 500 * r.duration / d) {\n              var c = e.levels,\n                  h = Math.max(1, s.bw ? s.bw / 8 : 1e3 * s.loaded / u),\n                  v = c[r.level],\n                  g = v.realBitrate ? Math.max(v.realBitrate, v.bitrate) : v.bitrate,\n                  p = s.total ? s.total : Math.max(s.loaded, Math.round(r.duration * g / 8)),\n                  y = t.currentTime,\n                  m = (p - s.loaded) / h,\n                  b = (o.BufferHelper.bufferInfo(t, y, e.config.maxBufferHole).end - y) / d;\n\n              if (b < 2 * r.duration / d && m > b) {\n                var E = void 0,\n                    _ = void 0;\n\n                for (_ = r.level - 1; _ > n; _--) {\n                  var T = c[_].realBitrate ? Math.max(c[_].realBitrate, c[_].bitrate) : c[_].bitrate;\n                  if ((E = r.duration * T / (6.4 * h)) < b) break;\n                }\n\n                E < m && (l.logger.warn(\"loading too slow, abort fragment loading and switch to level \" + _ + \":fragLoadedDelay[\" + _ + \"]<fragLoadedDelay[\" + (r.level - 1) + \"];bufferStarvationDelay:\" + E.toFixed(1) + \"<\" + m.toFixed(1) + \":\" + b.toFixed(1)), e.nextLoadLevel = _, this._bwEstimator.sample(u, s.loaded), a.abort(), this.clearTimer(), e.trigger(i.default.FRAG_LOAD_EMERGENCY_ABORTED, {\n                  frag: r,\n                  stats: s\n                }));\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = e.frag;\n\n        if (\"main\" === t.type && Number.isFinite(t.sn)) {\n          if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {\n            var r = this.hls.levels[t.level],\n                a = (r.loaded ? r.loaded.bytes : 0) + e.stats.loaded,\n                i = (r.loaded ? r.loaded.duration : 0) + e.frag.duration;\n            r.loaded = {\n              bytes: a,\n              duration: i\n            }, r.realBitrate = Math.round(8 * a / i);\n          }\n\n          if (e.frag.bitrateTest) {\n            var n = e.stats;\n            n.tparsed = n.tbuffered = n.tload, this.onFragBuffered(e);\n          }\n        }\n      }\n    }, {\n      key: \"onFragBuffered\",\n      value: function (e) {\n        var t = e.stats,\n            r = e.frag;\n\n        if (!0 !== t.aborted && \"main\" === r.type && Number.isFinite(r.sn) && (!r.bitrateTest || t.tload === t.tbuffered)) {\n          var a = t.tparsed - t.trequest;\n          l.logger.log(\"latency/loading/parsing/append/kbps:\" + Math.round(t.tfirst - t.trequest) + \"/\" + Math.round(t.tload - t.tfirst) + \"/\" + Math.round(t.tparsed - t.tload) + \"/\" + Math.round(t.tbuffered - t.tparsed) + \"/\" + Math.round(8 * t.loaded / (t.tbuffered - t.trequest))), this._bwEstimator.sample(a, t.loaded), t.bwEstimate = this._bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0;\n        }\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        switch (e.details) {\n          case s.ErrorDetails.FRAG_LOAD_ERROR:\n          case s.ErrorDetails.FRAG_LOAD_TIMEOUT:\n            this.clearTimer();\n        }\n      }\n    }, {\n      key: \"clearTimer\",\n      value: function () {\n        clearInterval(this.timer), this.timer = null;\n      }\n    }, {\n      key: \"_findBestLevel\",\n      value: function (e, t, r, a, i, n, o, s, u) {\n        for (var d = i; d >= a; d--) {\n          var f = u[d];\n\n          if (f) {\n            var c = f.details,\n                h = c ? c.totalduration / c.fragments.length : t,\n                v = !!c && c.live,\n                g = void 0;\n            g = d <= e ? o * r : s * r;\n            var p = u[d].realBitrate ? Math.max(u[d].realBitrate, u[d].bitrate) : u[d].bitrate,\n                y = p * h / g;\n            if (l.logger.trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + d + \"/\" + Math.round(g) + \"/\" + p + \"/\" + h + \"/\" + n + \"/\" + y), g > p && (!y || v && !this.bitrateTestDelay || y < n)) return d;\n          }\n        }\n\n        return -1;\n      }\n    }, {\n      key: \"nextAutoLevel\",\n      get: function () {\n        var e = this._nextAutoLevel,\n            t = this._bwEstimator;\n        if (!(-1 === e || t && t.canEstimate())) return e;\n        var r = this._nextABRAutoLevel;\n        return -1 !== e && (r = Math.min(e, r)), r;\n      },\n      set: function (e) {\n        this._nextAutoLevel = e;\n      }\n    }, {\n      key: \"_nextABRAutoLevel\",\n      get: function () {\n        var e = this.hls,\n            t = e.maxAutoLevel,\n            r = e.levels,\n            a = e.config,\n            i = e.minAutoLevel,\n            n = e.media,\n            s = this.lastLoadedFragLevel,\n            u = this.fragCurrent ? this.fragCurrent.duration : 0,\n            d = n ? n.currentTime : 0,\n            f = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1,\n            c = this._bwEstimator ? this._bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate,\n            h = (o.BufferHelper.bufferInfo(n, d, a.maxBufferHole).end - d) / f,\n            v = this._findBestLevel(s, u, c, i, t, h, a.abrBandWidthFactor, a.abrBandWidthUpFactor, r);\n\n        if (v >= 0) return v;\n        l.logger.trace(\"rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering\");\n        var g = u ? Math.min(u, a.maxStarvationDelay) : a.maxStarvationDelay,\n            p = a.abrBandWidthFactor,\n            y = a.abrBandWidthUpFactor;\n\n        if (0 === h) {\n          var m = this.bitrateTestDelay;\n          if (m) g = (u ? Math.min(u, a.maxLoadingDelay) : a.maxLoadingDelay) - m, l.logger.trace(\"bitrate test took \" + Math.round(1e3 * m) + \"ms, set first fragment max fetchDuration to \" + Math.round(1e3 * g) + \" ms\"), p = y = 1;\n        }\n\n        return v = this._findBestLevel(s, u, c, i, t, h + g, p, y, r), Math.max(v, 0);\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = c, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a,\n      i = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      n = r(63),\n      o = (a = n) && a.__esModule ? a : {\n    default: a\n  };\n\n  var s = function () {\n    function e(t, r, a, i) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.hls = t, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new o.default(r), this.fast_ = new o.default(a);\n    }\n\n    return i(e, [{\n      key: \"sample\",\n      value: function (e, t) {\n        var r = 8e3 * t / (e = Math.max(e, this.minDelayMs_)),\n            a = e / 1e3;\n        this.fast_.sample(a, r), this.slow_.sample(a, r);\n      }\n    }, {\n      key: \"canEstimate\",\n      value: function () {\n        var e = this.fast_;\n        return e && e.getTotalWeight() >= this.minWeight_;\n      }\n    }, {\n      key: \"getEstimate\",\n      value: function () {\n        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {}\n    }]), e;\n  }();\n\n  t.default = s, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e(t) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = 0, this.totalWeight_ = 0;\n    }\n\n    return a(e, [{\n      key: \"sample\",\n      value: function (e, t) {\n        var r = Math.pow(this.alpha_, e);\n        this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;\n      }\n    }, {\n      key: \"getTotalWeight\",\n      value: function () {\n        return this.totalWeight_;\n      }\n    }, {\n      key: \"getEstimate\",\n      value: function () {\n        if (this.alpha_) {\n          var e = 1 - Math.pow(this.alpha_, this.totalWeight_);\n          return this.estimate_ / e;\n        }\n\n        return this.estimate_;\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(3)),\n      o = r(0),\n      s = r(2);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = (0, r(13).getMediaSource)(),\n      d = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHING, i.default.MEDIA_DETACHING, i.default.MANIFEST_PARSED, i.default.BUFFER_RESET, i.default.BUFFER_APPENDING, i.default.BUFFER_CODECS, i.default.BUFFER_EOS, i.default.BUFFER_FLUSHING, i.default.LEVEL_PTS_UPDATED, i.default.LEVEL_UPDATED));\n\n      return r._msDuration = null, r._levelDuration = null, r._levelTargetDuration = 10, r._live = null, r._objectUrl = null, r.bufferCodecEventsExpected = 0, r.onsbue = r.onSBUpdateEnd.bind(r), r.onsbe = r.onSBUpdateError.bind(r), r.pendingTracks = {}, r.tracks = {}, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onLevelPtsUpdated\",\n      value: function (e) {\n        var t = e.type,\n            r = this.tracks.audio;\n\n        if (\"audio\" === t && r && \"audio/mpeg\" === r.container) {\n          var a = this.sourceBuffer.audio;\n\n          if (Math.abs(a.timestampOffset - e.start) > .1) {\n            var i = a.updating;\n\n            try {\n              a.abort();\n            } catch (e) {\n              o.logger.warn(\"can not abort audio buffer: \" + e);\n            }\n\n            i ? this.audioTimestampOffset = e.start : (o.logger.warn(\"change mpeg audio timestamp offset from \" + a.timestampOffset + \" to \" + e.start), a.timestampOffset = e.start);\n          }\n        }\n      }\n    }, {\n      key: \"onManifestParsed\",\n      value: function (e) {\n        this.bufferCodecEventsExpected = e.altAudio ? 2 : 1, o.logger.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n      }\n    }, {\n      key: \"onMediaAttaching\",\n      value: function (e) {\n        var t = this.media = e.media;\n\n        if (t) {\n          var r = this.mediaSource = new u();\n          this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), r.addEventListener(\"sourceopen\", this.onmso), r.addEventListener(\"sourceended\", this.onmse), r.addEventListener(\"sourceclose\", this.onmsc), t.src = window.URL.createObjectURL(r), this._objectUrl = t.src;\n        }\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        o.logger.log(\"media source detaching\");\n        var e = this.mediaSource;\n\n        if (e) {\n          if (\"open\" === e.readyState) try {\n            e.endOfStream();\n          } catch (e) {\n            o.logger.warn(\"onMediaDetaching:\" + e.message + \" while calling endOfStream\");\n          }\n          e.removeEventListener(\"sourceopen\", this.onmso), e.removeEventListener(\"sourceended\", this.onmse), e.removeEventListener(\"sourceclose\", this.onmsc), this.media && (window.URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute(\"src\"), this.media.load()) : o.logger.warn(\"media.src was changed by a third party - skip cleanup\")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;\n        }\n\n        this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(i.default.MEDIA_DETACHED);\n      }\n    }, {\n      key: \"onMediaSourceOpen\",\n      value: function () {\n        o.logger.log(\"media source opened\"), this.hls.trigger(i.default.MEDIA_ATTACHED, {\n          media: this.media\n        });\n        var e = this.mediaSource;\n        e && e.removeEventListener(\"sourceopen\", this.onmso), this.checkPendingTracks();\n      }\n    }, {\n      key: \"checkPendingTracks\",\n      value: function () {\n        var e = this.bufferCodecEventsExpected,\n            t = this.pendingTracks,\n            r = Object.keys(t).length;\n        (r && !e || 2 === r) && (this.createSourceBuffers(t), this.pendingTracks = {}, this.doAppending());\n      }\n    }, {\n      key: \"onMediaSourceClose\",\n      value: function () {\n        o.logger.log(\"media source closed\");\n      }\n    }, {\n      key: \"onMediaSourceEnded\",\n      value: function () {\n        o.logger.log(\"media source ended\");\n      }\n    }, {\n      key: \"onSBUpdateEnd\",\n      value: function () {\n        if (this.audioTimestampOffset) {\n          var e = this.sourceBuffer.audio;\n          o.logger.warn(\"change mpeg audio timestamp offset from \" + e.timestampOffset + \" to \" + this.audioTimestampOffset), e.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;\n        }\n\n        this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1;\n        var t = this.parent,\n            r = this.segments.reduce(function (e, r) {\n          return r.parent === t ? e + 1 : e;\n        }, 0),\n            a = {},\n            n = this.sourceBuffer;\n\n        for (var s in n) a[s] = n[s].buffered;\n\n        if (!1 === this._paused && a.video && a.video.length > 0 && a.audio && a.audio.length > 0) if (a.video.end(0) - a.video.start(0) > 1 && a.audio.end(0) - a.audio.start(0) > 1) {\n          var l = Math.max(a.video.start(0), a.audio.start(0));\n          this.media.currentTime = l, this.media.play(), delete this._paused;\n        } else {\n          var u = Math.max(a.video.end(0), a.audio.end(0));\n          this.media.currentTime = u, this.media.play();\n        }\n        this.hls.trigger(i.default.BUFFER_APPENDED, {\n          parent: t,\n          pending: r,\n          timeRanges: a\n        }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration(), 0 === r && this.flushLiveBackBuffer();\n      }\n    }, {\n      key: \"onSBUpdateError\",\n      value: function (e) {\n        o.logger.error(\"sourceBuffer error:\", e), this.hls.trigger(i.default.ERROR, {\n          type: s.ErrorTypes.MEDIA_ERROR,\n          details: s.ErrorDetails.BUFFER_APPENDING_ERROR,\n          fatal: !1\n        });\n      }\n    }, {\n      key: \"onBufferReset\",\n      value: function () {\n        var e = this.sourceBuffer;\n\n        for (var t in e) {\n          var r = e[t];\n\n          try {\n            this.mediaSource.removeSourceBuffer(r), r.removeEventListener(\"updateend\", this.onsbue), r.removeEventListener(\"error\", this.onsbe);\n          } catch (e) {}\n        }\n\n        this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;\n      }\n    }, {\n      key: \"onBufferCodecs\",\n      value: function (e) {\n        var t = this;\n        Object.keys(e).forEach(function (r) {\n          t.pendingTracks[r] = e[r];\n        });\n        var r = this.mediaSource;\n        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), r && \"open\" === r.readyState && this.checkPendingTracks();\n      }\n    }, {\n      key: \"createSourceBuffers\",\n      value: function (e) {\n        var t = this.sourceBuffer,\n            r = this.mediaSource;\n\n        for (var a in e) if (!t[a]) {\n          var n = e[a],\n              l = n.levelCodec || n.codec,\n              d = n.container + \";codecs=\" + l;\n          o.logger.log(\"creating sourceBuffer(\" + d + \")\");\n\n          try {\n            var f = t[a] = r.addSourceBuffer(d);\n            f.addEventListener(\"updateend\", this.onsbue), f.addEventListener(\"error\", this.onsbe), this.tracks[a] = {\n              codec: l,\n              container: n.container\n            }, n.buffer = f;\n          } catch (e) {\n            if (22 == e.code) {\n              o.logger.log(\"Found new track, try to rebuild\"), this._paused = !1;\n              var c = this.mediaSource = new u();\n              this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this);\n\n              for (var h = 0; h < Object.keys(this.tracks).length; h++) {\n                var v = this.tracks[Object.keys(this.tracks)[h]];\n                this.pendingTracks[Object.keys(this.tracks)[h]] = v;\n              }\n\n              this.tracks = {}, this.sourceBuffer = {}, c.addEventListener(\"sourceopen\", this.onmso), c.addEventListener(\"sourceended\", this.onmse), c.addEventListener(\"sourceclose\", this.onmsc), this.media.src = window.URL.createObjectURL(c), this._objectUrl = media.src;\n            } else o.logger.error(\"error while trying to add sourceBuffer:\" + e.message), this.hls.trigger(i.default.ERROR, {\n              type: s.ErrorTypes.MEDIA_ERROR,\n              details: s.ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n              fatal: !1,\n              err: e,\n              mimeType: d\n            });\n          }\n        }\n\n        this.hls.trigger(i.default.BUFFER_CREATED, {\n          tracks: e\n        });\n      }\n    }, {\n      key: \"onBufferAppending\",\n      value: function (e) {\n        this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending());\n      }\n    }, {\n      key: \"onBufferAppendFail\",\n      value: function (e) {\n        o.logger.error(\"sourceBuffer error:\", e.event), this.hls.trigger(i.default.ERROR, {\n          type: s.ErrorTypes.MEDIA_ERROR,\n          details: s.ErrorDetails.BUFFER_APPENDING_ERROR,\n          fatal: !1\n        });\n      }\n    }, {\n      key: \"onBufferEos\",\n      value: function (e) {\n        var t = this.sourceBuffer,\n            r = e.type;\n\n        for (var a in t) r && a !== r || t[a].ended || (t[a].ended = !0, o.logger.log(a + \" sourceBuffer now EOS\"));\n\n        this.checkEos();\n      }\n    }, {\n      key: \"checkEos\",\n      value: function () {\n        var e = this.sourceBuffer,\n            t = this.mediaSource;\n\n        if (t && \"open\" === t.readyState) {\n          for (var r in e) {\n            var a = e[r];\n            if (!a.ended) return;\n            if (a.updating) return void (this._needsEos = !0);\n          }\n\n          o.logger.log(\"all media data are available, signal endOfStream() to MediaSource and stop loading fragment\");\n\n          try {\n            t.endOfStream();\n          } catch (e) {\n            o.logger.warn(\"exception while calling mediaSource.endOfStream()\");\n          }\n\n          this._needsEos = !1;\n        } else this._needsEos = !1;\n      }\n    }, {\n      key: \"onBufferFlushing\",\n      value: function (e) {\n        this.flushRange.push({\n          start: e.startOffset,\n          end: e.endOffset,\n          type: e.type\n        }), this.flushBufferCounter = 0, this.doFlush();\n      }\n    }, {\n      key: \"flushLiveBackBuffer\",\n      value: function () {\n        if (this._live) {\n          var e = this.hls.config.liveBackBufferLength;\n          if (isFinite(e) && !(e < 0)) for (var t = this.media.currentTime, r = this.sourceBuffer, a = Object.keys(r), i = t - Math.max(e, this._levelTargetDuration), n = a.length - 1; n >= 0; n--) {\n            var o = a[n],\n                s = r[o].buffered;\n            s.length > 0 && i > s.start(0) && this.removeBufferRange(o, r[o], 0, i);\n          }\n        }\n      }\n    }, {\n      key: \"onLevelUpdated\",\n      value: function (e) {\n        var t = e.details;\n        t.fragments.length > 0 && (this._levelDuration = t.totalduration + t.fragments[0].start, this._levelTargetDuration = t.averagetargetduration || t.targetduration || 10, this._live = t.live, this.updateMediaElementDuration());\n      }\n    }, {\n      key: \"updateMediaElementDuration\",\n      value: function () {\n        var e,\n            t = this.hls.config;\n\n        if (null !== this._levelDuration && this.media && this.mediaSource && this.sourceBuffer && 0 !== this.media.readyState && \"open\" === this.mediaSource.readyState) {\n          for (var r in this.sourceBuffer) if (!0 === this.sourceBuffer[r].updating) return;\n\n          e = this.media.duration, null === this._msDuration && (this._msDuration = this.mediaSource.duration), !0 === this._live && !0 === t.liveDurationInfinity ? (o.logger.log(\"Media Source duration is set to Infinity\"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > e || !Number.isFinite(e)) && (o.logger.log(\"Updating Media Source duration to \" + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration);\n        }\n      }\n    }, {\n      key: \"doFlush\",\n      value: function () {\n        for (; this.flushRange.length;) {\n          var e = this.flushRange[0];\n          if (!this.flushBuffer(e.start, e.end, e.type)) return void (this._needsFlush = !0);\n          this.flushRange.shift(), this.flushBufferCounter = 0;\n        }\n\n        if (0 === this.flushRange.length) {\n          this._needsFlush = !1;\n          var t = 0,\n              r = this.sourceBuffer;\n\n          try {\n            for (var a in r) t += r[a].buffered.length;\n          } catch (e) {\n            o.logger.error(\"error while accessing sourceBuffer.buffered\");\n          }\n\n          this.appended = t, this.hls.trigger(i.default.BUFFER_FLUSHED);\n        }\n      }\n    }, {\n      key: \"doAppending\",\n      value: function () {\n        var e = this.hls,\n            t = this.segments,\n            r = this.sourceBuffer;\n\n        if (Object.keys(r).length) {\n          if (this.media.error) return this.segments = [], void o.logger.error(\"trying to append although a media error occured, flush segment and abort\");\n          if (this.appending) return;\n\n          if (t && t.length) {\n            var a = t.shift();\n\n            try {\n              var n = r[a.type];\n              n ? n.updating ? t.unshift(a) : (n.ended = !1, this.parent = a.parent, n.appendBuffer(a.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();\n            } catch (r) {\n              o.logger.error(\"error while trying to append buffer:\" + r.message), t.unshift(a);\n              var l = {\n                type: s.ErrorTypes.MEDIA_ERROR,\n                parent: a.parent\n              };\n              22 !== r.code ? (this.appendError ? this.appendError++ : this.appendError = 1, l.details = s.ErrorDetails.BUFFER_APPEND_ERROR, this.appendError > e.config.appendErrorMaxRetry ? (o.logger.log(\"fail \" + e.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\"), this.segments = [], l.fatal = !0, e.trigger(i.default.ERROR, l)) : (l.fatal = !1, e.trigger(i.default.ERROR, l))) : (this.segments = [], l.details = s.ErrorDetails.BUFFER_FULL_ERROR, l.fatal = !1, e.trigger(i.default.ERROR, l));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"flushBuffer\",\n      value: function (e, t, r) {\n        var a = void 0,\n            i = this.sourceBuffer;\n\n        if (Object.keys(i).length) {\n          if (o.logger.log(\"flushBuffer,pos/start/end: \" + this.media.currentTime.toFixed(3) + \"/\" + e + \"/\" + t), this.flushBufferCounter < this.appended) {\n            for (var n in i) if (!r || n === r) {\n              if ((a = i[n]).ended = !1, a.updating) return o.logger.warn(\"cannot flush, sb updating in progress\"), !1;\n              if (this.removeBufferRange(n, a, e, t)) return this.flushBufferCounter++, !1;\n            }\n          } else o.logger.warn(\"abort flushing too many retries\");\n\n          o.logger.log(\"buffer flushed\");\n        }\n\n        return !0;\n      }\n    }, {\n      key: \"removeBufferRange\",\n      value: function (e, t, r, a) {\n        try {\n          for (var i = 0; i < t.buffered.length; i++) {\n            var n = t.buffered.start(i),\n                s = t.buffered.end(i),\n                l = Math.max(n, r),\n                u = Math.min(s, a);\n            if (Math.min(u, s) - l > .5) return o.logger.log(\"sb remove \" + e + \" [\" + l + \",\" + u + \"], of [\" + n + \",\" + s + \"], pos:\" + this.media.currentTime), t.remove(l, u), !0;\n          }\n        } catch (e) {\n          o.logger.warn(\"removeBufferRange failed\", e);\n        }\n\n        return !1;\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = d, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = n(r(1));\n\n  function n(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var o = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.FPS_DROP_LEVEL_CAPPING, i.default.MEDIA_ATTACHING, i.default.MANIFEST_PARSED, i.default.BUFFER_CODECS, i.default.MEDIA_DETACHING));\n\n      return r.autoLevelCapping = Number.POSITIVE_INFINITY, r.firstLevel = null, r.levels = [], r.media = null, r.restrictedLevels = [], r.timer = null, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        this.hls.config.capLevelToPlayerSize && (this.media = null, this._stopCapping());\n      }\n    }, {\n      key: \"onFpsDropLevelCapping\",\n      value: function (e) {\n        t.isLevelAllowed(e.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(e.droppedLevel);\n      }\n    }, {\n      key: \"onMediaAttaching\",\n      value: function (e) {\n        this.media = e.media instanceof window.HTMLVideoElement ? e.media : null;\n      }\n    }, {\n      key: \"onManifestParsed\",\n      value: function (e) {\n        var t = this.hls;\n        this.restrictedLevels = [], this.levels = e.levels, this.firstLevel = e.firstLevel, t.config.capLevelToPlayerSize && e.video && this._startCapping();\n      }\n    }, {\n      key: \"onBufferCodecs\",\n      value: function (e) {\n        this.hls.config.capLevelToPlayerSize && e.video && this._startCapping();\n      }\n    }, {\n      key: \"onLevelsUpdated\",\n      value: function (e) {\n        this.levels = e.levels;\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        this._stopCapping();\n      }\n    }, {\n      key: \"detectPlayerSize\",\n      value: function () {\n        if (this.media) {\n          var e = this.levels ? this.levels.length : 0;\n\n          if (e) {\n            var t = this.hls;\n            t.autoLevelCapping = this.getMaxLevel(e - 1), t.autoLevelCapping > this.autoLevelCapping && t.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;\n          }\n        }\n      }\n    }, {\n      key: \"getMaxLevel\",\n      value: function (e) {\n        var r = this;\n        if (!this.levels) return -1;\n        var a = this.levels.filter(function (a, i) {\n          return t.isLevelAllowed(i, r.restrictedLevels) && i <= e;\n        });\n        return t.getMaxLevelByMediaSize(a, this.mediaWidth, this.mediaHeight);\n      }\n    }, {\n      key: \"_startCapping\",\n      value: function () {\n        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n      }\n    }, {\n      key: \"_stopCapping\",\n      value: function () {\n        this.restrictedLevels = [], this.firstLevel = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer), this.timer = null);\n      }\n    }, {\n      key: \"mediaWidth\",\n      get: function () {\n        var e = void 0,\n            r = this.media;\n        return r && (e = r.width || r.clientWidth || r.offsetWidth, e *= t.contentScaleFactor), e;\n      }\n    }, {\n      key: \"mediaHeight\",\n      get: function () {\n        var e = void 0,\n            r = this.media;\n        return r && (e = r.height || r.clientHeight || r.offsetHeight, e *= t.contentScaleFactor), e;\n      }\n    }], [{\n      key: \"isLevelAllowed\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];\n        return -1 === t.indexOf(e);\n      }\n    }, {\n      key: \"getMaxLevelByMediaSize\",\n      value: function (e, t, r) {\n        if (!e || e && !e.length) return -1;\n\n        for (var a, i, n = e.length - 1, o = 0; o < e.length; o += 1) {\n          var s = e[o];\n\n          if ((s.width >= t || s.height >= r) && (a = s, !(i = e[o + 1]) || a.width !== i.width || a.height !== i.height)) {\n            n = o;\n            break;\n          }\n        }\n\n        return n;\n      }\n    }, {\n      key: \"contentScaleFactor\",\n      get: function () {\n        var e = 1;\n\n        try {\n          e = window.devicePixelRatio;\n        } catch (e) {}\n\n        return e;\n      }\n    }]), t;\n  }(n(r(3)).default);\n\n  t.default = o, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = s(r(1)),\n      n = s(r(3)),\n      o = r(0);\n\n  function s(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var l = window.performance,\n      u = function (e) {\n    function t(e) {\n      return function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHING));\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;\n      }\n    }, {\n      key: \"onMediaAttaching\",\n      value: function (e) {\n        var t = this.hls.config;\n        t.capLevelOnFPSDrop && (\"function\" == typeof (this.video = e.media instanceof window.HTMLVideoElement ? e.media : null).getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), t.fpsDroppedMonitoringPeriod));\n      }\n    }, {\n      key: \"checkFPS\",\n      value: function (e, t, r) {\n        var a = l.now();\n\n        if (t) {\n          if (this.lastTime) {\n            var n = a - this.lastTime,\n                s = r - this.lastDroppedFrames,\n                u = t - this.lastDecodedFrames,\n                d = 1e3 * s / n,\n                f = this.hls;\n\n            if (f.trigger(i.default.FPS_DROP, {\n              currentDropped: s,\n              currentDecoded: u,\n              totalDroppedFrames: r\n            }), d > 0 && s > f.config.fpsDroppedMonitoringThreshold * u) {\n              var c = f.currentLevel;\n              o.logger.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + c), c > 0 && (-1 === f.autoLevelCapping || f.autoLevelCapping >= c) && (c -= 1, f.trigger(i.default.FPS_DROP_LEVEL_CAPPING, {\n                level: c,\n                droppedLevel: f.currentLevel\n              }), f.autoLevelCapping = c, f.streamController.nextLevelSwitch());\n            }\n          }\n\n          this.lastTime = a, this.lastDroppedFrames = r, this.lastDecodedFrames = t;\n        }\n      }\n    }, {\n      key: \"checkFPSInterval\",\n      value: function () {\n        var e = this.video;\n        if (e) if (this.isVideoPlaybackQualityAvailable) {\n          var t = e.getVideoPlaybackQuality();\n          this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);\n        } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = r(0);\n\n  var n = window,\n      o = n.performance,\n      s = n.XMLHttpRequest,\n      l = function () {\n    function e(t) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), t && t.xhrSetup && (this.xhrSetup = t.xhrSetup);\n    }\n\n    return a(e, [{\n      key: \"destroy\",\n      value: function () {\n        this.abort(), this.loader = null;\n      }\n    }, {\n      key: \"abort\",\n      value: function () {\n        var e = this.loader;\n        e && 4 !== e.readyState && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;\n      }\n    }, {\n      key: \"load\",\n      value: function (e, t, r) {\n        this.context = e, this.config = t, this.callbacks = r, this.stats = {\n          trequest: o.now(),\n          retry: 0\n        }, this.retryDelay = t.retryDelay, this.loadInternal();\n      }\n    }, {\n      key: \"loadInternal\",\n      value: function () {\n        var e = void 0,\n            t = this.context;\n        e = this.loader = new s();\n        var r = this.stats;\n        r.tfirst = 0, r.loaded = 0;\n        var a = this.xhrSetup;\n\n        try {\n          if (a) try {\n            a(e, t.url);\n          } catch (r) {\n            e.open(\"GET\", t.url, !0), a(e, t.url);\n          }\n          e.readyState || e.open(\"GET\", t.url, !0);\n        } catch (r) {\n          return void this.callbacks.onError({\n            code: e.status,\n            text: r.message\n          }, t, e);\n        }\n\n        t.rangeEnd && e.setRequestHeader(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send();\n      }\n    }, {\n      key: \"readystatechange\",\n      value: function (e) {\n        var t = e.currentTarget,\n            r = t.readyState,\n            a = this.stats,\n            n = this.context,\n            s = this.config;\n        if (!a.aborted && r >= 2) if (window.clearTimeout(this.requestTimeout), 0 === a.tfirst && (a.tfirst = Math.max(o.now(), a.trequest)), 4 === r) {\n          var l = t.status;\n\n          if (l >= 200 && l < 300) {\n            a.tload = Math.max(a.tfirst, o.now());\n            var u = void 0,\n                d = void 0;\n            d = \"arraybuffer\" === n.responseType ? (u = t.response).byteLength : (u = t.responseText).length, a.loaded = a.total = d;\n            var f = {\n              url: t.responseURL,\n              data: u\n            };\n            this.callbacks.onSuccess(f, a, n, t);\n          } else a.retry >= s.maxRetry || l >= 400 && l < 499 ? (i.logger.error(l + \" while loading \" + n.url), this.callbacks.onError({\n            code: l,\n            text: t.statusText\n          }, n, t)) : (i.logger.warn(l + \" while loading \" + n.url + \", retrying in \" + this.retryDelay + \"...\"), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, s.maxRetryDelay), a.retry++);\n        } else this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), s.timeout);\n      }\n    }, {\n      key: \"loadtimeout\",\n      value: function () {\n        i.logger.warn(\"timeout while loading \" + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null);\n      }\n    }, {\n      key: \"loadprogress\",\n      value: function (e) {\n        var t = e.currentTarget,\n            r = this.stats;\n        r.loaded = e.loaded, e.lengthComputable && (r.total = e.total);\n        var a = this.callbacks.onProgress;\n        a && a(r, this.context, null, t);\n      }\n    }]), e;\n  }();\n\n  t.default = l, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(28)),\n      o = r(0),\n      s = r(2);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MANIFEST_LOADING, i.default.MANIFEST_PARSED, i.default.AUDIO_TRACK_LOADED, i.default.AUDIO_TRACK_SWITCHED, i.default.LEVEL_LOADED, i.default.ERROR));\n\n      return r._trackId = -1, r._selectDefaultTrack = !0, r.tracks = [], r.trackIdBlacklist = Object.create(null), r.audioGroupId = null, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"onManifestLoading\",\n      value: function () {\n        this.tracks = [], this._trackId = -1, this._selectDefaultTrack = !0;\n      }\n    }, {\n      key: \"onManifestParsed\",\n      value: function (e) {\n        var t = this.tracks = e.audioTracks || [];\n        this.hls.trigger(i.default.AUDIO_TRACKS_UPDATED, {\n          audioTracks: t\n        });\n      }\n    }, {\n      key: \"onAudioTrackLoaded\",\n      value: function (e) {\n        if (e.id >= this.tracks.length) o.logger.warn(\"Invalid audio track id:\", e.id);else {\n          if (o.logger.log(\"audioTrack \" + e.id + \" loaded\"), this.tracks[e.id].details = e.details, e.details.live && !this.hasInterval()) {\n            var t = 1e3 * e.details.targetduration;\n            this.setInterval(t);\n          }\n\n          !e.details.live && this.hasInterval() && this.clearInterval();\n        }\n      }\n    }, {\n      key: \"onAudioTrackSwitched\",\n      value: function (e) {\n        var t = this.tracks[e.id].groupId;\n        t && this.audioGroupId !== t && (this.audioGroupId = t);\n      }\n    }, {\n      key: \"onLevelLoaded\",\n      value: function (e) {\n        var t = this.hls.levels[e.level];\n\n        if (t.audioGroupIds) {\n          var r = t.audioGroupIds[t.urlId];\n          this.audioGroupId !== r && (this.audioGroupId = r, this._selectInitialAudioTrack());\n        }\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        e.type === s.ErrorTypes.NETWORK_ERROR && (e.fatal && this.clearInterval(), e.details === s.ErrorDetails.AUDIO_TRACK_LOAD_ERROR && (o.logger.warn(\"Network failure on audio-track id:\", e.context.id), this._handleLoadError()));\n      }\n    }, {\n      key: \"_setAudioTrack\",\n      value: function (e) {\n        if (this._trackId === e && this.tracks[this._trackId].details) o.logger.debug(\"Same id as current audio-track passed, and track details available -> no-op\");else if (e < 0 || e >= this.tracks.length) o.logger.warn(\"Invalid id passed to audio-track controller\");else {\n          var t = this.tracks[e];\n          o.logger.log(\"Now switching to audio-track index \" + e), this.clearInterval(), this._trackId = e;\n          var r = t.url,\n              a = t.type,\n              n = t.id;\n          this.hls.trigger(i.default.AUDIO_TRACK_SWITCHING, {\n            id: n,\n            type: a,\n            url: r\n          }), this._loadTrackDetailsIfNeeded(t);\n        }\n      }\n    }, {\n      key: \"doTick\",\n      value: function () {\n        this._updateTrack(this._trackId);\n      }\n    }, {\n      key: \"_selectInitialAudioTrack\",\n      value: function () {\n        var e = this,\n            t = this.tracks;\n\n        if (t.length) {\n          var r = this.tracks[this._trackId],\n              a = null;\n\n          if (r && (a = r.name), this._selectDefaultTrack) {\n            var n = t.filter(function (e) {\n              return e.default;\n            });\n            n.length ? t = n : o.logger.warn(\"No default audio tracks defined\");\n          }\n\n          var l = !1,\n              u = function () {\n            t.forEach(function (t) {\n              l || e.audioGroupId && t.groupId !== e.audioGroupId || a && a !== t.name || (e._setAudioTrack(t.id), l = !0);\n            });\n          };\n\n          u(), l || (a = null, u()), l || (o.logger.error(\"No track found for running audio group-ID: \" + this.audioGroupId), this.hls.trigger(i.default.ERROR, {\n            type: s.ErrorTypes.MEDIA_ERROR,\n            details: s.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n            fatal: !0\n          }));\n        }\n      }\n    }, {\n      key: \"_needsTrackLoading\",\n      value: function (e) {\n        var t = e.details,\n            r = e.url;\n        return !(t && !t.live) && !!r;\n      }\n    }, {\n      key: \"_loadTrackDetailsIfNeeded\",\n      value: function (e) {\n        if (this._needsTrackLoading(e)) {\n          var t = e.url,\n              r = e.id;\n          o.logger.log(\"loading audio-track playlist for id: \" + r), this.hls.trigger(i.default.AUDIO_TRACK_LOADING, {\n            url: t,\n            id: r\n          });\n        }\n      }\n    }, {\n      key: \"_updateTrack\",\n      value: function (e) {\n        if (!(e < 0 || e >= this.tracks.length)) {\n          this.clearInterval(), this._trackId = e, o.logger.log(\"trying to update audio-track \" + e);\n          var t = this.tracks[e];\n\n          this._loadTrackDetailsIfNeeded(t);\n        }\n      }\n    }, {\n      key: \"_handleLoadError\",\n      value: function () {\n        this.trackIdBlacklist[this._trackId] = !0;\n        var e = this._trackId,\n            t = this.tracks[e],\n            r = t.name,\n            a = t.language,\n            i = t.groupId;\n        o.logger.warn(\"Loading failed on audio track id: \" + e + \", group-id: \" + i + ', name/language: \"' + r + '\" / \"' + a + '\"');\n\n        for (var n = e, s = 0; s < this.tracks.length; s++) {\n          if (!this.trackIdBlacklist[s]) if (this.tracks[s].name === r) {\n            n = s;\n            break;\n          }\n        }\n\n        n !== e ? (o.logger.log(\"Attempting audio-track fallback id:\", n, \"group-id:\", this.tracks[n].groupId), this._setAudioTrack(n)) : o.logger.warn('No fallback audio-track found for name/language: \"' + r + '\" / \"' + a + '\"');\n      }\n    }, {\n      key: \"audioTracks\",\n      get: function () {\n        return this.tracks;\n      }\n    }, {\n      key: \"audioTrack\",\n      get: function () {\n        return this._trackId;\n      },\n      set: function (e) {\n        this._setAudioTrack(e), this._selectDefaultTrack = !1;\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = y(r(9)),\n      n = r(4),\n      o = y(r(19)),\n      s = y(r(1)),\n      l = function (e) {\n    if (e && e.__esModule) return e;\n    var t = {};\n    if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    return t.default = e, t;\n  }(r(7)),\n      u = y(r(25)),\n      d = r(2),\n      f = r(0),\n      c = r(26),\n      h = r(6),\n      v = y(r(11)),\n      g = r(14),\n      p = y(g);\n\n  function y(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var m = window.performance,\n      b = function (e) {\n    function t(e, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var a = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, s.default.MEDIA_ATTACHED, s.default.MEDIA_DETACHING, s.default.AUDIO_TRACKS_UPDATED, s.default.AUDIO_TRACK_SWITCHING, s.default.AUDIO_TRACK_LOADED, s.default.KEY_LOADED, s.default.FRAG_LOADED, s.default.FRAG_PARSING_INIT_SEGMENT, s.default.FRAG_PARSING_DATA, s.default.FRAG_PARSED, s.default.ERROR, s.default.BUFFER_RESET, s.default.BUFFER_CREATED, s.default.BUFFER_APPENDED, s.default.BUFFER_FLUSHED, s.default.INIT_PTS_FOUND));\n\n      return a.fragmentTracker = r, a.config = e.config, a.audioCodecSwap = !1, a._state = g.State.STOPPED, a.initPTS = [], a.waitingFragment = null, a.videoTrackCC = null, a;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"onInitPtsFound\",\n      value: function (e) {\n        var t = e.id,\n            r = e.frag.cc,\n            a = e.initPTS;\n        \"main\" === t && (this.initPTS[r] = a, this.videoTrackCC = r, f.logger.log(\"InitPTS for cc: \" + r + \" found from video track: \" + a), this.state === g.State.WAITING_INIT_PTS && this.tick());\n      }\n    }, {\n      key: \"startLoad\",\n      value: function (e) {\n        if (this.tracks) {\n          var t = this.lastCurrentTime;\n          this.stopLoad(), this.setInterval(100), this.fragLoadError = 0, t > 0 && -1 === e ? (f.logger.log(\"audio:override startPosition with lastCurrentTime @\" + t.toFixed(3)), this.state = g.State.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : e, this.state = g.State.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();\n        } else this.startPosition = e, this.state = g.State.STOPPED;\n      }\n    }, {\n      key: \"doTick\",\n      value: function () {\n        var e = void 0,\n            t = void 0,\n            r = void 0,\n            a = this.hls,\n            o = a.config;\n\n        switch (this.state) {\n          case g.State.ERROR:\n          case g.State.PAUSED:\n          case g.State.BUFFER_FLUSHING:\n            break;\n\n          case g.State.STARTING:\n            this.state = g.State.WAITING_TRACK, this.loadedmetadata = !1;\n            break;\n\n          case g.State.IDLE:\n            var l = this.tracks;\n            if (!l) break;\n            if (!this.media && (this.startFragRequested || !o.startFragPrefetch)) break;\n            if (this.loadedmetadata) e = this.media.currentTime;else if (void 0 === (e = this.nextLoadPosition)) break;\n\n            var u = this.mediaBuffer ? this.mediaBuffer : this.media,\n                d = this.videoBuffer ? this.videoBuffer : this.media,\n                v = n.BufferHelper.bufferInfo(u, e, o.maxBufferHole),\n                p = n.BufferHelper.bufferInfo(d, e, o.maxBufferHole),\n                y = v.len,\n                b = v.end,\n                E = this.fragPrevious,\n                _ = Math.min(o.maxBufferLength, o.maxMaxBufferLength),\n                T = Math.max(_, p.len),\n                S = this.audioSwitch,\n                k = this.trackId;\n\n            if ((y < T || S) && k < l.length) {\n              if (void 0 === (r = l[k].details)) {\n                this.state = g.State.WAITING_TRACK;\n                break;\n              }\n\n              if (!S && this._streamEnded(v, r)) return this.hls.trigger(s.default.BUFFER_EOS, {\n                type: \"audio\"\n              }), void (this.state = g.State.ENDED);\n              var R = r.fragments,\n                  A = R.length,\n                  w = R[0].start,\n                  O = R[A - 1].start + R[A - 1].duration,\n                  L = void 0;\n              if (S) if (r.live && !r.PTSKnown) f.logger.log(\"switching audiotrack, live stream, unknown PTS,load first fragment\"), b = 0;else if (b = e, r.PTSKnown && e < w) {\n                if (!(v.end > w || v.nextStart)) return;\n                f.logger.log(\"alt audio track ahead of main track, seek to start of alt audio track\"), this.media.currentTime = w + .05;\n              }\n              if (r.initSegment && !r.initSegment.data) L = r.initSegment;else if (b <= w) {\n                if (L = R[0], null !== this.videoTrackCC && L.cc !== this.videoTrackCC && (L = (0, c.findFragWithCC)(R, this.videoTrackCC)), r.live && L.loadIdx && L.loadIdx === this.fragLoadIdx) {\n                  var D = v.nextStart ? v.nextStart : w;\n                  return f.logger.log(\"no alt audio available @currentTime:\" + this.media.currentTime + \", seeking @\" + (D + .05)), void (this.media.currentTime = D + .05);\n                }\n              } else {\n                var P = void 0,\n                    I = o.maxFragLookUpTolerance,\n                    C = E ? R[E.sn - R[0].sn + 1] : void 0,\n                    x = function (e) {\n                  var t = Math.min(I, e.duration);\n                  return e.start + e.duration - t <= b ? 1 : e.start - t > b && e.start ? -1 : 0;\n                };\n\n                b < O ? (b > O - I && (I = 0), P = C && !x(C) ? C : i.default.search(R, x)) : P = R[A - 1], P && (L = P, w = P.start, E && L.level === E.level && L.sn === E.sn && (L.sn < r.endSN ? (L = R[L.sn + 1 - r.startSN], f.logger.log(\"SN just loaded, load next one: \" + L.sn)) : L = null));\n              }\n              L && (L.encrypted ? (f.logger.log(\"Loading key for \" + L.sn + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],track \" + k), this.state = g.State.KEY_LOADING, a.trigger(s.default.KEY_LOADING, {\n                frag: L\n              })) : (f.logger.log(\"Loading \" + L.sn + \", cc: \" + L.cc + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],track \" + k + \", currentTime:\" + e + \",bufferEnd:\" + b.toFixed(3)), this.fragCurrent = L, (S || this.fragmentTracker.getState(L) === h.FragmentState.NOT_LOADED) && (this.startFragRequested = !0, Number.isFinite(L.sn) && (this.nextLoadPosition = L.start + L.duration), a.trigger(s.default.FRAG_LOADING, {\n                frag: L\n              }), this.state = g.State.FRAG_LOADING)));\n            }\n\n            break;\n\n          case g.State.WAITING_TRACK:\n            (t = this.tracks[this.trackId]) && t.details && (this.state = g.State.IDLE);\n            break;\n\n          case g.State.FRAG_LOADING_WAITING_RETRY:\n            var M = m.now(),\n                F = this.retryDate,\n                N = (u = this.media) && u.seeking;\n            (!F || M >= F || N) && (f.logger.log(\"audioStreamController: retryDate reached, switch back to IDLE state\"), this.state = g.State.IDLE);\n            break;\n\n          case g.State.WAITING_INIT_PTS:\n            var U = this.videoTrackCC;\n            if (void 0 === this.initPTS[U]) break;\n            var B = this.waitingFragment;\n\n            if (B) {\n              var G = B.frag.cc;\n              U !== G ? (t = this.tracks[this.trackId]).details && t.details.live && (f.logger.warn(\"Waiting fragment CC (\" + G + \") does not match video track CC (\" + U + \")\"), this.waitingFragment = null, this.state = g.State.IDLE) : (this.state = g.State.FRAG_LOADING, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null);\n            } else this.state = g.State.IDLE;\n\n            break;\n\n          case g.State.STOPPED:\n          case g.State.FRAG_LOADING:\n          case g.State.PARSING:\n          case g.State.PARSED:\n          case g.State.ENDED:\n        }\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        var t = this.media = this.mediaBuffer = e.media;\n        this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener(\"seeking\", this.onvseeking), t.addEventListener(\"ended\", this.onvended);\n        var r = this.config;\n        this.tracks && r.autoStartLoad && this.startLoad(r.startPosition);\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        var e = this.media;\n        e && e.ended && (f.logger.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0), e && (e.removeEventListener(\"seeking\", this.onvseeking), e.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.stopLoad();\n      }\n    }, {\n      key: \"onAudioTracksUpdated\",\n      value: function (e) {\n        f.logger.log(\"audio tracks updated\"), this.tracks = e.audioTracks;\n      }\n    }, {\n      key: \"onAudioTrackSwitching\",\n      value: function (e) {\n        var t = !!e.url;\n        this.trackId = e.id, this.fragCurrent = null, this.state = g.State.PAUSED, this.waitingFragment = null, t ? this.setInterval(100) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), t && (this.audioSwitch = !0, this.state = g.State.IDLE), this.tick();\n      }\n    }, {\n      key: \"onAudioTrackLoaded\",\n      value: function (e) {\n        var t = e.details,\n            r = e.id,\n            a = this.tracks[r],\n            i = t.totalduration,\n            n = 0;\n\n        if (f.logger.log(\"track \" + r + \" loaded [\" + t.startSN + \",\" + t.endSN + \"],duration:\" + i), t.live) {\n          var o = a.details;\n          o && t.fragments.length > 0 ? (l.mergeDetails(o, t), n = t.fragments[0].start, t.PTSKnown ? f.logger.log(\"live audio playlist sliding:\" + n.toFixed(3)) : f.logger.log(\"live audio playlist - outdated PTS, unknown sliding\")) : (t.PTSKnown = !1, f.logger.log(\"live audio playlist - first load, unknown sliding\"));\n        } else t.PTSKnown = !1;\n\n        if (a.details = t, !this.startFragRequested) {\n          if (-1 === this.startPosition) {\n            var s = t.startTimeOffset;\n            Number.isFinite(s) ? (f.logger.log(\"start time offset found in playlist, adjust startPosition to \" + s), this.startPosition = s) : this.startPosition = 0;\n          }\n\n          this.nextLoadPosition = this.startPosition;\n        }\n\n        this.state === g.State.WAITING_TRACK && (this.state = g.State.IDLE), this.tick();\n      }\n    }, {\n      key: \"onKeyLoaded\",\n      value: function () {\n        this.state === g.State.KEY_LOADING && (this.state = g.State.IDLE, this.tick());\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag;\n\n        if (this.state === g.State.FRAG_LOADING && t && \"audio\" === r.type && r.level === t.level && r.sn === t.sn) {\n          var a = this.tracks[this.trackId],\n              i = a.details,\n              n = i.totalduration,\n              l = t.level,\n              u = t.sn,\n              d = t.cc,\n              c = this.config.defaultAudioCodec || a.audioCodec || \"mp4a.40.2\",\n              h = this.stats = e.stats;\n          if (\"initSegment\" === u) this.state = g.State.IDLE, h.tparsed = h.tbuffered = m.now(), i.initSegment.data = e.payload, this.hls.trigger(s.default.FRAG_BUFFERED, {\n            stats: h,\n            frag: t,\n            id: \"audio\"\n          }), this.tick();else {\n            this.state = g.State.PARSING, this.appended = !1, this.demuxer || (this.demuxer = new o.default(this.hls, \"audio\"));\n            var v = this.initPTS[d],\n                p = i.initSegment ? i.initSegment.data : [];\n\n            if (i.initSegment || void 0 !== v) {\n              this.pendingBuffering = !0, f.logger.log(\"Demuxing \" + u + \" of [\" + i.startSN + \" ,\" + i.endSN + \"],track \" + l);\n              this.demuxer.push(e.payload, p, c, null, t, n, !1, v);\n            } else f.logger.log(\"unknown video PTS for continuity counter \" + d + \", waiting for video PTS before demuxing audio frag \" + u + \" of [\" + i.startSN + \" ,\" + i.endSN + \"],track \" + l), this.waitingFragment = e, this.state = g.State.WAITING_INIT_PTS;\n          }\n        }\n\n        this.fragLoadError = 0;\n      }\n    }, {\n      key: \"onFragParsingInitSegment\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag;\n\n        if (t && \"audio\" === e.id && r.sn === t.sn && r.level === t.level && this.state === g.State.PARSING) {\n          var a = e.tracks,\n              i = void 0;\n\n          if (a.video && delete a.video, i = a.audio) {\n            i.levelCodec = i.codec, i.id = e.id, this.hls.trigger(s.default.BUFFER_CODECS, a), f.logger.log(\"audio track:audio,container:\" + i.container + \",codecs[level/parsed]=[\" + i.levelCodec + \"/\" + i.codec + \"]\");\n            var n = i.initSegment;\n\n            if (n) {\n              var o = {\n                type: \"audio\",\n                data: n,\n                parent: \"audio\",\n                content: \"initSegment\"\n              };\n              this.audioSwitch ? this.pendingData = [o] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(s.default.BUFFER_APPENDING, o));\n            }\n\n            this.tick();\n          }\n        }\n      }\n    }, {\n      key: \"onFragParsingData\",\n      value: function (e) {\n        var t = this,\n            r = this.fragCurrent,\n            a = e.frag;\n\n        if (r && \"audio\" === e.id && \"audio\" === e.type && a.sn === r.sn && a.level === r.level && this.state === g.State.PARSING) {\n          var i = this.trackId,\n              n = this.tracks[i],\n              o = this.hls;\n          Number.isFinite(e.endPTS) || (e.endPTS = e.startPTS + r.duration, e.endDTS = e.startDTS + r.duration), r.addElementaryStream(v.default.ElementaryStreamTypes.AUDIO), f.logger.log(\"parsed \" + e.type + \",PTS:[\" + e.startPTS.toFixed(3) + \",\" + e.endPTS.toFixed(3) + \"],DTS:[\" + e.startDTS.toFixed(3) + \"/\" + e.endDTS.toFixed(3) + \"],nb:\" + e.nb), l.updateFragPTSDTS(n.details, r, e.startPTS, e.endPTS);\n          var u = this.audioSwitch,\n              c = this.media,\n              h = !1;\n          if (u && c) if (c.readyState) {\n            var p = c.currentTime;\n            f.logger.log(\"switching audio track : currentTime:\" + p), p >= e.startPTS && (f.logger.log(\"switching audio track : flushing all audio\"), this.state = g.State.BUFFER_FLUSHING, o.trigger(s.default.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: Number.POSITIVE_INFINITY,\n              type: \"audio\"\n            }), h = !0, this.audioSwitch = !1, o.trigger(s.default.AUDIO_TRACK_SWITCHED, {\n              id: i\n            }));\n          } else this.audioSwitch = !1, o.trigger(s.default.AUDIO_TRACK_SWITCHED, {\n            id: i\n          });\n          var y = this.pendingData;\n          if (!y) return f.logger.warn(\"Apparently attempt to enqueue media payload without codec initialization data upfront\"), void o.trigger(s.default.ERROR, {\n            type: d.ErrorTypes.MEDIA_ERROR,\n            details: null,\n            fatal: !0\n          });\n          this.audioSwitch || ([e.data1, e.data2].forEach(function (t) {\n            t && t.length && y.push({\n              type: e.type,\n              data: t,\n              parent: \"audio\",\n              content: \"data\"\n            });\n          }), !h && y.length && (y.forEach(function (e) {\n            t.state === g.State.PARSING && (t.pendingBuffering = !0, t.hls.trigger(s.default.BUFFER_APPENDING, e));\n          }), this.pendingData = [], this.appended = !0)), this.tick();\n        }\n      }\n    }, {\n      key: \"onFragParsed\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag;\n        t && \"audio\" === e.id && r.sn === t.sn && r.level === t.level && this.state === g.State.PARSING && (this.stats.tparsed = m.now(), this.state = g.State.PARSED, this._checkAppendedParsed());\n      }\n    }, {\n      key: \"onBufferReset\",\n      value: function () {\n        this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1;\n      }\n    }, {\n      key: \"onBufferCreated\",\n      value: function (e) {\n        var t = e.tracks.audio;\n        t && (this.mediaBuffer = t.buffer, this.loadedmetadata = !0), e.tracks.video && (this.videoBuffer = e.tracks.video.buffer);\n      }\n    }, {\n      key: \"onBufferAppended\",\n      value: function (e) {\n        if (\"audio\" === e.parent) {\n          var t = this.state;\n          t !== g.State.PARSING && t !== g.State.PARSED || (this.pendingBuffering = e.pending > 0, this._checkAppendedParsed());\n        }\n      }\n    }, {\n      key: \"_checkAppendedParsed\",\n      value: function () {\n        if (!(this.state !== g.State.PARSED || this.appended && this.pendingBuffering)) {\n          var e = this.fragCurrent,\n              t = this.stats,\n              r = this.hls;\n\n          if (e) {\n            this.fragPrevious = e, t.tbuffered = m.now(), r.trigger(s.default.FRAG_BUFFERED, {\n              stats: t,\n              frag: e,\n              id: \"audio\"\n            });\n            var a = this.mediaBuffer ? this.mediaBuffer : this.media;\n            f.logger.log(\"audio buffered : \" + u.default.toString(a.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, r.trigger(s.default.AUDIO_TRACK_SWITCHED, {\n              id: this.trackId\n            })), this.state = g.State.IDLE;\n          }\n\n          this.tick();\n        }\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        var t = e.frag;\n        if (!t || \"audio\" === t.type) switch (e.details) {\n          case d.ErrorDetails.FRAG_LOAD_ERROR:\n          case d.ErrorDetails.FRAG_LOAD_TIMEOUT:\n            var r = e.frag;\n            if (r && \"audio\" !== r.type) break;\n\n            if (!e.fatal) {\n              var a = this.fragLoadError;\n              a ? a++ : a = 1;\n              var i = this.config;\n\n              if (a <= i.fragLoadingMaxRetry) {\n                this.fragLoadError = a;\n                var o = Math.min(Math.pow(2, a - 1) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);\n                f.logger.warn(\"AudioStreamController: frag loading failed, retry in \" + o + \" ms\"), this.retryDate = m.now() + o, this.state = g.State.FRAG_LOADING_WAITING_RETRY;\n              } else f.logger.error(\"AudioStreamController: \" + e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.state = g.State.ERROR;\n            }\n\n            break;\n\n          case d.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n          case d.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n          case d.ErrorDetails.KEY_LOAD_ERROR:\n          case d.ErrorDetails.KEY_LOAD_TIMEOUT:\n            this.state !== g.State.ERROR && (this.state = e.fatal ? g.State.ERROR : g.State.IDLE, f.logger.warn(\"AudioStreamController: \" + e.details + \" while loading frag, now switching to \" + this.state + \" state ...\"));\n            break;\n\n          case d.ErrorDetails.BUFFER_FULL_ERROR:\n            if (\"audio\" === e.parent && (this.state === g.State.PARSING || this.state === g.State.PARSED)) {\n              var l = this.mediaBuffer,\n                  u = this.media.currentTime;\n\n              if (l && n.BufferHelper.isBuffered(l, u) && n.BufferHelper.isBuffered(l, u + .5)) {\n                var c = this.config;\n                c.maxMaxBufferLength >= c.maxBufferLength && (c.maxMaxBufferLength /= 2, f.logger.warn(\"AudioStreamController: reduce max buffer length to \" + c.maxMaxBufferLength + \"s\")), this.state = g.State.IDLE;\n              } else f.logger.warn(\"AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer\"), this.fragCurrent = null, this.state = g.State.BUFFER_FLUSHING, this.hls.trigger(s.default.BUFFER_FLUSHING, {\n                startOffset: 0,\n                endOffset: Number.POSITIVE_INFINITY,\n                type: \"audio\"\n              });\n            }\n\n        }\n      }\n    }, {\n      key: \"onBufferFlushed\",\n      value: function () {\n        var e = this,\n            t = this.pendingData;\n        t && t.length ? (f.logger.log(\"AudioStreamController: appending pending audio data after buffer flushed\"), t.forEach(function (t) {\n          e.hls.trigger(s.default.BUFFER_APPENDING, t);\n        }), this.appended = !0, this.pendingData = [], this.state = g.State.PARSED) : (this.state = g.State.IDLE, this.fragPrevious = null, this.tick());\n      }\n    }, {\n      key: \"state\",\n      set: function (e) {\n        if (this.state !== e) {\n          var t = this.state;\n          this._state = e, f.logger.log(\"audio stream:\" + t + \"->\" + e);\n        }\n      },\n      get: function () {\n        return this._state;\n      }\n    }]), t;\n  }(p.default);\n\n  t.default = b, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.newCue = function (e, t, r, i) {\n    for (var n = void 0, o = void 0, s = void 0, l = void 0, u = void 0, d = window.VTTCue || window.TextTrackCue, f = 0; f < i.rows.length; f++) if (n = i.rows[f], s = !0, l = 0, u = \"\", !n.isEmpty()) {\n      for (var c = 0; c < n.chars.length; c++) n.chars[c].uchar.match(/\\s/) && s ? l++ : (u += n.chars[c].uchar, s = !1);\n\n      n.cueStartTime = t, t === r && (r += 1e-4), o = new d(t, r, (0, a.fixLineBreaks)(u.trim())), l >= 16 ? l-- : l++, navigator.userAgent.match(/Firefox\\//) ? o.line = f + 1 : o.line = f > 7 ? f - 2 : f + 1, o.align = \"left\", o.position = Math.max(0, Math.min(100, l / 32 * 100 + (navigator.userAgent.match(/Firefox\\//) ? 50 : 0))), e.addCue(o);\n    }\n  };\n  var a = r(30);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.default = function () {\n    if (\"undefined\" != typeof window && window.VTTCue) return window.VTTCue;\n    var e = {\n      \"\": !0,\n      lr: !0,\n      rl: !0\n    },\n        t = {\n      start: !0,\n      middle: !0,\n      end: !0,\n      left: !0,\n      right: !0\n    };\n\n    function r(e) {\n      return \"string\" == typeof e && !!t[e.toLowerCase()] && e.toLowerCase();\n    }\n\n    function a(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var r = arguments[t];\n\n        for (var a in r) e[a] = r[a];\n      }\n\n      return e;\n    }\n\n    function i(t, i, n) {\n      var o = this,\n          s = function () {\n        if (\"undefined\" != typeof navigator) return /MSIE\\s8\\.0/.test(navigator.userAgent);\n      }(),\n          l = {};\n\n      s ? o = document.createElement(\"custom\") : l.enumerable = !0, o.hasBeenReset = !1;\n      var u = \"\",\n          d = !1,\n          f = t,\n          c = i,\n          h = n,\n          v = null,\n          g = \"\",\n          p = !0,\n          y = \"auto\",\n          m = \"start\",\n          b = 50,\n          E = \"middle\",\n          _ = 50,\n          T = \"middle\";\n      if (Object.defineProperty(o, \"id\", a({}, l, {\n        get: function () {\n          return u;\n        },\n        set: function (e) {\n          u = \"\" + e;\n        }\n      })), Object.defineProperty(o, \"pauseOnExit\", a({}, l, {\n        get: function () {\n          return d;\n        },\n        set: function (e) {\n          d = !!e;\n        }\n      })), Object.defineProperty(o, \"startTime\", a({}, l, {\n        get: function () {\n          return f;\n        },\n        set: function (e) {\n          if (\"number\" != typeof e) throw new TypeError(\"Start time must be set to a number.\");\n          f = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"endTime\", a({}, l, {\n        get: function () {\n          return c;\n        },\n        set: function (e) {\n          if (\"number\" != typeof e) throw new TypeError(\"End time must be set to a number.\");\n          c = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"text\", a({}, l, {\n        get: function () {\n          return h;\n        },\n        set: function (e) {\n          h = \"\" + e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"region\", a({}, l, {\n        get: function () {\n          return v;\n        },\n        set: function (e) {\n          v = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"vertical\", a({}, l, {\n        get: function () {\n          return g;\n        },\n        set: function (t) {\n          var r = function (t) {\n            return \"string\" == typeof t && !!e[t.toLowerCase()] && t.toLowerCase();\n          }(t);\n\n          if (!1 === r) throw new SyntaxError(\"An invalid or illegal string was specified.\");\n          g = r, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"snapToLines\", a({}, l, {\n        get: function () {\n          return p;\n        },\n        set: function (e) {\n          p = !!e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"line\", a({}, l, {\n        get: function () {\n          return y;\n        },\n        set: function (e) {\n          if (\"number\" != typeof e && \"auto\" !== e) throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n          y = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"lineAlign\", a({}, l, {\n        get: function () {\n          return m;\n        },\n        set: function (e) {\n          var t = r(e);\n          if (!t) throw new SyntaxError(\"An invalid or illegal string was specified.\");\n          m = t, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"position\", a({}, l, {\n        get: function () {\n          return b;\n        },\n        set: function (e) {\n          if (e < 0 || e > 100) throw new Error(\"Position must be between 0 and 100.\");\n          b = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"positionAlign\", a({}, l, {\n        get: function () {\n          return E;\n        },\n        set: function (e) {\n          var t = r(e);\n          if (!t) throw new SyntaxError(\"An invalid or illegal string was specified.\");\n          E = t, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"size\", a({}, l, {\n        get: function () {\n          return _;\n        },\n        set: function (e) {\n          if (e < 0 || e > 100) throw new Error(\"Size must be between 0 and 100.\");\n          _ = e, this.hasBeenReset = !0;\n        }\n      })), Object.defineProperty(o, \"align\", a({}, l, {\n        get: function () {\n          return T;\n        },\n        set: function (e) {\n          var t = r(e);\n          if (!t) throw new SyntaxError(\"An invalid or illegal string was specified.\");\n          T = t, this.hasBeenReset = !0;\n        }\n      })), o.displayState = void 0, s) return o;\n    }\n\n    return i.prototype.getCueAsHTML = function () {\n      return window.WebVTT.convertCueToDOMTree(window, this.text);\n    }, i;\n  }(), e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = f(r(1)),\n      n = f(r(3)),\n      o = f(r(73)),\n      s = f(r(74)),\n      l = f(r(75)),\n      u = r(0),\n      d = r(29);\n\n  function f(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  function c(e, t) {\n    return e && e.label === t.name && !(e.textTrack1 || e.textTrack2);\n  }\n\n  var h = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHING, i.default.MEDIA_DETACHING, i.default.FRAG_PARSING_USERDATA, i.default.FRAG_DECRYPTED, i.default.MANIFEST_LOADING, i.default.MANIFEST_LOADED, i.default.FRAG_LOADED, i.default.LEVEL_SWITCHING, i.default.INIT_PTS_FOUND));\n\n      if (r.hls = e, r.config = e.config, r.enabled = !0, r.Cues = e.config.cueHandler, r.textTracks = [], r.tracks = [], r.unparsedVttFrags = [], r.initPTS = [], r.cueRanges = [], r.captionsTracks = {}, r.captionsProperties = {\n        textTrack1: {\n          label: r.config.captionsTextTrack1Label,\n          languageCode: r.config.captionsTextTrack1LanguageCode\n        },\n        textTrack2: {\n          label: r.config.captionsTextTrack2Label,\n          languageCode: r.config.captionsTextTrack2LanguageCode\n        }\n      }, r.config.enableCEA708Captions) {\n        var a = new s.default(r, \"textTrack1\"),\n            n = new s.default(r, \"textTrack2\");\n        r.cea608Parser = new o.default(0, a, n);\n      }\n\n      return r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"addCues\",\n      value: function (e, t, r, a) {\n        for (var i, n, o, s, l = this.cueRanges, u = !1, d = l.length; d--;) {\n          var f = l[d],\n              c = (i = f[0], n = f[1], o = t, s = r, Math.min(n, s) - Math.max(i, o));\n          if (c >= 0 && (f[0] = Math.min(f[0], t), f[1] = Math.max(f[1], r), u = !0, c / (r - t) > .5)) return;\n        }\n\n        u || l.push([t, r]), this.Cues.newCue(this.captionsTracks[e], t, r, a);\n      }\n    }, {\n      key: \"onInitPtsFound\",\n      value: function (e) {\n        var t = this;\n\n        if (\"main\" === e.id && (this.initPTS[e.frag.cc] = e.initPTS), this.unparsedVttFrags.length) {\n          var r = this.unparsedVttFrags;\n          this.unparsedVttFrags = [], r.forEach(function (e) {\n            t.onFragLoaded(e);\n          });\n        }\n      }\n    }, {\n      key: \"getExistingTrack\",\n      value: function (e) {\n        var t = this.media;\n        if (t) for (var r = 0; r < t.textTracks.length; r++) {\n          var a = t.textTracks[r];\n          if (a[e]) return a;\n        }\n        return null;\n      }\n    }, {\n      key: \"createCaptionsTrack\",\n      value: function (e) {\n        var t = this.captionsProperties[e],\n            r = t.label,\n            a = t.languageCode,\n            i = this.captionsTracks;\n\n        if (!i[e]) {\n          var n = this.getExistingTrack(e);\n          if (n) i[e] = n, (0, d.clearCurrentCues)(i[e]), (0, d.sendAddTrackEvent)(i[e], this.media);else {\n            var o = this.createTextTrack(\"captions\", r, a);\n            o && (o[e] = !0, i[e] = o);\n          }\n        }\n      }\n    }, {\n      key: \"createTextTrack\",\n      value: function (e, t, r) {\n        var a = this.media;\n        if (a) return a.addTextTrack(e, t, r);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onMediaAttaching\",\n      value: function (e) {\n        this.media = e.media, this._cleanTracks();\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        var e = this.captionsTracks;\n        Object.keys(e).forEach(function (t) {\n          (0, d.clearCurrentCues)(e[t]), delete e[t];\n        });\n      }\n    }, {\n      key: \"onManifestLoading\",\n      value: function () {\n        this.lastSn = -1, this.prevCC = -1, this.vttCCs = {\n          ccOffset: 0,\n          presentationOffset: 0,\n          0: {\n            start: 0,\n            prevCC: -1,\n            new: !1\n          }\n        }, this._cleanTracks();\n      }\n    }, {\n      key: \"_cleanTracks\",\n      value: function () {\n        var e = this.media;\n\n        if (e) {\n          var t = e.textTracks;\n          if (t) for (var r = 0; r < t.length; r++) (0, d.clearCurrentCues)(t[r]);\n        }\n      }\n    }, {\n      key: \"onManifestLoaded\",\n      value: function (e) {\n        var t = this;\n\n        if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cueRanges = [], this.config.enableWebVTT) {\n          this.tracks = e.subtitles || [];\n          var r = this.media ? this.media.textTracks : [];\n          this.tracks.forEach(function (e, a) {\n            var i = void 0;\n\n            if (a < r.length) {\n              for (var n = null, o = 0; o < r.length; o++) if (c(r[o], e)) {\n                n = r[o];\n                break;\n              }\n\n              n && (i = n);\n            }\n\n            i || (i = t.createTextTrack(\"subtitles\", e.name, e.lang)), e.default ? i.mode = t.hls.subtitleDisplay ? \"showing\" : \"hidden\" : i.mode = \"disabled\", t.textTracks.push(i);\n          });\n        }\n      }\n    }, {\n      key: \"onLevelSwitching\",\n      value: function () {\n        this.enabled = \"NONE\" !== this.hls.currentLevel.closedCaptions;\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = e.frag,\n            r = e.payload;\n\n        if (\"main\" === t.type) {\n          var a = t.sn;\n\n          if (a !== this.lastSn + 1) {\n            var n = this.cea608Parser;\n            n && n.reset();\n          }\n\n          this.lastSn = a;\n        } else if (\"subtitle\" === t.type) if (r.byteLength) {\n          if (!Number.isFinite(this.initPTS[t.cc])) return this.unparsedVttFrags.push(e), void (this.initPTS.length && this.hls.trigger(i.default.SUBTITLE_FRAG_PROCESSED, {\n            success: !1,\n            frag: t\n          }));\n          var o = t.decryptdata;\n          null != o && null != o.key && \"AES-128\" === o.method || this._parseVTTs(t, r);\n        } else this.hls.trigger(i.default.SUBTITLE_FRAG_PROCESSED, {\n          success: !1,\n          frag: t\n        });\n      }\n    }, {\n      key: \"_parseVTTs\",\n      value: function (e, t) {\n        var r = this.vttCCs;\n        r[e.cc] || (r[e.cc] = {\n          start: e.start,\n          prevCC: this.prevCC,\n          new: !0\n        }, this.prevCC = e.cc);\n        var a = this.textTracks,\n            n = this.hls;\n        l.default.parse(t, this.initPTS[e.cc], r, e.cc, function (t) {\n          var r = a[e.level];\n          \"disabled\" !== r.mode ? (t.forEach(function (e) {\n            if (!r.cues.getCueById(e.id)) try {\n              r.addCue(e);\n            } catch (a) {\n              var t = new window.TextTrackCue(e.startTime, e.endTime, e.text);\n              t.id = e.id, r.addCue(t);\n            }\n          }), n.trigger(i.default.SUBTITLE_FRAG_PROCESSED, {\n            success: !0,\n            frag: e\n          })) : n.trigger(i.default.SUBTITLE_FRAG_PROCESSED, {\n            success: !1,\n            frag: e\n          });\n        }, function (t) {\n          u.logger.log(\"Failed to parse VTT cue: \" + t), n.trigger(i.default.SUBTITLE_FRAG_PROCESSED, {\n            success: !1,\n            frag: e\n          });\n        });\n      }\n    }, {\n      key: \"onFragDecrypted\",\n      value: function (e) {\n        var t = e.payload,\n            r = e.frag;\n\n        if (\"subtitle\" === r.type) {\n          if (!Number.isFinite(this.initPTS[r.cc])) return void this.unparsedVttFrags.push(e);\n\n          this._parseVTTs(r, t);\n        }\n      }\n    }, {\n      key: \"onFragParsingUserdata\",\n      value: function (e) {\n        if (this.enabled && this.config.enableCEA708Captions) for (var t = 0; t < e.samples.length; t++) {\n          var r = this.extractCea608Data(e.samples[t].bytes);\n          this.cea608Parser.addData(e.samples[t].pts, r);\n        }\n      }\n    }, {\n      key: \"extractCea608Data\",\n      value: function (e) {\n        for (var t = 31 & e[0], r = 2, a = void 0, i = void 0, n = void 0, o = [], s = 0; s < t; s++) a = e[r++], i = 127 & e[r++], n = 127 & e[r++], 0 === i && 0 === n || 0 != (4 & a) && 0 === (3 & a) && (o.push(i), o.push(n));\n\n        return o;\n      }\n    }]), t;\n  }(n.default);\n\n  t.default = h, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  function i(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var n = {\n    42: 225,\n    92: 233,\n    94: 237,\n    95: 243,\n    96: 250,\n    123: 231,\n    124: 247,\n    125: 209,\n    126: 241,\n    127: 9608,\n    128: 174,\n    129: 176,\n    130: 189,\n    131: 191,\n    132: 8482,\n    133: 162,\n    134: 163,\n    135: 9834,\n    136: 224,\n    137: 32,\n    138: 232,\n    139: 226,\n    140: 234,\n    141: 238,\n    142: 244,\n    143: 251,\n    144: 193,\n    145: 201,\n    146: 211,\n    147: 218,\n    148: 220,\n    149: 252,\n    150: 8216,\n    151: 161,\n    152: 42,\n    153: 8217,\n    154: 9473,\n    155: 169,\n    156: 8480,\n    157: 8226,\n    158: 8220,\n    159: 8221,\n    160: 192,\n    161: 194,\n    162: 199,\n    163: 200,\n    164: 202,\n    165: 203,\n    166: 235,\n    167: 206,\n    168: 207,\n    169: 239,\n    170: 212,\n    171: 217,\n    172: 249,\n    173: 219,\n    174: 171,\n    175: 187,\n    176: 195,\n    177: 227,\n    178: 205,\n    179: 204,\n    180: 236,\n    181: 210,\n    182: 242,\n    183: 213,\n    184: 245,\n    185: 123,\n    186: 125,\n    187: 92,\n    188: 94,\n    189: 95,\n    190: 124,\n    191: 8764,\n    192: 196,\n    193: 228,\n    194: 214,\n    195: 246,\n    196: 223,\n    197: 165,\n    198: 164,\n    199: 9475,\n    200: 197,\n    201: 229,\n    202: 216,\n    203: 248,\n    204: 9487,\n    205: 9491,\n    206: 9495,\n    207: 9499\n  },\n      o = function (e) {\n    var t = e;\n    return n.hasOwnProperty(e) && (t = n[e]), String.fromCharCode(t);\n  },\n      s = {\n    17: 1,\n    18: 3,\n    21: 5,\n    22: 7,\n    23: 9,\n    16: 11,\n    19: 12,\n    20: 14\n  },\n      l = {\n    17: 2,\n    18: 4,\n    21: 6,\n    22: 8,\n    23: 10,\n    19: 13,\n    20: 15\n  },\n      u = {\n    25: 1,\n    26: 3,\n    29: 5,\n    30: 7,\n    31: 9,\n    24: 11,\n    27: 12,\n    28: 14\n  },\n      d = {\n    25: 2,\n    26: 4,\n    29: 6,\n    30: 8,\n    31: 10,\n    27: 13,\n    28: 15\n  },\n      f = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"black\", \"transparent\"],\n      c = {\n    verboseFilter: {\n      DATA: 3,\n      DEBUG: 3,\n      INFO: 2,\n      WARNING: 2,\n      TEXT: 1,\n      ERROR: 0\n    },\n    time: null,\n    verboseLevel: 0,\n    setTime: function (e) {\n      this.time = e;\n    },\n    log: function (e, t) {\n      this.verboseFilter[e];\n      this.verboseLevel;\n    }\n  },\n      h = function (e) {\n    for (var t = [], r = 0; r < e.length; r++) t.push(e[r].toString(16));\n\n    return t;\n  },\n      v = function () {\n    function e(t, r, a, n, o) {\n      i(this, e), this.foreground = t || \"white\", this.underline = r || !1, this.italics = a || !1, this.background = n || \"black\", this.flash = o || !1;\n    }\n\n    return a(e, [{\n      key: \"reset\",\n      value: function () {\n        this.foreground = \"white\", this.underline = !1, this.italics = !1, this.background = \"black\", this.flash = !1;\n      }\n    }, {\n      key: \"setStyles\",\n      value: function (e) {\n        for (var t = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"], r = 0; r < t.length; r++) {\n          var a = t[r];\n          e.hasOwnProperty(a) && (this[a] = e[a]);\n        }\n      }\n    }, {\n      key: \"isDefault\",\n      value: function () {\n        return \"white\" === this.foreground && !this.underline && !this.italics && \"black\" === this.background && !this.flash;\n      }\n    }, {\n      key: \"equals\",\n      value: function (e) {\n        return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;\n      }\n    }, {\n      key: \"copy\",\n      value: function (e) {\n        this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n      }\n    }]), e;\n  }(),\n      g = function () {\n    function e(t, r, a, n, o, s) {\n      i(this, e), this.uchar = t || \" \", this.penState = new v(r, a, n, o, s);\n    }\n\n    return a(e, [{\n      key: \"reset\",\n      value: function () {\n        this.uchar = \" \", this.penState.reset();\n      }\n    }, {\n      key: \"setChar\",\n      value: function (e, t) {\n        this.uchar = e, this.penState.copy(t);\n      }\n    }, {\n      key: \"setPenState\",\n      value: function (e) {\n        this.penState.copy(e);\n      }\n    }, {\n      key: \"equals\",\n      value: function (e) {\n        return this.uchar === e.uchar && this.penState.equals(e.penState);\n      }\n    }, {\n      key: \"copy\",\n      value: function (e) {\n        this.uchar = e.uchar, this.penState.copy(e.penState);\n      }\n    }, {\n      key: \"isEmpty\",\n      value: function () {\n        return \" \" === this.uchar && this.penState.isDefault();\n      }\n    }]), e;\n  }(),\n      p = function () {\n    function e() {\n      i(this, e), this.chars = [];\n\n      for (var t = 0; t < 100; t++) this.chars.push(new g());\n\n      this.pos = 0, this.currPenState = new v();\n    }\n\n    return a(e, [{\n      key: \"equals\",\n      value: function (e) {\n        for (var t = !0, r = 0; r < 100; r++) if (!this.chars[r].equals(e.chars[r])) {\n          t = !1;\n          break;\n        }\n\n        return t;\n      }\n    }, {\n      key: \"copy\",\n      value: function (e) {\n        for (var t = 0; t < 100; t++) this.chars[t].copy(e.chars[t]);\n      }\n    }, {\n      key: \"isEmpty\",\n      value: function () {\n        for (var e = !0, t = 0; t < 100; t++) if (!this.chars[t].isEmpty()) {\n          e = !1;\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"setCursor\",\n      value: function (e) {\n        this.pos !== e && (this.pos = e), this.pos < 0 ? (c.log(\"ERROR\", \"Negative cursor position \" + this.pos), this.pos = 0) : this.pos > 100 && (c.log(\"ERROR\", \"Too large cursor position \" + this.pos), this.pos = 100);\n      }\n    }, {\n      key: \"moveCursor\",\n      value: function (e) {\n        var t = this.pos + e;\n        if (e > 1) for (var r = this.pos + 1; r < t + 1; r++) this.chars[r].setPenState(this.currPenState);\n        this.setCursor(t);\n      }\n    }, {\n      key: \"backSpace\",\n      value: function () {\n        this.moveCursor(-1), this.chars[this.pos].setChar(\" \", this.currPenState);\n      }\n    }, {\n      key: \"insertChar\",\n      value: function (e) {\n        e >= 144 && this.backSpace();\n        var t = o(e);\n        this.pos >= 100 ? c.log(\"ERROR\", \"Cannot insert \" + e.toString(16) + \" (\" + t + \") at position \" + this.pos + \". Skipping it!\") : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1));\n      }\n    }, {\n      key: \"clearFromPos\",\n      value: function (e) {\n        var t = void 0;\n\n        for (t = e; t < 100; t++) this.chars[t].reset();\n      }\n    }, {\n      key: \"clear\",\n      value: function () {\n        this.clearFromPos(0), this.pos = 0, this.currPenState.reset();\n      }\n    }, {\n      key: \"clearToEndOfRow\",\n      value: function () {\n        this.clearFromPos(this.pos);\n      }\n    }, {\n      key: \"getTextString\",\n      value: function () {\n        for (var e = [], t = !0, r = 0; r < 100; r++) {\n          var a = this.chars[r].uchar;\n          \" \" !== a && (t = !1), e.push(a);\n        }\n\n        return t ? \"\" : e.join(\"\");\n      }\n    }, {\n      key: \"setPenStyles\",\n      value: function (e) {\n        this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);\n      }\n    }]), e;\n  }(),\n      y = function () {\n    function e() {\n      i(this, e), this.rows = [];\n\n      for (var t = 0; t < 15; t++) this.rows.push(new p());\n\n      this.currRow = 14, this.nrRollUpRows = null, this.reset();\n    }\n\n    return a(e, [{\n      key: \"reset\",\n      value: function () {\n        for (var e = 0; e < 15; e++) this.rows[e].clear();\n\n        this.currRow = 14;\n      }\n    }, {\n      key: \"equals\",\n      value: function (e) {\n        for (var t = !0, r = 0; r < 15; r++) if (!this.rows[r].equals(e.rows[r])) {\n          t = !1;\n          break;\n        }\n\n        return t;\n      }\n    }, {\n      key: \"copy\",\n      value: function (e) {\n        for (var t = 0; t < 15; t++) this.rows[t].copy(e.rows[t]);\n      }\n    }, {\n      key: \"isEmpty\",\n      value: function () {\n        for (var e = !0, t = 0; t < 15; t++) if (!this.rows[t].isEmpty()) {\n          e = !1;\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"backSpace\",\n      value: function () {\n        this.rows[this.currRow].backSpace();\n      }\n    }, {\n      key: \"clearToEndOfRow\",\n      value: function () {\n        this.rows[this.currRow].clearToEndOfRow();\n      }\n    }, {\n      key: \"insertChar\",\n      value: function (e) {\n        this.rows[this.currRow].insertChar(e);\n      }\n    }, {\n      key: \"setPen\",\n      value: function (e) {\n        this.rows[this.currRow].setPenStyles(e);\n      }\n    }, {\n      key: \"moveCursor\",\n      value: function (e) {\n        this.rows[this.currRow].moveCursor(e);\n      }\n    }, {\n      key: \"setCursor\",\n      value: function (e) {\n        c.log(\"INFO\", \"setCursor: \" + e), this.rows[this.currRow].setCursor(e);\n      }\n    }, {\n      key: \"setPAC\",\n      value: function (e) {\n        c.log(\"INFO\", \"pacData = \" + JSON.stringify(e));\n        var t = e.row - 1;\n\n        if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {\n          for (var r = 0; r < 15; r++) this.rows[r].clear();\n\n          var a = this.currRow + 1 - this.nrRollUpRows,\n              i = this.lastOutputScreen;\n\n          if (i) {\n            var n = i.rows[a].cueStartTime;\n            if (n && n < c.time) for (var o = 0; o < this.nrRollUpRows; o++) this.rows[t - this.nrRollUpRows + o + 1].copy(i.rows[a + o]);\n          }\n        }\n\n        this.currRow = t;\n        var s = this.rows[this.currRow];\n\n        if (null !== e.indent) {\n          var l = e.indent,\n              u = Math.max(l - 1, 0);\n          s.setCursor(e.indent), e.color = s.chars[u].penState.foreground;\n        }\n\n        var d = {\n          foreground: e.color,\n          underline: e.underline,\n          italics: e.italics,\n          background: \"black\",\n          flash: !1\n        };\n        this.setPen(d);\n      }\n    }, {\n      key: \"setBkgData\",\n      value: function (e) {\n        c.log(\"INFO\", \"bkgData = \" + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32);\n      }\n    }, {\n      key: \"setRollUpRows\",\n      value: function (e) {\n        this.nrRollUpRows = e;\n      }\n    }, {\n      key: \"rollUp\",\n      value: function () {\n        if (null !== this.nrRollUpRows) {\n          c.log(\"TEXT\", this.getDisplayText());\n          var e = this.currRow + 1 - this.nrRollUpRows,\n              t = this.rows.splice(e, 1)[0];\n          t.clear(), this.rows.splice(this.currRow, 0, t), c.log(\"INFO\", \"Rolling up\");\n        } else c.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n      }\n    }, {\n      key: \"getDisplayText\",\n      value: function (e) {\n        e = e || !1;\n\n        for (var t = [], r = \"\", a = -1, i = 0; i < 15; i++) {\n          var n = this.rows[i].getTextString();\n          n && (a = i + 1, e ? t.push(\"Row \" + a + \": '\" + n + \"'\") : t.push(n.trim()));\n        }\n\n        return t.length > 0 && (r = e ? \"[\" + t.join(\" | \") + \"]\" : t.join(\"\\n\")), r;\n      }\n    }, {\n      key: \"getTextAndFormat\",\n      value: function () {\n        return this.rows;\n      }\n    }]), e;\n  }(),\n      m = function () {\n    function e(t, r) {\n      i(this, e), this.chNr = t, this.outputFilter = r, this.mode = null, this.verbose = 0, this.displayedMemory = new y(), this.nonDisplayedMemory = new y(), this.lastOutputScreen = new y(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;\n    }\n\n    return a(e, [{\n      key: \"reset\",\n      value: function () {\n        this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;\n      }\n    }, {\n      key: \"getHandler\",\n      value: function () {\n        return this.outputFilter;\n      }\n    }, {\n      key: \"setHandler\",\n      value: function (e) {\n        this.outputFilter = e;\n      }\n    }, {\n      key: \"setPAC\",\n      value: function (e) {\n        this.writeScreen.setPAC(e);\n      }\n    }, {\n      key: \"setBkgData\",\n      value: function (e) {\n        this.writeScreen.setBkgData(e);\n      }\n    }, {\n      key: \"setMode\",\n      value: function (e) {\n        e !== this.mode && (this.mode = e, c.log(\"INFO\", \"MODE=\" + e), \"MODE_POP-ON\" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), \"MODE_ROLL-UP\" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);\n      }\n    }, {\n      key: \"insertChars\",\n      value: function (e) {\n        for (var t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);\n\n        var r = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n        c.log(\"INFO\", r + \": \" + this.writeScreen.getDisplayText(!0)), \"MODE_PAINT-ON\" !== this.mode && \"MODE_ROLL-UP\" !== this.mode || (c.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());\n      }\n    }, {\n      key: \"ccRCL\",\n      value: function () {\n        c.log(\"INFO\", \"RCL - Resume Caption Loading\"), this.setMode(\"MODE_POP-ON\");\n      }\n    }, {\n      key: \"ccBS\",\n      value: function () {\n        c.log(\"INFO\", \"BS - BackSpace\"), \"MODE_TEXT\" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());\n      }\n    }, {\n      key: \"ccAOF\",\n      value: function () {}\n    }, {\n      key: \"ccAON\",\n      value: function () {}\n    }, {\n      key: \"ccDER\",\n      value: function () {\n        c.log(\"INFO\", \"DER- Delete to End of Row\"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();\n      }\n    }, {\n      key: \"ccRU\",\n      value: function (e) {\n        c.log(\"INFO\", \"RU(\" + e + \") - Roll Up\"), this.writeScreen = this.displayedMemory, this.setMode(\"MODE_ROLL-UP\"), this.writeScreen.setRollUpRows(e);\n      }\n    }, {\n      key: \"ccFON\",\n      value: function () {\n        c.log(\"INFO\", \"FON - Flash On\"), this.writeScreen.setPen({\n          flash: !0\n        });\n      }\n    }, {\n      key: \"ccRDC\",\n      value: function () {\n        c.log(\"INFO\", \"RDC - Resume Direct Captioning\"), this.setMode(\"MODE_PAINT-ON\");\n      }\n    }, {\n      key: \"ccTR\",\n      value: function () {\n        c.log(\"INFO\", \"TR\"), this.setMode(\"MODE_TEXT\");\n      }\n    }, {\n      key: \"ccRTD\",\n      value: function () {\n        c.log(\"INFO\", \"RTD\"), this.setMode(\"MODE_TEXT\");\n      }\n    }, {\n      key: \"ccEDM\",\n      value: function () {\n        c.log(\"INFO\", \"EDM - Erase Displayed Memory\"), this.displayedMemory.reset(), this.outputDataUpdate(!0);\n      }\n    }, {\n      key: \"ccCR\",\n      value: function () {\n        c.log(\"CR - Carriage Return\"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);\n      }\n    }, {\n      key: \"ccENM\",\n      value: function () {\n        c.log(\"INFO\", \"ENM - Erase Non-displayed Memory\"), this.nonDisplayedMemory.reset();\n      }\n    }, {\n      key: \"ccEOC\",\n      value: function () {\n        if (c.log(\"INFO\", \"EOC - End Of Caption\"), \"MODE_POP-ON\" === this.mode) {\n          var e = this.displayedMemory;\n          this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, c.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n        }\n\n        this.outputDataUpdate(!0);\n      }\n    }, {\n      key: \"ccTO\",\n      value: function (e) {\n        c.log(\"INFO\", \"TO(\" + e + \") - Tab Offset\"), this.writeScreen.moveCursor(e);\n      }\n    }, {\n      key: \"ccMIDROW\",\n      value: function (e) {\n        var t = {\n          flash: !1\n        };\n        if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = \"white\";else {\n          var r = Math.floor(e / 2) - 16;\n          t.foreground = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"][r];\n        }\n        c.log(\"INFO\", \"MIDROW: \" + JSON.stringify(t)), this.writeScreen.setPen(t);\n      }\n    }, {\n      key: \"outputDataUpdate\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n            t = c.time;\n        null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), !0 === e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue()), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory));\n      }\n    }, {\n      key: \"cueSplitAtTime\",\n      value: function (e) {\n        this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));\n      }\n    }]), e;\n  }(),\n      b = function () {\n    function e(t, r, a) {\n      i(this, e), this.field = t || 1, this.outputs = [r, a], this.channels = [new m(1, r), new m(2, a)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = {\n        padding: 0,\n        char: 0,\n        cmd: 0,\n        other: 0\n      };\n    }\n\n    return a(e, [{\n      key: \"getHandler\",\n      value: function (e) {\n        return this.channels[e].getHandler();\n      }\n    }, {\n      key: \"setHandler\",\n      value: function (e, t) {\n        this.channels[e].setHandler(t);\n      }\n    }, {\n      key: \"addData\",\n      value: function (e, t) {\n        var r = void 0,\n            a = void 0,\n            i = void 0,\n            n = !1;\n        this.lastTime = e, c.setTime(e);\n\n        for (var o = 0; o < t.length; o += 2) if (a = 127 & t[o], i = 127 & t[o + 1], 0 !== a || 0 !== i) {\n          if (c.log(\"DATA\", \"[\" + h([t[o], t[o + 1]]) + \"] -> (\" + h([a, i]) + \")\"), (r = this.parseCmd(a, i)) || (r = this.parseMidrow(a, i)), r || (r = this.parsePAC(a, i)), r || (r = this.parseBackgroundAttributes(a, i)), !r) if (n = this.parseChars(a, i)) if (this.currChNr && this.currChNr >= 0) this.channels[this.currChNr - 1].insertChars(n);else c.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n          r ? this.dataCounters.cmd += 2 : n ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, c.log(\"WARNING\", \"Couldn't parse cleaned data \" + h([a, i]) + \" orig: \" + h([t[o], t[o + 1]])));\n        } else this.dataCounters.padding += 2;\n      }\n    }, {\n      key: \"parseCmd\",\n      value: function (e, t) {\n        var r = null;\n        if (!((20 === e || 28 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 33 && t <= 35)) return !1;\n        if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, c.log(\"DEBUG\", \"Repeated command (\" + h([e, t]) + \") is dropped\"), !0;\n        r = 20 === e || 23 === e ? 1 : 2;\n        var a = this.channels[r - 1];\n        return 20 === e || 28 === e ? 32 === t ? a.ccRCL() : 33 === t ? a.ccBS() : 34 === t ? a.ccAOF() : 35 === t ? a.ccAON() : 36 === t ? a.ccDER() : 37 === t ? a.ccRU(2) : 38 === t ? a.ccRU(3) : 39 === t ? a.ccRU(4) : 40 === t ? a.ccFON() : 41 === t ? a.ccRDC() : 42 === t ? a.ccTR() : 43 === t ? a.ccRTD() : 44 === t ? a.ccEDM() : 45 === t ? a.ccCR() : 46 === t ? a.ccENM() : 47 === t && a.ccEOC() : a.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0;\n      }\n    }, {\n      key: \"parseMidrow\",\n      value: function (e, t) {\n        var r = null;\n        return (17 === e || 25 === e) && t >= 32 && t <= 47 && ((r = 17 === e ? 1 : 2) !== this.currChNr ? (c.log(\"ERROR\", \"Mismatch channel in midrow parsing\"), !1) : (this.channels[r - 1].ccMIDROW(t), c.log(\"DEBUG\", \"MIDROW (\" + h([e, t]) + \")\"), !0));\n      }\n    }, {\n      key: \"parsePAC\",\n      value: function (e, t) {\n        var r,\n            a = null;\n        if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127) && !((16 === e || 24 === e) && t >= 64 && t <= 95)) return !1;\n        if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, !0;\n        r = e <= 23 ? 1 : 2, a = t >= 64 && t <= 95 ? 1 === r ? s[e] : u[e] : 1 === r ? l[e] : d[e];\n        var i = this.interpretPAC(a, t);\n        return this.channels[r - 1].setPAC(i), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0;\n      }\n    }, {\n      key: \"interpretPAC\",\n      value: function (e, t) {\n        var r = t,\n            a = {\n          color: null,\n          italics: !1,\n          indent: null,\n          underline: !1,\n          row: e\n        };\n        return r = t > 95 ? t - 96 : t - 64, a.underline = 1 == (1 & r), r <= 13 ? a.color = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"white\"][Math.floor(r / 2)] : r <= 15 ? (a.italics = !0, a.color = \"white\") : a.indent = 4 * Math.floor((r - 16) / 2), a;\n      }\n    }, {\n      key: \"parseChars\",\n      value: function (e, t) {\n        var r = null,\n            a = null,\n            i = null;\n\n        if (e >= 25 ? (r = 2, i = e - 8) : (r = 1, i = e), i >= 17 && i <= 19) {\n          var n = t;\n          n = 17 === i ? t + 80 : 18 === i ? t + 112 : t + 144, c.log(\"INFO\", \"Special char '\" + o(n) + \"' in channel \" + r), a = [n];\n        } else e >= 32 && e <= 127 && (a = 0 === t ? [e] : [e, t]);\n\n        if (a) {\n          var s = h(a);\n          c.log(\"DEBUG\", \"Char codes =  \" + s.join(\",\")), this.lastCmdA = null, this.lastCmdB = null;\n        }\n\n        return a;\n      }\n    }, {\n      key: \"parseBackgroundAttributes\",\n      value: function (e, t) {\n        var r,\n            a = void 0,\n            i = void 0;\n        return ((16 === e || 24 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 45 && t <= 47) && (a = {}, 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), a.background = f[i], t % 2 == 1 && (a.background = a.background + \"_semi\")) : 45 === t ? a.background = \"transparent\" : (a.foreground = \"black\", 47 === t && (a.underline = !0)), r = e < 24 ? 1 : 2, this.channels[r - 1].setBkgData(a), this.lastCmdA = null, this.lastCmdB = null, !0);\n      }\n    }, {\n      key: \"reset\",\n      value: function () {\n        for (var e = 0; e < this.channels.length; e++) this.channels[e] && this.channels[e].reset();\n\n        this.lastCmdA = null, this.lastCmdB = null;\n      }\n    }, {\n      key: \"cueSplitAtTime\",\n      value: function (e) {\n        for (var t = 0; t < this.channels.length; t++) this.channels[t] && this.channels[t].cueSplitAtTime(e);\n      }\n    }]), e;\n  }();\n\n  t.default = b, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }();\n\n  var i = function () {\n    function e(t, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.timelineController = t, this.trackName = r, this.startTime = null, this.endTime = null, this.screen = null;\n    }\n\n    return a(e, [{\n      key: \"dispatchCue\",\n      value: function () {\n        null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen), this.startTime = null);\n      }\n    }, {\n      key: \"newCue\",\n      value: function (e, t, r) {\n        (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);\n      }\n    }]), e;\n  }();\n\n  t.default = i, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a,\n      i = r(30),\n      n = (a = i) && a.__esModule ? a : {\n    default: a\n  },\n      o = r(10);\n\n  var s = function (e, t, r) {\n    return e.substr(r || 0, t.length) === t;\n  },\n      l = function (e) {\n    for (var t = 5381, r = e.length; r;) t = 33 * t ^ e.charCodeAt(--r);\n\n    return (t >>> 0).toString();\n  },\n      u = {\n    parse: function (e, t, r, a, i, u) {\n      var d = (0, o.utf8ArrayToStr)(new Uint8Array(e)).trim().replace(/\\r\\n|\\n\\r|\\n|\\r/g, \"\\n\").split(\"\\n\"),\n          f = \"00:00.000\",\n          c = 0,\n          h = 0,\n          v = 0,\n          g = [],\n          p = void 0,\n          y = !0,\n          m = new n.default();\n      m.oncue = function (e) {\n        var t = r[a],\n            i = r.ccOffset;\n        t && t.new && (void 0 !== h ? i = r.ccOffset = t.start : function (e, t, r) {\n          var a = e[t],\n              i = e[a.prevCC];\n          if (!i || !i.new && a.new) return e.ccOffset = e.presentationOffset = a.start, void (a.new = !1);\n\n          for (; i && i.new;) e.ccOffset += a.start - i.start, a.new = !1, i = e[(a = i).prevCC];\n\n          e.presentationOffset = r;\n        }(r, a, v)), v && (i = v - r.presentationOffset), e.startTime += i - h, e.endTime += i - h, e.id = l(e.startTime.toString()) + l(e.endTime.toString()) + l(e.text), e.text = decodeURIComponent(encodeURIComponent(e.text)), e.endTime > 0 && g.push(e);\n      }, m.onparsingerror = function (e) {\n        p = e;\n      }, m.onflush = function () {\n        p && u ? u(p) : i(g);\n      }, d.forEach(function (e) {\n        if (y) {\n          if (s(e, \"X-TIMESTAMP-MAP=\")) {\n            y = !1, e.substr(16).split(\",\").forEach(function (e) {\n              s(e, \"LOCAL:\") ? f = e.substr(6) : s(e, \"MPEGTS:\") && (c = parseInt(e.substr(7)));\n            });\n\n            try {\n              t + (9e4 * r[a].start || 0) < 0 && (t += 8589934592), c -= t, i = f, n = parseInt(i.substr(-3)), o = parseInt(i.substr(-6, 2)), l = parseInt(i.substr(-9, 2)), u = i.length > 9 ? parseInt(i.substr(0, i.indexOf(\":\"))) : 0, h = (Number.isFinite(n) && Number.isFinite(o) && Number.isFinite(l) && Number.isFinite(u) ? (n += 1e3 * o, n += 6e4 * l, n += 36e5 * u) : -1) / 1e3, v = c / 9e4, -1 === h && (p = new Error(\"Malformed X-TIMESTAMP-MAP: \" + e));\n            } catch (t) {\n              p = new Error(\"Malformed X-TIMESTAMP-MAP: \" + e);\n            }\n\n            return;\n          }\n\n          \"\" === e && (y = !1);\n        }\n\n        var i, n, o, l, u;\n        m.parse(e + \"\\n\");\n      }), m.flush();\n    }\n  };\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(1)),\n      n = l(r(3)),\n      o = r(0),\n      s = r(7);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHED, i.default.MEDIA_DETACHING, i.default.MANIFEST_LOADED, i.default.SUBTITLE_TRACK_LOADED));\n\n      return r.tracks = [], r.trackId = -1, r.media = null, r.stopped = !0, r.subtitleDisplay = !0, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"destroy\",\n      value: function () {\n        n.default.prototype.destroy.call(this);\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        var t = this;\n        this.media = e.media, this.media && (this.queuedDefaultTrack && (this.subtitleTrack = this.queuedDefaultTrack, delete this.queuedDefaultTrack), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && \"onchange\" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function () {\n          t.trackChangeListener();\n        }, 500) : this.media.textTracks.addEventListener(\"change\", this.trackChangeListener));\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener(\"change\", this.trackChangeListener), this.media = null);\n      }\n    }, {\n      key: \"onManifestLoaded\",\n      value: function (e) {\n        var t = this,\n            r = e.subtitles || [];\n        this.tracks = r, this.hls.trigger(i.default.SUBTITLE_TRACKS_UPDATED, {\n          subtitleTracks: r\n        }), r.forEach(function (e) {\n          e.default && (t.media ? t.subtitleTrack = e.id : t.queuedDefaultTrack = e.id);\n        });\n      }\n    }, {\n      key: \"onSubtitleTrackLoaded\",\n      value: function (e) {\n        var t = this,\n            r = e.id,\n            a = e.details,\n            i = this.trackId,\n            n = this.tracks,\n            l = n[i];\n        if (r >= n.length || r !== i || !l || this.stopped) this._clearReloadTimer();else if (o.logger.log(\"subtitle track \" + r + \" loaded\"), a.live) {\n          var u = (0, s.computeReloadInterval)(l.details, a, e.stats.trequest);\n          o.logger.log(\"Reloading live subtitle playlist in \" + u + \"ms\"), this.timer = setTimeout(function () {\n            t._loadCurrentTrack();\n          }, u);\n        } else this._clearReloadTimer();\n      }\n    }, {\n      key: \"startLoad\",\n      value: function () {\n        this.stopped = !1, this._loadCurrentTrack();\n      }\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        this.stopped = !0, this._clearReloadTimer();\n      }\n    }, {\n      key: \"_clearReloadTimer\",\n      value: function () {\n        this.timer && (clearTimeout(this.timer), this.timer = null);\n      }\n    }, {\n      key: \"_loadCurrentTrack\",\n      value: function () {\n        var e = this.trackId,\n            t = this.tracks,\n            r = this.hls,\n            a = t[e];\n        e < 0 || !a || a.details && !a.details.live || (o.logger.log(\"Loading subtitle track \" + e), r.trigger(i.default.SUBTITLE_TRACK_LOADING, {\n          url: a.url,\n          id: e\n        }));\n      }\n    }, {\n      key: \"_toggleTrackModes\",\n      value: function (e) {\n        var t = this.media,\n            r = this.subtitleDisplay,\n            a = this.trackId;\n\n        if (t) {\n          var i = d(t.textTracks);\n          if (-1 === e) [].slice.call(i).forEach(function (e) {\n            e.mode = \"disabled\";\n          });else {\n            var n = i[a];\n            n && (n.mode = \"disabled\");\n          }\n          var o = i[e];\n          o && (o.mode = r ? \"showing\" : \"hidden\");\n        }\n      }\n    }, {\n      key: \"_setSubtitleTrackInternal\",\n      value: function (e) {\n        var t = this.hls,\n            r = this.tracks;\n        !Number.isFinite(e) || e < -1 || e >= r.length || (this.trackId = e, o.logger.log(\"Switching to subtitle track \" + e), t.trigger(i.default.SUBTITLE_TRACK_SWITCH, {\n          id: e\n        }), this._loadCurrentTrack());\n      }\n    }, {\n      key: \"_onTextTracksChanged\",\n      value: function () {\n        if (this.media) {\n          for (var e = -1, t = d(this.media.textTracks), r = 0; r < t.length; r++) if (\"hidden\" === t[r].mode) e = r;else if (\"showing\" === t[r].mode) {\n            e = r;\n            break;\n          }\n\n          this.subtitleTrack = e;\n        }\n      }\n    }, {\n      key: \"subtitleTracks\",\n      get: function () {\n        return this.tracks;\n      }\n    }, {\n      key: \"subtitleTrack\",\n      get: function () {\n        return this.trackId;\n      },\n      set: function (e) {\n        this.trackId !== e && (this._toggleTrackModes(e), this._setSubtitleTrackInternal(e));\n      }\n    }]), t;\n  }(n.default);\n\n  function d(e) {\n    for (var t = [], r = 0; r < e.length; r++) {\n      var a = e[r];\n      \"subtitles\" === a.kind && a.label && t.push(e[r]);\n    }\n\n    return t;\n  }\n\n  t.default = u, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.SubtitleStreamController = void 0;\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = h(r(1)),\n      n = r(0),\n      o = h(r(12)),\n      s = r(4),\n      l = r(27),\n      u = r(6),\n      d = r(14),\n      f = h(d),\n      c = r(7);\n\n  function h(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var v = window.performance;\n\n  t.SubtitleStreamController = function (e) {\n    function t(e, r) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var a = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i.default.MEDIA_ATTACHED, i.default.MEDIA_DETACHING, i.default.ERROR, i.default.KEY_LOADED, i.default.FRAG_LOADED, i.default.SUBTITLE_TRACKS_UPDATED, i.default.SUBTITLE_TRACK_SWITCH, i.default.SUBTITLE_TRACK_LOADED, i.default.SUBTITLE_FRAG_PROCESSED, i.default.LEVEL_UPDATED));\n\n      return a.fragmentTracker = r, a.config = e.config, a.state = d.State.STOPPED, a.tracks = [], a.tracksBuffered = [], a.currentTrackId = -1, a.decrypter = new o.default(e, e.config), a.lastAVStart = 0, a._onMediaSeeking = a.onMediaSeeking.bind(a), a;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"onSubtitleFragProcessed\",\n      value: function (e) {\n        var t = e.frag,\n            r = e.success;\n\n        if (this.fragPrevious = t, this.state = d.State.IDLE, r) {\n          var a = this.tracksBuffered[this.currentTrackId];\n\n          if (a) {\n            for (var i = void 0, n = t.start, o = 0; o < a.length; o++) if (n >= a[o].start && n <= a[o].end) {\n              i = a[o];\n              break;\n            }\n\n            var s = t.start + t.duration;\n            i ? i.end = s : (i = {\n              start: n,\n              end: s\n            }, a.push(i));\n          }\n        }\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        var t = e.media;\n        this.media = t, t.addEventListener(\"seeking\", this._onMediaSeeking), this.state = d.State.IDLE;\n      }\n    }, {\n      key: \"onMediaDetaching\",\n      value: function () {\n        this.media.removeEventListener(\"seeking\", this._onMediaSeeking), this.media = null, this.state = d.State.STOPPED;\n      }\n    }, {\n      key: \"onError\",\n      value: function (e) {\n        var t = e.frag;\n        t && \"subtitle\" === t.type && (this.state = d.State.IDLE);\n      }\n    }, {\n      key: \"onSubtitleTracksUpdated\",\n      value: function (e) {\n        var t = this;\n        n.logger.log(\"subtitle tracks updated\"), this.tracksBuffered = [], this.tracks = e.subtitleTracks, this.tracks.forEach(function (e) {\n          t.tracksBuffered[e.id] = [];\n        });\n      }\n    }, {\n      key: \"onSubtitleTrackSwitch\",\n      value: function (e) {\n        if (this.currentTrackId = e.id, this.tracks && -1 !== this.currentTrackId) {\n          var t = this.tracks[this.currentTrackId];\n          t && t.details && this.setInterval(500);\n        } else this.clearInterval();\n      }\n    }, {\n      key: \"onSubtitleTrackLoaded\",\n      value: function (e) {\n        var t = e.id,\n            r = e.details,\n            a = this.currentTrackId,\n            i = this.tracks,\n            n = i[a];\n        t >= i.length || t !== a || !n || (r.live && (0, c.mergeSubtitlePlaylists)(n.details, r, this.lastAVStart), n.details = r, this.setInterval(500));\n      }\n    }, {\n      key: \"onKeyLoaded\",\n      value: function () {\n        this.state === d.State.KEY_LOADING && (this.state = d.State.IDLE);\n      }\n    }, {\n      key: \"onFragLoaded\",\n      value: function (e) {\n        var t = this.fragCurrent,\n            r = e.frag.decryptdata,\n            a = e.frag,\n            n = this.hls;\n\n        if (this.state === d.State.FRAG_LOADING && t && \"subtitle\" === e.frag.type && t.sn === e.frag.sn && e.payload.byteLength > 0 && r && r.key && \"AES-128\" === r.method) {\n          var o = v.now();\n          this.decrypter.decrypt(e.payload, r.key.buffer, r.iv.buffer, function (e) {\n            var t = v.now();\n            n.trigger(i.default.FRAG_DECRYPTED, {\n              frag: a,\n              payload: e,\n              stats: {\n                tstart: o,\n                tdecrypt: t\n              }\n            });\n          });\n        }\n      }\n    }, {\n      key: \"onLevelUpdated\",\n      value: function (e) {\n        var t = e.details.fragments;\n        this.lastAVStart = t.length ? t[0].start : 0;\n      }\n    }, {\n      key: \"doTick\",\n      value: function () {\n        if (this.media) switch (this.state) {\n          case d.State.IDLE:\n            var e = this.config,\n                t = this.currentTrackId,\n                r = this.fragmentTracker,\n                a = this.media,\n                o = this.tracks;\n            if (!o || !o[t] || !o[t].details) break;\n            var f = e.maxBufferHole,\n                c = e.maxFragLookUpTolerance,\n                h = Math.min(e.maxBufferLength, e.maxMaxBufferLength),\n                v = s.BufferHelper.bufferedInfo(this._getBuffered(), a.currentTime, f),\n                g = v.end,\n                p = v.len,\n                y = o[t].details,\n                m = y.fragments,\n                b = m.length,\n                E = m[b - 1].start + m[b - 1].duration;\n            if (p > h) return;\n\n            var _ = void 0,\n                T = this.fragPrevious;\n\n            g < E ? (T && y.hasProgramDateTime && (_ = (0, l.findFragmentByPDT)(m, T.endProgramDateTime, c)), _ || (_ = (0, l.findFragmentByPTS)(T, m, g, c))) : _ = m[b - 1], _ && _.encrypted ? (n.logger.log(\"Loading key for \" + _.sn), this.state = d.State.KEY_LOADING, this.hls.trigger(i.default.KEY_LOADING, {\n              frag: _\n            })) : _ && r.getState(_) === u.FragmentState.NOT_LOADED && (this.fragCurrent = _, this.state = d.State.FRAG_LOADING, this.hls.trigger(i.default.FRAG_LOADING, {\n              frag: _\n            }));\n        } else this.state = d.State.IDLE;\n      }\n    }, {\n      key: \"stopLoad\",\n      value: function () {\n        this.lastAVStart = 0, function e(t, r, a) {\n          null === t && (t = Function.prototype);\n          var i = Object.getOwnPropertyDescriptor(t, r);\n\n          if (void 0 === i) {\n            var n = Object.getPrototypeOf(t);\n            return null === n ? void 0 : e(n, r, a);\n          }\n\n          if (\"value\" in i) return i.value;\n          var o = i.get;\n          return void 0 !== o ? o.call(a) : void 0;\n        }(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"stopLoad\", this).call(this);\n      }\n    }, {\n      key: \"_getBuffered\",\n      value: function () {\n        return this.tracksBuffered[this.currentTrackId] || [];\n      }\n    }, {\n      key: \"onMediaSeeking\",\n      value: function () {\n        this.fragPrevious = null;\n      }\n    }]), t;\n  }(f.default);\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n\n  var a = function () {\n    function e(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    return function (t, r, a) {\n      return r && e(t.prototype, r), a && e(t, a), t;\n    };\n  }(),\n      i = l(r(3)),\n      n = l(r(1)),\n      o = r(2),\n      s = r(0);\n\n  function l(e) {\n    return e && e.__esModule ? e : {\n      default: e\n    };\n  }\n\n  var u = window.XMLHttpRequest,\n      d = \"com.widevine.alpha\",\n      f = \"com.microsoft.playready\",\n      c = function (e) {\n    function t(e) {\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t);\n\n      var r = function (e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n.default.MEDIA_ATTACHED, n.default.MANIFEST_PARSED));\n\n      return r._widevineLicenseUrl = e.config.widevineLicenseUrl, r._licenseXhrSetup = e.config.licenseXhrSetup, r._emeEnabled = e.config.emeEnabled, r._requestMediaKeySystemAccess = e.config.requestMediaKeySystemAccessFunc, r._mediaKeysList = [], r._media = null, r._hasSetMediaKeys = !1, r._isMediaEncrypted = !1, r._requestLicenseFailureCount = 0, r;\n    }\n\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }(t, e), a(t, [{\n      key: \"getLicenseServerUrl\",\n      value: function (e) {\n        var t = void 0;\n\n        switch (e) {\n          case d:\n            t = this._widevineLicenseUrl;\n            break;\n\n          default:\n            t = null;\n        }\n\n        return t || (s.logger.error('No license server URL configured for key-system \"' + e + '\"'), this.hls.trigger(n.default.ERROR, {\n          type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n          details: o.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n          fatal: !0\n        })), t;\n      }\n    }, {\n      key: \"_attemptKeySystemAccess\",\n      value: function (e, t, r) {\n        var a = this,\n            i = function (e, t, r) {\n          switch (e) {\n            case d:\n              return function (e, t, r) {\n                var a = {\n                  videoCapabilities: []\n                };\n                return t.forEach(function (e) {\n                  a.videoCapabilities.push({\n                    contentType: 'video/mp4; codecs=\"' + e + '\"'\n                  });\n                }), [a];\n              }(0, r);\n\n            default:\n              throw Error(\"Unknown key-system: \" + e);\n          }\n        }(e, 0, r);\n\n        i ? (s.logger.log(\"Requesting encrypted media key-system access\"), this.requestMediaKeySystemAccess(e, i).then(function (t) {\n          a._onMediaKeySystemAccessObtained(e, t);\n        }).catch(function (t) {\n          s.logger.error('Failed to obtain key-system \"' + e + '\" access:', t);\n        })) : s.logger.warn(\"Can not create config for key-system (maybe because platform is not supported):\", e);\n      }\n    }, {\n      key: \"_onMediaKeySystemAccessObtained\",\n      value: function (e, t) {\n        var r = this;\n        s.logger.log('Access for key-system \"' + e + '\" obtained');\n        var a = {\n          mediaKeys: null,\n          mediaKeysSession: null,\n          mediaKeysSessionInitialized: !1,\n          mediaKeySystemAccess: t,\n          mediaKeySystemDomain: e\n        };\n        this._mediaKeysList.push(a), t.createMediaKeys().then(function (t) {\n          a.mediaKeys = t, s.logger.log('Media-keys created for key-system \"' + e + '\"'), r._onMediaKeysCreated();\n        }).catch(function (e) {\n          s.logger.error(\"Failed to create media-keys:\", e);\n        });\n      }\n    }, {\n      key: \"_onMediaKeysCreated\",\n      value: function () {\n        var e = this;\n\n        this._mediaKeysList.forEach(function (t) {\n          t.mediaKeysSession || (t.mediaKeysSession = t.mediaKeys.createSession(), e._onNewMediaKeySession(t.mediaKeysSession));\n        });\n      }\n    }, {\n      key: \"_onNewMediaKeySession\",\n      value: function (e) {\n        var t = this;\n        s.logger.log(\"New key-system session \" + e.sessionId), e.addEventListener(\"message\", function (r) {\n          t._onKeySessionMessage(e, r.message);\n        }, !1);\n      }\n    }, {\n      key: \"_onKeySessionMessage\",\n      value: function (e, t) {\n        s.logger.log(\"Got EME message event, creating license request\"), this._requestLicense(t, function (t) {\n          s.logger.log(\"Received license data, updating key-session\"), e.update(t);\n        });\n      }\n    }, {\n      key: \"_onMediaEncrypted\",\n      value: function (e, t) {\n        s.logger.log('Media is encrypted using \"' + e + '\" init data type'), this._isMediaEncrypted = !0, this._mediaEncryptionInitDataType = e, this._mediaEncryptionInitData = t, this._attemptSetMediaKeys(), this._generateRequestWithPreferredKeySession();\n      }\n    }, {\n      key: \"_attemptSetMediaKeys\",\n      value: function () {\n        if (!this._hasSetMediaKeys) {\n          var e = this._mediaKeysList[0];\n          if (!e || !e.mediaKeys) return s.logger.error(\"Fatal: Media is encrypted but no CDM access or no keys have been obtained yet\"), void this.hls.trigger(n.default.ERROR, {\n            type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n            details: o.ErrorDetails.KEY_SYSTEM_NO_KEYS,\n            fatal: !0\n          });\n          s.logger.log(\"Setting keys for encrypted media\"), this._media.setMediaKeys(e.mediaKeys), this._hasSetMediaKeys = !0;\n        }\n      }\n    }, {\n      key: \"_generateRequestWithPreferredKeySession\",\n      value: function () {\n        var e = this,\n            t = this._mediaKeysList[0];\n        if (!t) return s.logger.error(\"Fatal: Media is encrypted but not any key-system access has been obtained yet\"), void this.hls.trigger(n.default.ERROR, {\n          type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n          details: o.ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n          fatal: !0\n        });\n        if (t.mediaKeysSessionInitialized) s.logger.warn(\"Key-Session already initialized but requested again\");else {\n          var r = t.mediaKeysSession;\n          r || (s.logger.error(\"Fatal: Media is encrypted but no key-session existing\"), this.hls.trigger(n.default.ERROR, {\n            type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n            details: o.ErrorDetails.KEY_SYSTEM_NO_SESSION,\n            fatal: !0\n          }));\n          var a = this._mediaEncryptionInitDataType,\n              i = this._mediaEncryptionInitData;\n          s.logger.log('Generating key-session request for \"' + a + '\" init data type'), t.mediaKeysSessionInitialized = !0, r.generateRequest(a, i).then(function () {\n            s.logger.debug(\"Key-session generation succeeded\");\n          }).catch(function (t) {\n            s.logger.error(\"Error generating key-session request:\", t), e.hls.trigger(n.default.ERROR, {\n              type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n              details: o.ErrorDetails.KEY_SYSTEM_NO_SESSION,\n              fatal: !1\n            });\n          });\n        }\n      }\n    }, {\n      key: \"_createLicenseXhr\",\n      value: function (e, t, r) {\n        var a = new u(),\n            i = this._licenseXhrSetup;\n\n        try {\n          if (i) try {\n            i(a, e);\n          } catch (t) {\n            a.open(\"POST\", e, !0), i(a, e);\n          }\n          a.readyState || a.open(\"POST\", e, !0);\n        } catch (e) {\n          return s.logger.error(\"Error setting up key-system license XHR\", e), void this.hls.trigger(n.default.ERROR, {\n            type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n            details: o.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n            fatal: !0\n          });\n        }\n\n        return a.responseType = \"arraybuffer\", a.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, a, e, t, r), a;\n      }\n    }, {\n      key: \"_onLicenseRequestReadyStageChange\",\n      value: function (e, t, r, a) {\n        switch (e.readyState) {\n          case 4:\n            if (200 === e.status) this._requestLicenseFailureCount = 0, s.logger.log(\"License request succeeded\"), a(e.response);else {\n              if (s.logger.error(\"License Request XHR failed (\" + t + \"). Status: \" + e.status + \" (\" + e.statusText + \")\"), this._requestLicenseFailureCount++, this._requestLicenseFailureCount <= 3) {\n                var i = 3 - this._requestLicenseFailureCount + 1;\n                return s.logger.warn(\"Retrying license request, \" + i + \" attempts left\"), void this._requestLicense(r, a);\n              }\n\n              this.hls.trigger(n.default.ERROR, {\n                type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n                details: o.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: !0\n              });\n            }\n        }\n      }\n    }, {\n      key: \"_generateLicenseRequestChallenge\",\n      value: function (e, t) {\n        var r = void 0;\n        return e.mediaKeySystemDomain === f ? s.logger.error(\"PlayReady is not supported (yet)\") : e.mediaKeySystemDomain === d ? r = t : s.logger.error(\"Unsupported key-system:\", e.mediaKeySystemDomain), r;\n      }\n    }, {\n      key: \"_requestLicense\",\n      value: function (e, t) {\n        s.logger.log(\"Requesting content license for key-system\");\n        var r = this._mediaKeysList[0];\n        if (!r) return s.logger.error(\"Fatal error: Media is encrypted but no key-system access has been obtained yet\"), void this.hls.trigger(n.default.ERROR, {\n          type: o.ErrorTypes.KEY_SYSTEM_ERROR,\n          details: o.ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n          fatal: !0\n        });\n\n        var a = this.getLicenseServerUrl(r.mediaKeySystemDomain),\n            i = this._createLicenseXhr(a, e, t);\n\n        s.logger.log(\"Sending license request to URL: \" + a), i.send(this._generateLicenseRequestChallenge(r, e));\n      }\n    }, {\n      key: \"onMediaAttached\",\n      value: function (e) {\n        var t = this;\n\n        if (this._emeEnabled) {\n          var r = e.media;\n          this._media = r, r.addEventListener(\"encrypted\", function (e) {\n            t._onMediaEncrypted(e.initDataType, e.initData);\n          });\n        }\n      }\n    }, {\n      key: \"onManifestParsed\",\n      value: function (e) {\n        if (this._emeEnabled) {\n          var t = e.levels.map(function (e) {\n            return e.audioCodec;\n          }),\n              r = e.levels.map(function (e) {\n            return e.videoCodec;\n          });\n\n          this._attemptKeySystemAccess(d, t, r);\n        }\n      }\n    }, {\n      key: \"requestMediaKeySystemAccess\",\n      get: function () {\n        if (!this._requestMediaKeySystemAccess) throw new Error(\"No requestMediaKeySystemAccess function configured\");\n        return this._requestMediaKeySystemAccess;\n      }\n    }]), t;\n  }(i.default);\n\n  t.default = c, e.exports = t.default;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = \"undefined\" != typeof window && window.navigator && window.navigator.requestMediaKeySystemAccess ? window.navigator.requestMediaKeySystemAccess.bind(window.navigator) : null;\n  t.requestMediaKeySystemAccess = a;\n}, function (e, t, r) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = {\n    getBrowserVersion: function () {\n      var e = navigator.userAgent;\n      if (e.toLowerCase().indexOf(\"mobile\") > -1) return \"Unknown\";\n      if (e.indexOf(\"Firefox\") > -1) return \"Firefox \" + e.match(/firefox\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n      if (e.indexOf(\"Edge\") > -1) return \"Edge \" + e.match(/edge\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n      if (e.indexOf(\"rv:11\") > -1) return \"IE 11\";\n\n      if (e.indexOf(\"Opera\") > -1 || e.indexOf(\"OPR\") > -1) {\n        if (e.indexOf(\"Opera\") > -1) return \"Opera \" + e.match(/opera\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n        if (e.indexOf(\"OPR\") > -1) return \"Opera \" + e.match(/opr\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n      } else {\n        if (e.indexOf(\"Chrome\") > -1) return \"Chrome \" + e.match(/chrome\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n        if (e.indexOf(\"Safari\") > -1) return \"Safari \" + e.match(/safari\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n        if (!(e.indexOf(\"MSIE\") > -1 || e.indexOf(\"Trident\") > -1)) return \"Unknown\";\n        if (e.indexOf(\"MSIE\") > -1) return \"IE \" + e.match(/msie [\\d.]+/gi)[0].match(/[\\d]+/)[0];\n\n        if (e.indexOf(\"Trident\") > -1) {\n          var t = e.match(/trident\\/[\\d.]+/gi)[0].match(/[\\d]+/)[0];\n          return \"IE \" + (parseInt(t) + 4);\n        }\n      }\n    }\n  };\n  t.default = a, e.exports = t.default;\n}]);","map":null,"metadata":{},"sourceType":"script"}